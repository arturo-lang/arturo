import 'rosetta!

API_URL: "https://rosettacode.org/w/api.php"
SESSION_COOKIES: #[]

LOGIN_TRIES: 2

login: function [username, password][
    loop LOGIN_TRIES 'x [
        tokenParams: #[
            action: "query"
            meta: "tokens"
            type: "login"
            format: "json"
        ]
        
        tokenResp: request.get API_URL tokenParams
        if tokenResp\status <> 200 -> return false
        
        cookies: tokenResp\headers\["set-cookie"]
        if string? cookies -> cookies: @[cookies]
        
        loop cookies 'cookie [
            parts: split.by:";" cookie
            nameVal: split.by:"=" first parts
            if 2 = size nameVal ->
                SESSION_COOKIES\[first nameVal]: last nameVal
        ]
        
        tokenData: read.json tokenResp\body
        loginToken: tokenData\query\tokens\logintoken
        
        cookieStr: join.with:"; " map keys SESSION_COOKIES 'k -> join @[k "=" SESSION_COOKIES\[k]]
        
        loginParams: #[
            action: "login"
            lgname: username
            lgpassword: password
            lgtoken: loginToken
            format: "json"
        ]
        
        loginResp: request.post .headers: #[
            Cookie: cookieStr
        ] API_URL loginParams

        if loginResp\status <> 200 -> return false
        
        newCookies: loginResp\headers\["set-cookie"]
        if string? newCookies -> newCookies: @[newCookies]
        
        loop newCookies 'cookie [
            parts: split.by:";" cookie
            nameVal: split.by:"=" first parts
            if 2 = size nameVal ->
                SESSION_COOKIES\[first nameVal]: last nameVal
        ]
        
        loginData: read.json loginResp\body
        
        if loginData\login\result = "Success" -> return true

        pause 1500
    ]

    return false
]

editPage: function [title, content, summary][
    cookieStr: join.with:"; " map keys SESSION_COOKIES 'k -> join @[k "=" SESSION_COOKIES\[k]]
    
    userParams: #[
        action: "query"
        meta: "userinfo"
        format: "json"
    ]
    
    userResp: request.get .headers: #[Cookie: cookieStr] API_URL userParams
    
    userData: read.json userResp\body
    
    if key? userData\query\userinfo 'anon [
        print "ERROR: Not logged in!"
        return false
    ]
    
    tokenParams: #[
        action: "query"
        meta: "tokens"
        format: "json"
    ]
    
    tokenResp: request.get .headers: #[Cookie: cookieStr] API_URL tokenParams
    tokenData: read.json tokenResp\body
    
    if key? tokenData 'error [
        print ["Token Error:" tokenData\error\code "-" tokenData\error\info]
        return false
    ]
    
    editToken: tokenData\query\tokens\csrftoken
    
    editParams: #[
        action: "edit"
        title: title
        text: content
        summary: summary
        token: editToken
        minor: "true"
        format: "json"
    ]
    
    editResp: request.post .headers: #[Cookie: cookieStr] API_URL editParams
    
    if editResp\status <> 200 -> return false
    
    editData: read.json editResp\body
    
    if key? editData 'error -> return false
    
    return key? editData 'edit
]

fetchTaskBody: function [taskName][
    errorMsg: function [msg][
        #[
            code: "",
            output: msg
            rebol?: true
        ]
    ]
    
    params: #[
        action: "parse"
        page: taskName
        prop: "wikitext"
        format: "json"
    ]
    response: request API_URL params
    if response\status <> 200 [
        return ""
    ]
    body: ø
    if try [
        body: read.json response\body
    ] [
        return ""
    ]
    
    unless key? body\parse 'wikitext -> return ""
    
    wikitext: first values body\parse\wikitext

    return wikitext
]

; Connect to RosettaCode
rc: to :Rosetta []!

; Get all implemented tasks for Arturo
tasks: rc\implemented "Arturo"

; Keep the ones whose files we can easily spot
; and have a solution (= are used as unit-tests)
tasks: select tasks 'task [
   res: and? exists? ~"examples/rosetta/|lower task\title|.art"
             exists? ~"examples/rosetta/|lower task\title|.res"
   unless res [
       unless exists? ~"examples/rosetta/|lower task\title|.art" [
            print task\title
       ]
   ]
   res
]

notOKs: map read.lines ./"notok.lst" => strip

;loop select tasks 'task -> contains? notOKs task\title 'task [!
print size tasks
loop [] 'task [!
    prints pad.right truncate task\title 60 60

    arturo: task\solution "Arturo"
    have: strip (first arturo\code) ?? ""
    got: strip (read ~"examples/rosetta/|lower task\title|.art") ?? ""

    haveblock: {<syntaxhighlight lang="arturo">} ++ have ++ {</syntaxhighlight>}
    haveblock2: {<syntaxhighlight lang="rebol">} ++ have ++ {</syntaxhighlight>}
    gotblock: {<syntaxhighlight lang="arturo">} ++ got ++ {</syntaxhighlight>}

    haveOK?: or? [contains? task\content haveblock][contains? task\content haveblock2]
    gotOK?: contains? task\content gotblock

    copyrightOK?: have = strip replace got {/; by @\w+/} ""

    unless copyrightOK? [
        gotblock: {<syntaxhighlight lang="arturo">} ++ (strip replace got {/; by @\w+/} "") ++ {</syntaxhighlight>}
    ]

    ;print [haveOK? gotOK?]

    ; task\content >> "content"
    ; haveblock >> "haveblock"
    ; have >> "have"
    ; got >> "got"

    ;print have

    correct: replace replace task\content haveblock gotblock haveblock2 gotblock
    

    switch or? have = got copyrightOK? [
        print color #green "OK"
    ][
        switch haveOK? [
            print color.bold #red "X"
            print execute "diff have got"
            prints "\tUpdate? [y/n]"
            ch: input ø
            switch ch = 'y' [
                print "\nupdating..."

                switch login "drkameleon" read.file ./"PW" [
                    ;print "\t> Logged in"

                    print (editPage task\title correct "updated Arturo solution")? 
                        -> color #green "[  DONE ]"
                        -> color #red   "[ ERROR ]"
                ][
                    print color #red "[ ERROR*]"
                ]
            ][
                print ""
            ]
        ][
            print color.bold #red "X"
        ]
    ]
]