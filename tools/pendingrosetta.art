import'progressive!
import'tabular!
import'unidecode!

;------------------------------------------
; Configuration
;------------------------------------------

API_URL: "https://rosettacode.org/w/api.php"

;------------------------------------------
; Helper Functions
;------------------------------------------

fetchCategory: function [category][
    results: []
    continue: ""
    
    while ø [
        params: #[
            action: "query"
            list: "categorymembers"
            cmtitle: ~"Category:|category|"
            cmlimit: "500"
            format: "json"
        ]
        
        unless empty? continue ->
            params\cmcontinue: continue

        response: request API_URL params
        body: read.json response\body
        
        'results ++ map body\query\categorymembers 'page ->
            page\title
            
        switch key? body 'continue 
            -> continue: body\continue\cmcontinue
            -> break
    ]
    
    return results
]

fetchTaskSolution: function [taskName, language][
    ;------------------------------------------
    ; Fetch the raw wikitext for the task
    ;------------------------------------------
    
    params: #[
        action: "parse"
        page: taskName
        prop: "wikitext"
        format: "json"
    ]
    
    response: request API_URL params
    body: read.json response\body
    
    ; Check if page exists
    unless key? body\parse 'wikitext [
        print color #red "Error: Task not found!"
        return null
    ]
    
    ; Get the wikitext content
    wikitextObj: body\parse\wikitext
    wikitext: first values wikitextObj
    
    ;------------------------------------------
    ; Extract the section for the given language
    ;------------------------------------------

    syntaxStart: {<syntaxhighlight}
    rebolSyntax: {<syntaxhighlight lang="rebol">}
    arturoSyntax: {<syntaxhighlight lang="arturo">}
    syntaxEnd: {</syntaxhighlight>}

    preStart: {<pre>}
    preEnd: {</pre>}
    
    ; Create the header pattern to search for
    headerStart: "=={{header|"
    headerPattern: headerStart ++ language ++ "}}=="

    ;print ["===>" size split.by:headerPattern wikitext "sections found"]
    main: last split.by:headerPattern wikitext
    if main = wikitext ->
        panic "Arturo section not found"
    main: strip first split.by:headerStart main

    code?: false
    output?: false

    hasOldRebolTag?: false

    code: ""
    output: ""

    i: 0
    while [i < size main][
        substr: drop.times: i main
        ch: main\[i]

        when.has: substr [
            [|prefix? syntaxEnd][
                i: i + dec size syntaxEnd
                code?: false
            ]
            [|prefix? preEnd][
                output?: false
            ]
        ]

        if code?    -> code: code ++ ch
        if output?  -> output: output ++ ch

        when.has: substr [
            [|prefix? syntaxStart][
                when.has: substr [
                    [|prefix? rebolSyntax][
                        i: i + dec size rebolSyntax
                        hasOldRebolTag?: true
                        code?: true
                    ]
                    [|prefix? arturoSyntax][
                        i: i + dec size arturoSyntax
                        code?: true
                    ]
                    true [
                        return #[
                            code: "Unrecognized syntax marker"
                            output: ""
                            rebol?: hasOldRebolTag?
                        ]
                    ]
                ]
            ]
            [|prefix? preStart][
                i: i + dec size preStart
                output?: true
            ]
        ]

        i: i + 1
    ]

    return #[
        code: code
        output: output
        rebol?: hasOldRebolTag?
    ]
]

checkSolution: function [fname,name][
    source: read ./~"../examples/rosetta/|fname|.art"
    output: read ./~"../examples/rosetta/|fname|.res"

    fetched: fetchTaskSolution name "Arturo"
    ;return fetched

    return #[
        codeOK?: to :string fetched\code = source
        outputOK?: to :string fetched\output = output
        oldTags?: to :string fetched\rebol?
    ]
    ; print (fetched\code = source) ?
    ;     -> color #green "SOURCE OK"
    ;     -> color #red "SOURCE ERROR"
    
    ; print ["fetched:" fetched\code]
    ; print ["was:" source]

    ; print (fetched\output = output) ?
    ;     -> color #green "OUTPUT OK"
    ;     -> color #red "OUTPUT ERROR"

    ; print ["fetched:" fetched\output]
    ; print ["was:" output]
]
;checkSolution "100 prisoners"

prints " • Fetching remote tasks implemented in Arturo..."
rcTasks: "arturo" 
    | fetchCategory
    | filter => [& = "Category:Arturo User"]
print color #green " OK"

prints " • Getting local tasks..."
localTasks: "examples/rosetta" 
    | list
    | select => [suffix? & ".art"]
    | map => [extract.filename &]
print color #green " OK"

print " • Matching tasks..."
result: #[]
progressive\loop.keep localTasks 'tsk [
    processing tsk
    sanitized: strip first split.by:"--" replace tsk " - " "/"
    found: ø
    loop rcTasks 'rct [
        if sanitized = unidecode lower rct [
            found: rct
            break
        ]
    ]
    result\[tsk]: found
]

unmatchedRcTasks: difference rcTasks values result

loop result [k,v][
    if null? v [
        print color #gray "\tNot found: " ++ k
        sanitized: strip first split.by:"--" replace k " - " "/"
        found: minimum unmatchedRcTasks 'rct ->
            levenshtein sanitized unidecode lower rct
        result\[k]: found
        print color #gray "\t\t-> Matched with: " ++ found
    ]
]

unmatchedRcTasks: difference rcTasks values result
nofTasks: (size unmatchedRcTasks) + size unique values result

print color #cyan repeat "-" 60
print [" •  Found" size result "files"]
print [" • " nofTasks "tasks solved in total (" size unmatchedRcTasks "only on RC )"]
print color #cyan repeat "-" 60

print " • Checking tasks..."
stats: #[]
tblrows: []
result: arrange result [k,v]-> v
progressive\loop.keep first.n:10 keys result 'kk [
    vv: result\[kk]
    processing kk

    check: checkSolution kk vv
    ;stats\[kk]: checkSolution kk vv

    'tblrows ++ @[flatten @[vv values check]]
    ; sanitized: strip first split.by:"--" replace tsk " - " "/"
    ; found: ø
    ; loop rcTasks 'rct [
    ;     if sanitized = unidecode lower rct [
    ;         found: rct
    ;         break
    ;     ]
    ; ]
    ; result\[tsk]: found
]

;inspect rows
print tabular.header:["Task" "Solution" "Output" "Older tags"] tblrows