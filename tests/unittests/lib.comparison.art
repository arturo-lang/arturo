; helper function
debug: $[variable][
    print[variable type variable]
]

topic: $[topic :string] -> print ~"\n>> |topic|"
passed: $[] -> print "[+] passed!"


; ==> Tests

topic « compare
do [
    
    
    topic « compare - :integer :floating :rational
    
    ensure -> 0 = compare 1 1
    ensure -> 0 = compare 1 1.0
    ensure -> 0 = compare 1 to :rational @[1 1]
    ensure -> 0 = compare 1 to :rational @[5 5]
    passed
    
    ensure -> (neg 1) = compare 1 2
    ensure -> (neg 1) = compare 1 2.0
    ensure -> (neg 1) = compare 1 to :rational @[2 1]
    passed
    
    ensure -> 1 = compare 2 1
    ensure -> 1 = compare 2 1.0
    ensure -> 1 = compare 2 to :rational @[1 1]
    passed
    
    
    ensure -> 0 = compare 1.0 1.0
    ensure -> 0 = compare 1.0 1
    ensure -> 0 = compare 1.0 to :rational @[1 1]
    ensure -> 0 = compare 1.0 to :rational @[5 5]
    passed
    
    ensure -> (neg 1) = compare 1.0 2.0
    ensure -> (neg 1) = compare 1.0 2
    ensure -> (neg 1) = compare 1.0 to :rational @[2 1]
    passed
    
    ensure -> 1 = compare 2.0 1.0
    ensure -> 1 = compare 2.0 1
    ensure -> 1 = compare 2.0 to :rational @[1 1]
    passed
    
    
    ensure -> 0 = compare to :rational @[1 1] to :rational @[5 5]
    ensure -> 0 = compare to :rational @[1 1] 1
    ensure -> 0 = compare to :rational @[1 1] 1.0
    passed
    
    ensure -> (neg 1) = compare to :rational @[1 1] to :rational @[2 1]
    ensure -> (neg 1) = compare to :rational @[1 1] 2
    ensure -> (neg 1) = compare to :rational @[1 1] 2.0
    passed
    
    ensure -> 1 = compare to :rational @[2 1] to :rational @[5 5]
    ensure -> 1 = compare to :rational @[2 1] 1
    ensure -> 1 = compare to :rational @[2 1] 1.0
    passed
    
    
    topic « compare - :quantity
    
    ensure -> 0 = compare 1`usd 1
    ensure -> 0 = compare 1`m   1
    ensure -> 0 = compare 1`m2  1
    ensure -> 0 = compare 1`m3  1
    ensure -> 0 = compare 1`c   1
    ensure -> 0 = compare 1`f   1
    ensure -> 0 = compare 1 1`usd
    ensure -> 0 = compare 1 1`m
    ensure -> 0 = compare 1 1`m2
    ensure -> 0 = compare 1 1`m3
    ensure -> 0 = compare 1 1`c
    ensure -> 0 = compare 1 1`f
    passed
    
    ensure -> 0 = compare 1`usd 1.0
    ensure -> 0 = compare 1`m   1.0
    ensure -> 0 = compare 1`m2  1.0
    ensure -> 0 = compare 1`m3  1.0
    ensure -> 0 = compare 1`c   1.0
    ensure -> 0 = compare 1`f   1.0
    ensure -> 0 = compare 1.0 1`usd
    ensure -> 0 = compare 1.0 1`m
    ensure -> 0 = compare 1.0 1`m2
    ensure -> 0 = compare 1.0 1`m3
    ensure -> 0 = compare 1.0 1`c
    ensure -> 0 = compare 1.0 1`f
    passed
    
    ensure -> 0 = compare 1`usd to :rational @[5 5]
    ensure -> 0 = compare 1`m   to :rational @[5 5]
    ensure -> 0 = compare 1`m2  to :rational @[5 5]
    ensure -> 0 = compare 1`m3  to :rational @[5 5]
    ensure -> 0 = compare 1`c   to :rational @[5 5]
    ensure -> 0 = compare 1`f   to :rational @[5 5]
    ensure -> 0 = compare to :rational @[5 5] 1`usd
    ensure -> 0 = compare to :rational @[5 5] 1`m
    ensure -> 0 = compare to :rational @[5 5] 1`m2
    ensure -> 0 = compare to :rational @[5 5] 1`m3
    ensure -> 0 = compare to :rational @[5 5] 1`c
    ensure -> 0 = compare to :rational @[5 5] 1`f
    passed
    
    
    ensure -> 1 = compare 2`usd 1
    ensure -> 1 = compare 2`m   1
    ensure -> 1 = compare 2`m2  1
    ensure -> 1 = compare 2`m3  1
    ensure -> 1 = compare 2`c   1
    ensure -> 1 = compare 2`f   1
    ensure -> 1 = compare 2 1`usd
    ensure -> 1 = compare 2 1`m
    ensure -> 1 = compare 2 1`m2
    ensure -> 1 = compare 2 1`m3
    ensure -> 1 = compare 2 1`c
    ensure -> 1 = compare 2 1`f
    passed
    
    ensure -> 1 = compare 2`usd 1.0
    ensure -> 1 = compare 2`m   1.0
    ensure -> 1 = compare 2`m2  1.0
    ensure -> 1 = compare 2`m3  1.0
    ensure -> 1 = compare 2`c   1.0
    ensure -> 1 = compare 2`f   1.0
    ensure -> 1 = compare 2.0 1`usd
    ensure -> 1 = compare 2.0 1`m
    ensure -> 1 = compare 2.0 1`m2
    ensure -> 1 = compare 2.0 1`m3
    ensure -> 1 = compare 2.0 1`c
    ensure -> 1 = compare 2.0 1`f
    passed
    
    ensure -> 1 = compare 2`usd to :rational @[5 5]
    ensure -> 1 = compare 2`m   to :rational @[5 5]
    ensure -> 1 = compare 2`m2  to :rational @[5 5]
    ensure -> 1 = compare 2`m3  to :rational @[5 5]
    ensure -> 1 = compare 2`c   to :rational @[5 5]
    ensure -> 1 = compare 2`f   to :rational @[5 5] 
    ensure -> 1 = compare to :rational @[2 1] 1`usd
    ensure -> 1 = compare to :rational @[2 1] 1`m
    ensure -> 1 = compare to :rational @[2 1] 1`m2
    ensure -> 1 = compare to :rational @[2 1] 1`m3
    ensure -> 1 = compare to :rational @[2 1] 1`c
    ensure -> 1 = compare to :rational @[2 1] 1`f
    passed
    
    
    ensure -> (neg 1) = compare 1`usd 2
    ensure -> (neg 1) = compare 1`m   2
    ensure -> (neg 1) = compare 1`m2  2
    ensure -> (neg 1) = compare 1`m3  2
    ensure -> (neg 1) = compare 1`c   2
    ensure -> (neg 1) = compare 1`f   2
    ensure -> (neg 1) = compare 1 2`usd
    ensure -> (neg 1) = compare 1 2`m
    ensure -> (neg 1) = compare 1 2`m2
    ensure -> (neg 1) = compare 1 2`m3
    ensure -> (neg 1) = compare 1 2`c
    ensure -> (neg 1) = compare 1 2`f
    passed
    
    ensure -> (neg 1) = compare 1`usd 2.0
    ensure -> (neg 1) = compare 1`m   2.0
    ensure -> (neg 1) = compare 1`m2  2.0
    ensure -> (neg 1) = compare 1`m3  2.0
    ensure -> (neg 1) = compare 1`c   2.0
    ensure -> (neg 1) = compare 1`f   2.0
    ensure -> (neg 1) = compare 1.0 2`usd
    ensure -> (neg 1) = compare 1.0 2`m
    ensure -> (neg 1) = compare 1.0 2`m2
    ensure -> (neg 1) = compare 1.0 2`m3
    ensure -> (neg 1) = compare 1.0 2`c
    ensure -> (neg 1) = compare 1.0 2`f
    passed
    
    ensure -> (neg 1) = compare 1`usd to :rational @[2 1]
    ensure -> (neg 1) = compare 1`m   to :rational @[2 1]
    ensure -> (neg 1) = compare 1`m2  to :rational @[2 1]
    ensure -> (neg 1) = compare 1`m3  to :rational @[2 1]
    ensure -> (neg 1) = compare 1`c   to :rational @[2 1]
    ensure -> (neg 1) = compare 1`f   to :rational @[2 1] 
    ensure -> (neg 1) = compare to :rational @[1 1] 2`usd
    ensure -> (neg 1) = compare to :rational @[1 1] 2`m
    ensure -> (neg 1) = compare to :rational @[1 1] 2`m2
    ensure -> (neg 1) = compare to :rational @[1 1] 2`m3
    ensure -> (neg 1) = compare to :rational @[1 1] 2`c
    ensure -> (neg 1) = compare to :rational @[1 1] 2`f
    passed
    
    
    topic « compare - :null
    
    ensure -> 0 = compare null null
    ensure -> 0 = compare null ø
    ensure -> 0 = compare ø ø
    ensure -> 0 = compare ø null
    passed
    
    
    topic « compare - :logical
    
    ensure -> 0 = compare true true
    ensure -> 0 = compare true (1 > 0)
    ensure -> 0 = compare false false
    ensure -> 0 = compare false (1 < 0)
    ensure -> 0 = compare maybe maybe
    passed
    
    
    topic « compare - :complex
    
    ; comparing re
    ensure -> 0 = compare to :complex [1 2] to :complex [1 2]
    ensure -> 1 = compare to :complex [2 2] to :complex [1 2] 
    ensure -> (neg 1) = compare to :complex [1 2] to :complex [2 2] 
    passed
    
    ; comparing im
    ensure -> 0 = compare to :complex [1 2] to :complex [1 2]
    ensure -> 1 = compare to :complex [1 2] to :complex [1 1] 
    ensure -> (neg 1) = compare to :complex [1 1] to :complex [1 2] 
    passed
    
    
    topic « compare - :version
    
    ensure -> 0 = compare 1.2.3 1.2.3
    ensure -> (neg 1) = compare 1.2.2 1.2.3
    ensure -> 1 = compare 1.2.3 1.2.2
    passed
    
    
    topic « compare - :type
    
    ensure -> 0 = compare :string type "a"
    ensure -> 0 = compare :integer type 1
    ensure -> 0 = compare :floating type 1.5
    passed
    
    
    topic « compare - :char
    
    ensure -> 0 = compare 'a' 'a'
    ensure -> (neg 1) = compare 'a' 'b'
    ensure -> 1 = compare 'b' 'a'
    passed
    
    
    topic « compare - :string
    
    ensure -> 0 = compare "Arturo" "Arturo"
    ensure -> (neg 1) = compare "Arturo" "Ruby"
    ensure -> 1 = compare "Python" "Arturo"
    passed
    
    
    topic « compare - :word
    
    ensure -> 1 = compare to :word "b" to :word "a"
    ensure -> 0 = compare to :word "a" to :word "a"
    ensure -> 0 = compare to :word "b" to :word "b"
    ensure -> (neg 1) = compare to :word "a" to :word "b"
    passed
    
    
    topic « compare - :label
    
    ensure -> 1 = compare to :label "b" to :label "a"
    ensure -> 0 = compare to :label "a" to :label "a"
    ensure -> 0 = compare to :label "b" to :label "b"
    ensure -> (neg 1) = compare to :label "a" to :label "b"
    passed

    
    topic « compare - :literal
    
    ensure -> 0 = compare 'arturo 'arturo   
    ensure -> (neg 1) = compare 'arturo 'barry  
    ensure -> 1 = compare 'barry 'arturo   
    passed
    
    
    topic « compare - :attribute
    
    ensure -> 1 = compare to :attribute "b" to :attribute "a"
    ensure -> 0 = compare to :attribute "a" to :attribute "a"
    ensure -> 0 = compare to :attribute "b" to :attribute "b"
    ensure -> (neg 1) = compare to :attribute "a" to :attribute "b"
    passed
    
    
    topic « compare - :attributelabel
    
    ensure -> 1 = compare to :attributelabel "b" to :attributelabel "a"
    ensure -> 0 = compare to :attributelabel "a" to :attributelabel "a"
    ensure -> 0 = compare to :attributelabel "b" to :attributelabel "b"
    ensure -> (neg 1) = compare to :attributelabel "a" to :attributelabel "b"
    passed
    
    
    topic « compare - :path
    
    a: [a\b], b: [b\a]
    
    ensure -> 0 = compare a\0 a\0
    ensure -> 0 = compare b\0 b\0
    ; ensure -> (neg 1) = compare a\0 b\0 
    ; ensure -> 1 = compare b\0 a\0
    passed
    
    
    topic « compare - :pathLabel
    
    a: [a\b:], b: [b\a:]
    
    ensure -> 0 = compare a\0 a\0
    ensure -> 0 = compare b\0 b\0
    ; ensure -> (neg 1) = compare a\0 b\0 
    ; ensure -> 1 = compare b\0 a\0
    passed
    
    
    topic « compare - :symbol
    
    ensure -> 0 = compare [+] [+]
    ; ensure -> 1 = compare [+] [-]
    passed
    
    
    topic « compare - :regex
    
    ensure -> 0 = compare {/[A-Z]/} {/[A-Z]/} 
    ; ensure -> (neg 1) = compare {/[A]/} {/[Z]/} 
    ensure -> 1 = compare {/[Z]/} {/[A]/} 
    passed
    
    
    topic « compare - :binary
    
    ensure -> 0 = compare to :binary 0 to :binary 0
    ; ensure -> (neg 1) = compare to :binary 0 to :binary 1
    ensure -> 1 = compare to :binary 1 to :binary 0
    passed
    
    
    topic « compare - :bytecode
    
    x: to :bytecode [["print"][1 112 155]]
    
    ensure -> 0 = compare x to :bytecode [["print"][1 112 155]]
    passed
    
    
    topic « compare - :inline
    
    a: [(1)] b: [(1 2)]
    
    ensure -> 0 = compare a\0 a\0
    ensure -> 0 = compare b\0 b\0
    ensure -> (neg 1) = compare a\0 b\0
    ensure -> 1 = compare b\0 a\0
    passed

    
    topic « compare - :block
    
    a: [1] b: [1 2]
    
    ensure -> 0 = compare a a
    ensure -> 0 = compare b b
    ensure -> (neg 1) = compare a b
    ensure -> 1 = compare b a
    passed
    
    
    topic « compare - :range
    
    a: 1..10 b: 10..30
    
    ensure -> 0 = compare a a
    ensure -> 0 = compare b b
    ; ensure -> (neg 1) = compare a b
    ; ensure -> 1 = compare b a
    passed
    
    
    topic « compare - :dictionary
    
    a: #[name: "Walter" surname: "Pinkman"]
    
    ensure -> 0 = compare a #[name: "Walter" surname: "Pinkman"]
    ; ensure -> 1 = compare a #[name: "Jesse" surname: "Pinkman"]
    ; ensure -> (neg 1) = compare a #[name: "Walter" surname: "Pinkman" age: 35]
    ; ensure -> (neg 1) = compare a #[name: "Zalter" surname: "Rinkman"]
    passed
    
    
    topic « compare - :object
    
    define :person [  
        init: method [name, age][
            this\name: capitalize name
            this\age: age
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|"
        ]
        compare: method [that][
            if this\age > that\age -> return 1
            if this\age = that\age -> return 0
            if this\age < that\age -> return neg 1
        ]   
    ]
    
    define :student is :person [  
        init: method [name, age, id][
            this\name: capitalize name
            this\age: age
            this\id: id
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
        ]
    ]
    
    a: to :person ["John" 16]
    b: to :student ["Jane" 16 100]
    c: to :person ["John" 15]
    d: to :student ["Jane" 16 100]
    ensure -> 0 = compare a b
    ensure -> 0 = compare b a
    ensure -> (neg 1) = compare c d
    ensure -> 1 = compare d c
    passed
    
    
    topic « compare - :store
    
    a: store "test.db"
    a\name: "John" a\surname: "Doe"
    b: store "test.db"
    b\name: "John" b\surname: "Doe"
    
    ensure -> 0 = compare a a
    ensure -> 0 = compare a b
    ensure -> 0 = compare b a
    passed
    
    
    topic « compare - :color
    
    ensure -> 0 = compare #000 #black
    ensure -> 0 = compare #fff #white
    ensure -> 0 = compare #white #white
    passed
 
    
    topic « compare - :database
    ; todo: test this
    
    
    topic « less? - :date
    
    a: to :date .format: "MMM dd" "Jan 15"
    b: to :date .format: "MMM dd" "Jan 15"
    c: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    d: to :date .format: "MMM dd" "Jan 14"
    e: now
    
    ensure -> 0 = compare a a
    ensure -> 0 = compare b b
    ensure -> 0 = compare a b 
    ensure -> 0 = compare b a 
    passed
    
    ensure -> (neg 1) = compare a c
    ensure -> (neg 1) = compare a e
    ensure -> (neg 1) = compare d a
    ensure -> (neg 1) = compare d e
    passed
    
    ensure -> 1 = compare c a
    ensure -> 1 = compare e a
    ensure -> 1 = compare a d
    ensure -> 1 = compare e d
    passed
    
    topic « compare - :unit
    
    ensure -> 0 = compare `USD `USD
    ensure -> 1 = compare `USD `EUR
    ensure -> 1 = compare `EUR `USD
    passed

    
]

topic « equal?
do [
    
    topic « equal? - :integer :floating :rational
    
    ensure -> equal? 1 1
    ensure -> equal? 1 1.0
    ensure -> equal? 1 to :rational @[1 1]
    ensure -> equal? 1 to :rational @[5 5]
    ensure -> not? equal? 1 2
    ensure -> not? equal? 1 2.0
    ensure -> not? equal? 1 :rational @[1 2]
    ensure -> 1 = 1
    ensure -> 1 = 1.0
    ensure -> 1 = to :rational @[1 1]
    ensure -> 1 = to :rational @[5 5]
    ensure -> not? 1 = 2
    ensure -> not? 1 = 2.0
    ensure -> not? 1 = :rational @[1 2]
    passed
    
    ensure -> equal? 1.0 1
    ensure -> equal? 1.0 1.0
    ensure -> equal? 1.0 to :rational @[1 1]
    ensure -> equal? 1.0 to :rational @[5 5]
    ensure -> not? equal? 1.0 2
    ensure -> not? equal? 1.0 2.0
    ensure -> not? equal? 1.0 to :rational @[1 2]
    ensure -> 1.0 = 1
    ensure -> 1.0 = 1.0
    ensure -> 1.0 = to :rational @[1 1]
    ensure -> 1.0 = to :rational @[5 5]
    ensure -> not? 1.0 = 2
    ensure -> not? 1.0 = 2.0
    ensure -> not? 1.0 = to :rational @[1 2]
    passed
    
    ensure -> equal? to :rational @[5 5] 1
    ensure -> equal? to :rational @[5 5] 1.0
    ensure -> equal? to :rational @[5 5] to :rational @[1 1]
    ensure -> not? equal? to :rational @[5 5] 2
    ensure -> not? equal? to :rational @[5 5] 2.0
    ensure -> not? equal? to :rational @[5 5] to :rational @[1 2]
    ensure -> (to :rational @[5 5]) = 1
    ensure -> (to :rational @[5 5]) = 1.0
    ensure -> (to :rational @[5 5]) = to :rational @[1 1]
    ensure -> not? (to :rational @[5 5]) = 2
    ensure -> not? (to :rational @[5 5]) = 2.0
    ensure -> not? (to :rational @[5 5]) = to :rational @[1 2]
    passed
    
    
    topic « equal? - :quantity
    
    ensure -> equal? 1`usd 1
    ensure -> equal? 1`m   1
    ensure -> equal? 1`m2  1
    ensure -> equal? 1`m3  1
    ensure -> equal? 1`c   1
    ensure -> equal? 1`f   1
    ensure -> 1`usd = 1
    ensure -> 1`m   = 1
    ensure -> 1`m2  = 1
    ensure -> 1`m3  = 1
    ensure -> 1`c   = 1
    ensure -> 1`f   = 1
    passed
    
    ensure -> equal? 1 1`usd
    ensure -> equal? 1 1`m
    ensure -> equal? 1 1`m2
    ensure -> equal? 1 1`m3
    ensure -> equal? 1 1`c
    ensure -> equal? 1 1`f
    ensure -> 1 = 1`usd
    ensure -> 1 = 1`m
    ensure -> 1 = 1`m2
    ensure -> 1 = 1`m3
    ensure -> 1 = 1`c
    ensure -> 1 = 1`f
    passed
    
    ensure -> equal? 1`usd 1.0
    ensure -> equal? 1`m   1.0
    ensure -> equal? 1`m2  1.0
    ensure -> equal? 1`m3  1.0
    ensure -> equal? 1`c   1.0
    ensure -> equal? 1`f   1.0
    ensure -> 1`usd = 1.0
    ensure -> 1`m   = 1.0
    ensure -> 1`m2  = 1.0
    ensure -> 1`m3  = 1.0
    ensure -> 1`c   = 1.0
    ensure -> 1`f   = 1.0
    passed
    
    ensure -> equal? 1.0 1`usd
    ensure -> equal? 1.0 1`m
    ensure -> equal? 1.0 1`m2
    ensure -> equal? 1.0 1`m3
    ensure -> equal? 1.0 1`c
    ensure -> equal? 1.0 1`f
    ensure -> 1.0 = 1`usd
    ensure -> 1.0 = 1`m
    ensure -> 1.0 = 1`m2
    ensure -> 1.0 = 1`m3
    ensure -> 1.0 = 1`c
    ensure -> 1.0 = 1`f
    passed
    
    ensure -> equal? 1`usd to :rational @[5 5]
    ensure -> equal? 1`m   to :rational @[5 5]
    ensure -> equal? 1`m2  to :rational @[5 5]
    ensure -> equal? 1`m3  to :rational @[5 5]
    ensure -> equal? 1`c   to :rational @[5 5]
    ensure -> equal? 1`f   to :rational @[5 5]
    ensure -> 1`usd = to :rational @[5 5]
    ensure -> 1`m   = to :rational @[5 5]
    ensure -> 1`m2  = to :rational @[5 5]
    ensure -> 1`m3  = to :rational @[5 5]
    ensure -> 1`c   = to :rational @[5 5]
    ensure -> 1`f   = to :rational @[5 5]
    passed
    
    ensure -> equal? to :rational @[5 5] 1`usd
    ensure -> equal? to :rational @[5 5] 1`m
    ensure -> equal? to :rational @[5 5] 1`m2
    ensure -> equal? to :rational @[5 5] 1`m3
    ensure -> equal? to :rational @[5 5] 1`c
    ensure -> equal? to :rational @[5 5] 1`f
    ensure -> (to :rational @[5 5]) = 1`usd
    ensure -> (to :rational @[5 5]) = 1`m
    ensure -> (to :rational @[5 5]) = 1`m2
    ensure -> (to :rational @[5 5]) = 1`m3
    ensure -> (to :rational @[5 5]) = 1`c
    ensure -> (to :rational @[5 5]) = 1`f
    passed
    
    ensure -> not? equal? 2`usd 1
    ensure -> not? equal? 2 1`usd
    ensure -> not? equal? 2`usd 1.0
    ensure -> not? equal? 2.0 1`usd
    ensure -> not? equal? 2`usd to :rational @[5 5]
    ensure -> not? equal? to :rational @[2 5] 1`usd
    passed
    
    ensure -> equal? 1.5`m 150`cm 
    ensure -> not? equal? 2`m 2`cm
    passed 
    
    
    topic « equal? - :null
    
    ensure -> equal? null null
    ensure -> equal? null ø
    ensure -> equal? ø ø
    ensure -> equal? ø null
    ensure -> null = null
    ensure -> null = ø
    ensure -> ø = ø
    ensure -> ø = null
    passed
    
    ensure -> not? equal? ø 1
    ensure -> not? equal? ø 1.0
    ensure -> not? equal? ø "ø"
    ensure -> not? equal? ø 'ø'
    ensure -> not? ø = 1
    ensure -> not? ø = 1.0
    ensure -> not? ø = "ø"
    ensure -> not? ø = 'ø'
    passed
    
    
    topic « equal? - :logical
    
    ensure -> equal? true true
    ensure -> equal? true (1 > 0)
    ensure -> true = true
    ensure -> true = (1 > 0)
    passed
    
    ensure -> not? equal? true maybe
    ensure -> not? equal? true false
    ensure -> not? true = maybe
    ensure -> not? true = false
    passed
    
    
    topic « equal? - :complex
    
    ensure -> equal? to :complex [0 2] to :complex [0 2]
    ensure -> (to :complex [0 2]) = (to :complex [0 2])
    passed
    
    ; greater than
    ensure -> not? equal? to :complex [2 2] to :complex [1 2] 
    ensure -> not? equal? to :complex [2 3] to :complex [1 2]
    ensure -> not? (to :complex [2 2]) = (to :complex [1 2]) 
    ensure -> not? (to :complex [2 3]) = (to :complex [1 2]) 
    passed
    
    ; less than
    ensure -> not? equal? to :complex [0 2] to :complex [1 2] 
    ensure -> not? equal? to :complex [0 1] to :complex [1 2]
    ensure -> not? (to :complex [0 2]) = (to :complex [1 2]) 
    ensure -> not? (to :complex [0 1]) = (to :complex [1 2])
    passed
    
    
    topic « equal? - :version
    
    ensure -> equal? 1.2.3 1.2.3
    ensure -> 1.2.3 = 1.2.3
    passed
    
    ensure -> not? equal? 1.2.3 1.2.3-pre
    ensure -> not? equal? 1.2.3 1.2.3-dev
    ensure -> not? 1.2.3 = 1.2.3-pre
    ensure -> not? 1.2.3 = 1.2.3-dev
    passed
    
    
    topic « equal? - :type
    
    ensure -> equal? :string type "a"
    ensure -> equal? :integer type 1
    ensure -> equal? :floating type 1.5
    passed
    
    ensure -> not? equal? :string :integer
    ensure -> not? equal? :string :char
    ensure -> not? equal? :integer :floating
    passed
    
    
    topic « equal? - :char
    
    ensure -> equal? 'a' 'a'
    ensure -> 'a' = 'a'
    passed
    
    ensure -> not? equal? 'a' "a" 
    ensure -> not? equal? 'a' 'b'
    ensure -> not? equal? '1' 1
    ensure -> not? equal? "a" 'a' 
    ensure -> not? equal? 'b' 'a'
    ensure -> not? equal? 1   '1'
    ensure -> not? 'a' = "a" 
    ensure -> not? 'a' = 'b'
    ensure -> not? '1' =  1
    ensure -> not? "a" = 'a' 
    ensure -> not? 'b' = 'a'
    ensure -> not?  1  = '1'
    passed 
    
    
    topic « equal? - :string
    
    ensure -> equal? "Art" "Arturo" -- "uro"
    ensure -> "Art" = "Arturo" -- "uro"
    passed
    
    ensure -> not? equal? "A" "B"
    ensure -> not? equal? "Art" "Bob"
    passed
    
    ensure -> not? equal? "a"    'a' 
    ensure -> not? equal? "10"   10 
    ensure -> not? equal? "10"   10
    passed
    
    ensure -> not? equal? "a" 'a'
    ensure -> not? equal? "a" 'a
    ensure -> not? equal? "a" to :label "a"
    ensure -> not? equal? "a" to :attribute "a"
    ensure -> not? equal? "a" to :attributelabel "a"
    ensure -> not? equal? "string" to :type "string"
    passed
    
    
    topic « equal? - :word
    
    ensure -> equal? to :word "a" to :word "a"
    ensure -> not? equal? to :word "a" to :word "b"
    passed
    
    ensure -> not? equal? to :word "a" "a"
    ensure -> not? equal? to :word "a" 'a'
    ensure -> not? equal? to :word "a" 'a
    ensure -> not? equal? to :word "a" to :label "a"
    ensure -> not? equal? to :word "a" to :attribute "a"
    ensure -> not? equal? to :word "a" to :attributelabel "a"
    ensure -> not? equal? to :word "word" to :type "word"
    passed
    
    
    topic « equal? - :label
    
    ensure -> equal? to :label "a" to :label "a"
    ensure -> not? equal? to :label "a" to :label "b"
    passed
    
    ensure -> not? equal? to :label "a" "a"
    ensure -> not? equal? to :label "a" 'a'
    ensure -> not? equal? to :label "a" 'a
    ensure -> not? equal? to :label "a" to :word "a"
    ensure -> not? equal? to :label "a" to :attribute "a"
    ensure -> not? equal? to :label "a" to :attributelabel "a"
    ensure -> not? equal? to :label "label" to :type "label"
    passed
    
    
    topic « equal? - :literal
    
    ensure -> equal? 'a 'a
    ensure -> not? equal? 'a 'b
    passed
    
    ensure -> not? equal? 'a "a"
    ensure -> not? equal? 'a 'a'
    ensure -> not? equal? 'a to :label "a"
    ensure -> not? equal? 'a to :word "a"
    ensure -> not? equal? 'a to :attribute "a"
    ensure -> not? equal? 'a to :attributelabel "a"
    ensure -> not? equal? to :literal "literal" to :type "literal"
    passed

    
    
    topic « equal? - :attribute
    
    ensure -> equal? to :attribute "a" to :attribute "a"
    ensure -> not? equal? to :attribute "a" to :attribute "b"
    passed
    
    ensure -> not? equal? to :attribute "a" "a"
    ensure -> not? equal? to :attribute "a" 'a'
    ensure -> not? equal? to :attribute "a" 'a
    ensure -> not? equal? to :attribute "a" to :word "a"
    ensure -> not? equal? to :attribute "a" to :label "a"
    ensure -> not? equal? to :attribute "a" to :attributelabel "a"
    ensure -> not? equal? to :attribute "label" to :type "label"
    passed
    
    
    topic « equal? - :attributelabel
    
    ensure -> equal? to :attributelabel "a" to :attributelabel "a"
    ensure -> not? equal? to :attributelabel "a" to :attributelabel "b"
    passed
    
    ensure -> not? equal? to :attributelabel "a" "a"
    ensure -> not? equal? to :attributelabel "a" 'a'
    ensure -> not? equal? to :attributelabel "a" 'a
    ensure -> not? equal? to :attributelabel "a" to :word "a"
    ensure -> not? equal? to :attributelabel "a" to :label "a"
    ensure -> not? equal? to :attributelabel "a" to :attribute "a"
    ensure -> not? equal? to :attributelabel "label" to :type "label"
    passed
    
    
    topic « equal? - :path
    
    a: #[name: "John", surname: "Doe"]
    b: @["Joe" "Jane" "Jesse"]
    
    ensure -> equal? a\name "John" 
    ensure -> equal? a\surname "Doe" 
    ensure -> not? equal? a\name "Jane" 
    ensure -> not? equal? a\name 1
    passed
    
    ensure -> equal? b\0 "Joe" 
    ensure -> equal? b\1 "Jane" 
    ensure -> equal? b\2 "Jesse" 
    ensure -> not? equal? b\2 "Walter" 
    passed
    
    ensure -> equal? [b\0] [b\0]
    ensure -> equal? [a\name] [a\name]
    ensure -> not? equal? [b\0] [b\1]
    ensure -> not? equal? [a\name] [a\surname]
    passed
    
    
    topic « equal? - :pathLabel
       
    ensure -> equal? [a\name: "John"] [a\name: "John"]
    ensure -> not? equal? [a\surname: "Doe"] [b\surname: "Doe" ]
    ensure -> not? equal? [a\name: "John"] [b\name: "Jane"]
    ensure -> not? equal? [a\name: "John"] [b\name: "John"]
    passed
    
    
    topic « equal? - :symbol
    
    ensure -> equal? to :symbol "+" to :symbol "+"
    ensure -> not? equal? to :symbol "+" to :symbol "-"
    ensure -> not? equal? to :symbol "+" "++"
    ensure -> not? equal? to :symbol "+" '+'
    ensure -> not? equal? to :symbol "+" {+}
    ensure -> not? equal? to :symbol "+" "+"
    ensure -> not? equal? to :symbol "+" to :word "plus"
    ensure -> not? equal? to :symbol "+" '+
    passed
    
    
    topic « equal? - :regex
    
    ensure -> regex? {/[A-Z]/}
    ensure -> equal? {/[A-Z]/} {/[A-Z]/} 
    ensure -> not? equal? {/[A-Z]/} {/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/}
    ensure -> not? equal? {/[A-Z]/} {[A-Z]}
    ensure -> not? equal? {/[A-Z]/} "/[A-Z]/"
    passed


    topic « equal? - :binary
    
    ensure -> equal? "48 65 6C 6C 6F 20 77 6F 72 6C 64"
        ~{|to :binary "Hello world"|}
    ensure -> equal? "00" ~{|to :binary 0|}
    ensure -> equal? "01" ~{|to :binary 1|}
    ensure -> equal? "0A" ~{|to :binary 10|}
    ensure -> equal? "05" ~{|to :binary 5|}
    passed
    
    a: to :binary 0
    
    ensure -> not? equal? a 0
    ensure -> not? equal? "49 65 6C 6C 6F 20 77 6F 72 6C 64"
        ~{|to :binary "Hello world"|}
    passed


    topic « equal? - :bytecode
    
    x: to :bytecode [["print"][1 112 155]]
    
    ensure -> equal? x to :bytecode [["print"][1 112 155]]
    ensure -> not? equal? x to :bytecode [["print"][2 112 155]]
    ensure -> not? equal? x [["print"][2 112 155]]
    passed


    topic « equal? - :inline
    
    a: [(1 + 1)], b: [(1 + 1)] 
    ensure -> equal? a\0 b\0
    passed
    
    c: [(2 + 1)] 
    ensure -> not? equal? a\0 c\0
    passed
    
    d: [(3 - 1)] 
    ensure -> not? equal? a\0 d\0   ; even the calc (3-1) and (1+1) being 2, 
    passed                          ; they are different inlines 
                                    ; with the same result when evaluated
    
    
    e: [(1 + 2 - 1)]
    ensure -> not? equal? a\0 e\0
    ensure -> not? equal? a\0 2
    passed


    topic « equal? - :block
    
    a: [1 + 1]
    ensure -> equal? a [1 + 1]
    ensure -> not? equal? a [2]
    ensure -> not? equal? a 2
    ensure -> not? equal? a [1 ++ 1]
    passed
    
    
    topic « equal? - :range
    
    ensure -> equal? [0 1 2 3 4 5] @0..5
    ensure -> equal? [0 2 4] @0.. .step: 2 5
    ensure -> equal? @range.step: 2 0 5 @range.step: 2 0 4
    ensure -> not? equal? range.step: 2 0 5 range.step: 2 0 4
    passed


    topic « equal? - :dictionary
    
    a: #[name: "Walter" surname: "Pinkman"]
    
    ensure -> equal? a #[name: "Walter" surname: "Pinkman"]
    ensure -> not? equal? a #[name: "Jesse" surname: "Pinkman"]
    ensure -> not? equal? a #[name "Jesse" surname "Pinkman"]
    ensure -> not? equal? a [name "Jesse" surname "Pinkman"]
    passed
    
    ensure -> equal? a\name "Walter"
    ensure -> equal? a\surname "Pinkman"
    ensure -> not? equal? a\surname "White"
    passed


    topic « equal? - :object
    
    define :person [  
        init: method [name,age][
            this\name: capitalize name
            this\age: age
        ]
        string: method [][ 
            render "NAME: |this\name|, AGE: |this\age|"
        ]
    ]
    
    define :student is :person [
        init: method [name, age, id][
            this\name: capitalize name
            this\age: age
            this\id: id
        ]  
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
        ]
    ]
    
    a: to :person ["Joe" 32]
    ensure -> equal? a to :person ["Joe" 32]
    ensure -> not? equal? to :person ["Joe" 32] #[name: "Joe" age: 32]
    ensure -> not? equal? to :person ["Joe" 32] to :student ["Joe" 32 15]
    passed
    
    a\name: "Jane"
    ensure -> equal? a to :person ["Jane" 32]
    passed
    
    define :person [  
        init: method [name, age][
            this\name: capitalize name
            this\age: age
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|"
        ]
        compare: method [that][
            if this\age > that\age -> return 1
            if this\age = that\age -> return 0
            if this\age < that\age -> return neg 1
        ]   
    ]
    
    define :student is :person [  
        init: method [name, age, id][
            this\name: capitalize name
            this\age: age
            this\id: id
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
        ]
    ]
    
    a: to :person ["John" 16]
    b: to :student ["Jane" 16 100]
    c: to :person ["John" 15]
    d: to :student ["Jane" 16 100]
    ensure -> equal? a b
    ensure -> equal? b a
    ensure -> not? equal? c d
    ensure -> not? equal? d c
    passed
    
    
    
    topic « equal? - :store
    
    a: store "test.db"
    a\name: "John" a\surname: "Doe"
    b: store "test.db"
    b\name: "John" b\surname: "Doe"
    c: store "test2.db"
    c\name: "John" c\surname: "Doe"
    d: store "test3.db"
    d\name: "Jane" d\surname: "Doe"
    
    ensure -> equal? a a
    ensure -> equal? a b
    ensure -> equal? b a
    passed
    
    ensure -> not? equal? a c 
    ensure -> not? equal? c a 
    ensure -> not? equal? a d 
    ensure -> not? equal? d a 
    ensure -> not? equal? c d 
    ensure -> not? equal? d c 
    passed
    

    topic « equal? - :color
    
    ensure -> equal? #000 #black
    ensure -> equal? #fff #white
    ensure -> equal? #white #white
    ensure -> not? equal? #black #white
    ensure -> not? equal? #white #black
    passed


    topic « equal? - :function
    
    ensure -> equal? var 'print var 'print
    ensure -> not? equal? var 'inspect var 'print
    passed
    
    a: $[name surname][]
    A: $[name][]
    b: $[name][]
    c: $[name surname][]
    
    ensure -> equal? ~"|var 'a|" ~"|$[name surname][]|"
    ensure -> equal? ~"|var 'a|" ~"|var 'c|"
    ensure -> not? equal? ~"|var 'a|" ~"|var 'A|"
    ensure -> not? equal? ~"|var 'a|" ~"|var 'b|"
    passed


    topic « equal? - :database
    ; todo: test this


    topic « equal? - :date
    
    a: to :date .format: "MMM dd" "Jan 15"
    b: to :date .format: "MMM dd" "Jan 15"
    c: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    d: now
    
    ensure -> equal? a b 
    ensure -> not? equal? a c 
    ensure -> not? equal? a d
    passed 
    
    ensure -> equal? a\day c\day
    ensure -> equal? a\month c\month
    ensure -> not? equal? a\year c\year
    passed


    topic « equal? - incompatible types
    
    ; NOTES: 
    ; - to avoid repetition some tests may be not explicitly included
    ; - this test part tries to cover the most of possible behaviors,
    ;     including the possility of the Comparison module be rewritten, 
    ;     avoiding future broken changes
    ; - some combinations were not made, because it's considered very
    ;     improbable to happen, even with a future rewrite of 
    ;     the Comparison module
    
    ; for :integer
    
    ensure -> not? every? @[
        -> equal? 1 1
    ] => not?
    
    ensure -> every? @[
        -> equal? 1 null            -> equal? 1 true
        -> equal? 1 false           -> equal? 1 to :complex [1 1]
        -> equal? 1 1.0.0           -> equal? 1 :integer
        -> equal? 1 '1'             -> equal? 1 "1"
        -> equal? [1] [one]         -> equal? [1] [one:]
        -> equal? 1 '1              -> equal? [1] [.1]         
        -> equal? [1] [.1:]         -> equal? [1] [one\1]
        -> equal? [1] [one\1:]      -> equal? [1] [+]          
        -> equal? 1 {/1/}           -> equal? 1 to :binary 1   
        -> equal? 1 to :binary 1    -> equal? [1] [(1)]        
        -> equal? 1 [1]             -> equal? 1 1..1           
        -> equal? 1 #[one: 1]       -> equal? 0 #black         
        -> equal? 1 var 'one?
    ] => not? passed
    
    ; for :floating
    ensure -> every? @[
        -> equal? 1.0 null              -> equal? 1.0 true
        -> equal? 1.0 false             -> equal? 1.0 to :complex [1.0 1.0]
        -> equal? 1.0 1.0.0             -> equal? 1.0 :floating
        -> equal? 1.0 '1'               -> equal? 1.0 "1.0"
        -> equal? [1.0] [one]           -> equal? 1.0 '1
        -> equal? [1.0] [.1]            -> equal? [1.0] [.1:]
        -> equal? [1.0] [one\1]         -> equal? [1.0] [one\1:]        
        -> equal? [1.0] [+]             -> equal? 1.0 {/1.0/}
        -> equal? 1.0 to :binary 1.0    -> equal? 1.0 to :binary 1.0
        -> equal? [1.0] [(1.0)]         -> equal? 1.0 [1]
        -> equal? 1.0 1..1              -> equal? 1.0 #[one: 1.0]
        -> equal? 0.0 #black            -> equal? 1.0 var 'one?
    ] => not? passed
    
    ; for :rational
    a: to :rational [1 1]
    ensure -> every? @[
        -> equal? a null                    -> equal? a true
        -> equal? a false                   -> equal? a to :complex [1 1]
        -> equal? a 1.0.0                   -> equal? a :rational
        -> equal? a '1'                     -> equal? a "1/1"
        -> equal? @[a] [one]                -> equal? @[a] [one:]
        -> equal? 1 '1                      -> equal? @[a] [.1]                 
        -> equal? @[a] [.1:]                -> equal? @[a] [one\1]          
        -> equal? @[a] [+]                  -> equal? a {/1/1/}
        -> equal? a to :binary 1            -> equal? a to :binary 1
        -> equal? @[a] [(1)]                -> equal? a [1]
        -> equal? a 1..1                    -> equal? a #[one: 1]
        -> equal? to :rational [1 1] #black -> equal? a var 'one?
    ] => not? passed
    
    ; for :quantity
    ensure -> every? @[
        -> equal? 1`usd null            -> equal? 1`usd true
        -> equal? 1`usd false           -> equal? 1`usd to :complex [1 1]
        -> equal? 1`usd 1.0.0           -> equal? 1`usd :quantity
        -> equal? 1`usd '1'             -> equal? 1`usd "1USD"
        -> equal? [1`usd] [one]         -> equal? [1`usd] [one:]
        -> equal? 1`usd '1              -> equal? [1`usd] [.1]                  
        -> equal? [1`usd] [.1:]         -> equal? [1`usd] [one\1]
        -> equal? [1`usd] [one\1:]      -> equal? [1`usd] [+]                   
        -> equal? 1`usd {/1USD/}        -> equal? 1`usd to :binary 1            
        -> equal? 1`usd to :binary 1    -> equal? [1`usd] [(1)]                 
        -> equal? 1`usd [1`usd]         -> equal? 1`usd 1..1                    
        -> equal? 1`usd #[one: 1`usd]   -> equal? 0`usd #black                  
        -> equal? 1`usd var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> equal? 1`m null          -> equal? 1`m true
        -> equal? 1`m false         -> equal? 1`m to :complex [1 1]
        -> equal? 1`m 1.0.0         -> equal? 1`m :quantity
        -> equal? 1`m '1'           -> equal? 1`m "1m"
        -> equal? [1`m] [one]       -> equal? [1`m] [one:]
        -> equal? 1`m '1            -> equal? [1`m] [.1]            
        -> equal? [1`m] [one\1]     -> equal? [1`m] [one\1:]        
        -> equal? [1`m] [+]         -> equal? 1`m {/1m/}
        -> equal? 1`m to :binary 1  -> equal? 1`m to :binary 1
        -> equal? [1`m] [(1)]       -> equal? 1`m [1`m]
        -> equal? 1`m 1..1          -> equal? 1`m #[one: 1`m]
        -> equal? 0`m #black        -> equal? 1`m var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> equal? 1`m3 null                 -> equal? 1`m3 true
        -> equal? 1`m3 false                -> equal? 1`m3 to :complex [1 1]
        -> equal? 1`m3 1.0.0                -> equal? 1`m3 :quantity
        -> equal? 1`m3 '1'                  -> equal? 1`m3 "1m³"
        -> equal? [1`m3] [one]              -> equal? [1`m3] [one:]
        -> equal? 1`m3 '1                   -> equal? [1`m3] [.1]               
        -> equal? [1`m3] [.1:]              -> equal? [1`m3] [one\1]
        -> equal? [1`m3] [one\1:]           -> equal? [1`m3] [+]                
        -> equal? 1`m3 {/1m³/}              -> equal? 1`m3 to :binary 1         
        -> equal? 1`m3 to :binary 1         -> equal? [1`m3] [(1)]              
        -> equal? 1`m3 [1`m3]               -> equal? 1`m3 1..1                 
        -> equal? 1`m3 #[one: 1`m3]         -> equal? 0`m3 #black               
        -> equal? 1`m3 var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> equal? 1`c null              -> equal? 1`c true
        -> equal? 1`c false             -> equal? 1`c to :complex [1 1]
        -> equal? 1`c 1.0.0             -> equal? 1`c :quantity
        -> equal? 1`c '1'               -> equal? 1`c "1°C"
        -> equal? [1`c] [one]           -> equal? [1`c] [one:]
        -> equal? 1`c '1                -> equal? [1`c] [.1]            
        -> equal? [1`c] [.1:]           -> equal? [1`c] [one\1]
        -> equal? [1`c] [one\1:]        -> equal? [1`c] [+]             
        -> equal? 1`c {/1°C/}           -> equal? 1`c to :binary 1      
        -> equal? 1`c to :binary 1      -> equal? [1`c] [(1)]           
        -> equal? 1`c [1`c]             -> equal? 1`c 1..1              
        -> equal? 1`c #[one: 1`c]       -> equal? 0`c #black            
        -> equal? 1`c var 'one?
    ] => not? passed
    
    ; for :null
    ensure -> every? @[
        -> equal? null 0                    -> equal? null 0.0            
        -> equal? null to :rational [1 1]   -> equal? null true
        -> equal? null false                -> equal? null to :complex [0 0]
        -> equal? null 0.0.0                -> equal? null :null
        -> equal? null 'ø'                  -> equal? null "null"
        -> equal? @[null] [null]            -> equal? @[null] [null:]
        -> equal? null 'null                -> equal? @[null] [.null]               
        -> equal? @[null] [.null:]          -> equal? @[null] [null\null]
        -> equal? @[null] [null\null:]      -> equal? @[null] [ø]                   
        -> equal? null {/null/}             -> equal? null {/ø/}                    
        -> equal? null to :binary 0         -> equal? null to :binary 0             
        -> equal? @[null] [(null)]          -> equal? null [null]                   
        -> equal? null 0..0                 -> equal? null #[null: null]            
        -> equal? null #black               -> equal? null var 'null?
    ] => not? passed
    
    ; for :logical
    ensure -> every? @[
        -> equal? true 0                    -> equal? true 0.0            
        -> equal? true to :rational [1 1]   -> equal? true to :complex [0 0]
        -> equal? true 0.0.0                -> equal? true :true
        -> equal? true '0'                  -> equal? true "true"
        -> equal? @[true] [true]            -> equal? true 'true
        -> equal? @[true] [.true]           -> equal? @[true] [.true:]
        -> equal? @[true] [true\true]       -> equal? @[true] [true\true:]         
        -> equal? @[true] [ø]               -> equal? true {/true/}
        -> equal? true to :binary 0         -> equal? true to :binary 0             
        -> equal? @[true] [(true)]          -> equal? true [true]                   
        -> equal? true 0..0                 -> equal? true #[true: true]            
        -> equal? true #black               -> equal? true var 'true?
    ] => not? passed
    
    ensure -> every? @[
        -> equal? false 0                   -> equal? false 0.0            
        -> equal? false to :rational [1 1]  -> equal? false to :complex [0 0]
        -> equal? false 0.0.0               -> equal? false :false
        -> equal? false '0'                 -> equal? false "false"
        -> equal? @[false] [false]          -> equal? @[false] [false:]
        -> equal? false 'false              -> equal? @[false] [.false]                 
        -> equal? @[false] [.false:]        -> equal? @[false] [false\false]
        -> equal? @[false] [false\false:]   -> equal? @[false] [ø]                      
        -> equal? false {/false/}           -> equal? false to :binary 0                
        -> equal? false to :binary 0        -> equal? @[false] [(false)]                
        -> equal? false [false]             -> equal? false 0..0                        
        -> equal? false #[false: false]     -> equal? false #black                      
        -> equal? false var 'false?
    ] => not? passed
    
    ensure -> every? @[
        -> equal? maybe 0                   -> equal? maybe 0.0            
        -> equal? maybe to :rational [1 1]  -> equal? maybe to :complex [0 0]
        -> equal? maybe 0.0.0               -> equal? maybe :maybe
        -> equal? maybe '0'                 -> equal? maybe "maybe"
        -> equal? @[maybe] [maybe]          -> equal? @[maybe] [maybe:]
        -> equal? maybe 'maybe              -> equal? @[maybe] [.maybe]                 
        -> equal? @[maybe] [.maybe:]        -> equal? @[maybe] [maybe\maybe]
        -> equal? @[maybe] [maybe\maybe:]   -> equal? @[maybe] [ø]                      
        -> equal? maybe {/maybe/}           -> equal? maybe to :binary 0                
        -> equal? maybe to :binary 0        -> equal? @[maybe] [(maybe)]                
        -> equal? maybe [maybe]             -> equal? maybe 0..0                        
        -> equal? maybe #[maybe: maybe]     -> equal? maybe #black                      
    ] => not? passed
    
    ; for :complex
    a: to :complex [1 1]
    ensure -> every? @[
        -> equal? a 1                       -> equal? a 1.0            
        -> equal? a to :rational [1 1]      -> equal? a null                    
        -> equal? a true                    -> equal? a false
        -> equal? a 1.0.0                   -> equal? a :rational
        -> equal? a '1'                     -> equal? a "1.0+1.0i"
        -> equal? @[a] [one]                -> equal? @[a] [one:]
        -> equal? 1 '1                      -> equal? @[a] [.1]                 
        -> equal? @[a] [.1:]                -> equal? @[a] [one\1]              
        -> equal? @[a] [one\1:]             -> equal? @[a] [+]                  
        -> equal? a {/1.0+1.0i/}            -> equal? a to :binary 1            
        -> equal? a to :binary 1            -> equal? @[a] [(1)]                
        -> equal? a [1]                     -> equal? a 1..1                    
        -> equal? a #[one: 1]               -> equal? to :complex [0 0] #black  
        -> equal? a var 'one?
    ] => not? passed
    
    ; for :version
    ensure -> every? @[
        -> equal? 1.0.0 1                       -> equal? 1.0.0 1.0          
        -> equal? 1.0.0 to :rational [1 1]      -> equal? 1.0.0 null                    
        -> equal? 1.0.0 true                    -> equal? 1.0.0 false                   
        -> equal? 1.0.0 to :complex [1.0 1.0]   -> equal? 1.0.0 :floating
        -> equal? 1.0.0 '1'                     -> equal? 1.0.0 "1.0.0"
        -> equal? [1.0.0] [one]                 -> equal? [1.0.0] [one:]
        -> equal? 1.0.0 '1                      -> equal? [1.0.0] [.1]                  
        -> equal? [1.0.0] [.1:]                 -> equal? [1.0.0] [one\1]
        -> equal? [1.0.0] [one\1:]              -> equal? [1.0.0] [+]                   
        -> equal? 1.0.0 {/1.0.0/}               -> equal? 1.0.0 to :binary 1.0          
        -> equal? 1.0.0 to :binary 1.0          -> equal? [1.0.0] [(1.0.0)]             
        -> equal? 1.0.0 [1.0.0]                 -> equal? 1.0.0 1..1                    
        -> equal? 1.0.0 #[one: 1.0.0]           -> equal? 0.0.0 #black                  
        -> equal? 1.0.0 var 'version?
    ] => not? passed
    
    ; for :type
    ensure -> every? @[
        -> equal? :1 1                              -> equal? :1 1.0          
        -> equal? :integer 1                        -> equal? :floating 1.0          
        -> equal? :rational to :rational [1 1]      -> equal? :null null                    
        -> equal? :true true                        -> equal? :false false                   
        -> equal? :logical false                    -> equal? :complex to :complex [1 1]   
        -> equal? :version 1.0.0                    -> equal? :T 'T'                         
        -> equal? :char 'T'                         -> equal? :string ":type"
        -> equal? [:type] [type]                    -> equal? [:word] [word]                     
        -> equal? [:type] [type:]                   -> equal? [:label] [label:]
        -> equal? :1 '1                             -> equal? :literal '1                       
        -> equal? [:type] [.type]                   -> equal? [:attribute] [.type]              
        -> equal? [:type] [.type:]                  -> equal? [:attributelabel] [.type:]               
        -> equal? [:type] [type\type]               -> equal? [:path] [type\type]
        -> equal? [:type] [type\type:]              -> equal? [:pathLabel] [type\type:]            
        -> equal? [:type] [+]                       -> equal? [:symbol] [+]                     
        -> equal? :type {/:type/}                   -> equal? :regex {/:type/}                  
        -> equal? :type to :binary 1.0              -> equal? :binary to :binary 1.0            
        -> equal? [:type] [(:type)]                 -> equal? [:inline] [(:type)]               
        -> equal? :type [:type]                     -> equal? :block [:type]                    
        -> equal? :type 1..1                        -> equal? :range 1..1                       
        -> equal? :type #[type: :type]              -> equal? :dictionary #[type: :type]        
        -> equal? :type #black                      -> equal? :color #black                     
        -> equal? :type var 'type?                  -> equal? :function var 'one?
    ] => not? passed
    
    ; for :char
    ensure -> every? @[
        -> equal? '1' 1.0          
        -> equal? '1' to :rational [1 1]    -> equal? 'ø' null                    
        -> equal? 't' true                  -> equal? 'f' false                   
        -> equal? '1' to :complex [1.0 1.0] -> equal? 'T' :floating
        -> equal? ['a'] [one]               -> equal? 'a' 'a
        -> equal? ['a'] [.1]                -> equal? ['a'] [.a:]
        -> equal? ['a'] [a\a]               -> equal? ['a'] [a\a:]              
        -> equal? ['+'] [+]                 -> equal? 'a' {/a/}
        -> equal? '1' to :binary 1          -> equal? 'a' to :binary 1
        -> equal? ['1'] [('1')]             -> equal? 'a' ['a']
        -> equal? '1' 1..1                  -> equal? 'a' #[a: 'a']
        -> equal? '1' #black                -> equal? 'a' var 'char?
    ] => not? passed
    
    ; for :string
    ensure -> every? @[
        -> equal? "1" 1                             -> equal? "1/1" to :rational [1 1]          
        -> equal? "1.0" 1.0                         -> equal? "null" null                    
        -> equal? "" null                           -> equal? "true" true                  
        -> equal? "" false                          -> equal? "false" false                   
        -> equal? "1.0+1.0i" to :complex [1.0 1.0]  -> equal? "type" :floating
        -> equal? "floating" :floating              -> equal? ":floating" :floating
        -> equal? "1.0" :floating                   -> equal? ["a"] [a\a]
        -> equal? ["a"] [a\a:]                      -> equal? ["+"] [+]                         
        -> equal? "a" {/a/}                         -> equal? "01" to :binary 1                 
        -> equal? "1" to :binary 1                  -> equal? [""] [("")]                       
        -> equal? "" [""]                           -> equal? "1" 1..1                          
        -> equal? "a" #[a: "a"]                     -> equal? "#000000" #black                  
        -> equal? "000000" #black                   -> equal? "" var 'char?
    ] => not? passed
    
    ; for :word
    ensure -> every? @[        
        -> equal? [rational] @[to :rational [1 1]]      -> equal? [null]  @[null]                    
        -> equal? [true]     @[true]                    -> equal? [false] @[false]                   
        -> equal? [complex]  @[to :complex [1.0 1.0]]   -> equal? [type]  @[:floating]  
        -> equal? [floating] @[:floating]               -> equal? [a]      [a\a]                   
        -> equal? [a]         [a\a:]                    -> equal? [a]     @[{/a/}]                      
        -> equal? [binary]   @[to :binary 1]            -> equal? [one]   @[to :binary 1]              
        -> equal? [word]      [(word)]                  -> equal? [word]  @[[word]]                      
        -> equal? [range]    @[range 1 1]               -> equal? [a]     @[#[a: 'a']]               
        -> equal? [black]    @[#black ]                 -> equal? [word]  @[var 'word?]              
        -> equal? [var]      @[var 'word?]
    ] => not? passed
    
    ; for :label
    ensure -> every? @[
        -> equal? [rational:] @[to :rational [1 1]]     -> equal? [null:]     @[null]                                                        
        -> equal? [true:]     @[true]                   -> equal? [false:]    @[false]                   
        -> equal? [complex:]  @[to :complex [1.0 1.0]]  -> equal? [floating:] @[:floating]
        -> equal? [type:]     @[:floating]              -> equal? [a:]         [a\a]                     
        -> equal? [a:]         [a\a:]                   -> equal? [a:]        @[{/a:/}]                 
        -> equal? [binary:]   @[to :binary 1]           -> equal? [word:]      [(word:)]                
        -> equal? [label:]    @[[label:]]               -> equal? [a:]        @[#[a: 'a']]               
        -> equal? [black:]    @[#black ]                -> equal? [var:]      @[var 'word?]
        -> equal? [word:]     @[var 'word?]
    ] => not? passed
    
    ; for :literal
    ; NOTE: technically, '+ is not a :literal, but a :symbolLiteral type ;)
    ensure -> every? @[
        -> equal? 'integer  1                   -> equal? 'floating 1.0
        -> equal? 'rational to :rational [1 1]  -> equal? 'one      to :rational [1 1]
        -> equal? 'null     null                -> equal? 'true     true    
        -> equal? 'false    false               -> equal? 'complex  to :complex [1.0 1.0]    
        -> equal? 'type     :floating           -> equal? 'floating :floating               
        -> equal? ['a]        [a\a]             -> equal? ['+]      [+]                       
        -> equal? 'a        {/a/}               -> equal? 'binary   to :binary 1            
        -> equal? ['word]   [('word)]           -> equal? 'word     ['word]                                     
        -> equal? 'range    1..1                -> equal? 'a        #[a: 'a]                
        -> equal? 'black    #black              -> equal? 'word?    var 'word?              
        -> equal? 'var      var 'var
    ] => not? passed
    
    ; for :attribute
    ensure -> every? @[           
        -> equal? [.rational] @[to :rational [1 1]]    -> equal? [.null]     @[null]                  
        -> equal? [.true]     @[true]                  -> equal? [.false]    @[false]                 
        -> equal? [.complex]  @[to :complex [1.0 1.0]] -> equal? [.floating] @[:floating]                          
        -> equal? [.a]        @[{/a:/}]                -> equal? [.binary]   @[to :binary 1]          
        -> equal? [.word]      [(.word:)]              -> equal? [.label]    @[[.label]]                               
        -> equal? [.a]        @[#[a: 'a']]             -> equal? [.black]    @[#black]                
        -> equal? [.var]      @[var 'word?]            -> equal? [.word]     @[var 'word?]
    ] => not? passed
    
    ; for :attributelabel
    ensure -> every? @[           
        -> equal? [.rational:] @[to :rational [1 1]]    -> equal? [.null:]     @[null]                  
        -> equal? [.true:]     @[true]                  -> equal? [.false:]    @[false]                 
        -> equal? [.complex:]  @[to :complex [1.0 1.0]] -> equal? [.floating:] @[:floating]             
        -> equal? [.a:]         [a\a]                   -> equal? [.a: 'a']     [a\a: 'a']              
        -> equal? [.plus:]      [+]                     -> equal? [.a:]        @[{/a:/}]                
        -> equal? [.binary:]   @[to :binary 1]          -> equal? [.word:]      [(.word:)]               
        -> equal? [.label:]    @[[label:]]              -> equal? [.a:]        @[#[a: 'a']]             
        -> equal? [.black:]    @[#black]                -> equal? [.var:]      @[var 'word?]            
        -> equal? [.word:]     @[var 'word?]
    ] => not? passed
    
    ; for :path & :pathLabel
    ensure -> every? @[
        -> equal? [a\b:] [a\b]
        -> equal? [a\b] [a\b:]
    ] => not? passed

    ; for :regex
    ensure -> every? @[
        -> equal? {/1/} 1                               -> equal? {/1/1/} to :rational [1 1]          
        -> equal? {/1.0/} 1.0                           -> equal? {/null/} null                    
        -> equal? {//} null                             -> equal? {/true/} true                  
        -> equal? {//} false                            -> equal? {/false/} false                   
        -> equal? {/1.0+1.0i/} to :complex [1.0 1.0]    -> equal? {/type/} :floating
        -> equal? {/floating/} :floating                -> equal? {/:floating/} :floating
        -> equal? {/1.0/} :floating                     -> equal? [{/a/}] [a\a]
        -> equal? [{/a/}] [a\a:]                        -> equal? [{/\+/}] [+]                          
        -> equal? {/01/} to :binary 1                   -> equal? {/1/} to :binary 1                    
        -> equal? [{//}] [({//})]                       -> equal? {//} [""]                             
        -> equal? {/1/} 1..1                            -> equal? {/a/} #[a: "a"]                       
        -> equal? {/#000000/} #black                    -> equal? {/000000/} #black                     
        -> equal? {/var/} var 'regex?                   -> equal? {/regex?/} var 'regex?
    ] => not? passed
    
    ; for :binary
    ensure -> every? @[
        -> equal? to :binary 1 1                    -> equal? to :binary 1 1.0                
        -> equal? to :binary 1 to :rational [1 1]   -> equal? to :binary 1 1`usd                
        -> equal? to :binary 1 1`m                  -> equal? to :binary 1 1`m3                 
        -> equal? to :binary 1 1`c                  -> equal? to :binary 0 null                 
        -> equal? to :binary 0 true                 -> equal? to :binary 0 false                
        -> equal? to :binary 0 maybe                -> equal? to :binary 1 to :complex [1 1]                  
        -> equal? to :binary 1 1.0.0                -> equal? to :binary 1 :type              
        -> equal? to :binary 1 :binary              -> equal? to :binary 1 '1'                  
        -> equal? to :binary "a" 'a'                -> equal? to :binary 1 "01"                 
        -> equal? to :binary 1 "1"                  -> equal? @[to :binary 1] [binary]          
        -> equal? @[to :binary 1] [one]             -> equal? @[to :binary 1] [binary:]         
        -> equal? @[to :binary 1][.binary]          -> equal? @[to :binary 1] [.binary:]        
        -> equal? to :binary 1 {/01/}               -> equal? to :binary 1    {/1/}
    ] => not? passed
    
    ; for :range
    ensure -> every? @[
        -> equal? 1..1 1                        -> equal? 1..1 1.0
        -> equal? 1..1 a: to :rational [1 1]    -> equal? 1..1 1`usd
        -> equal? 1..1 1`m                      -> equal? 1..1 1`m3  
        -> equal? 1..1 1`c                      -> equal? 0..0 null 
        -> equal? 0..0 true                     -> equal? 0..0 false
        -> equal? 0..0 maybe                    -> equal? 1..1 to :complex [1 1]
        -> equal? 1..1 1.0.0                    -> equal? 1..1 :type                        
        -> equal? 1..1 :range                   -> equal? 1..1 '1' 
        -> equal? 1..1 "1"                      -> equal? 1..1 'range  
        -> equal? 1..1 {/1/}
    ] => not? passed
    
    ; for :dictionary, :object & :date
    define :person [name surname]
    
    a: to :person ["Walter" "Pinkman"]
    b: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    
    ensure -> every? @[
        -> equal? #[name: "Walter" surname: "Pinkman"] a
        -> equal? a #[name: "Walter" surname: "Pinkman"]
        -> equal? #[year: 2023 day: 15 Month: "January"] b
        -> equal? b #[year: 2023 day: 15 Month: "January"]
    ] => not? passed
    
    ; for :color
    ensure -> every? @[
        -> equal? #black 0                  -> equal? #black 0.0
        -> equal? #black to :rational [1 1] -> equal? #black 0`usd 
        -> equal? #black 0`m                -> equal? #black 0`m3
        -> equal? #black 0`c                -> equal? #black null 
        -> equal? #black true               -> equal? #black false 
        -> equal? #black maybe              -> equal? #black to :complex [0 0]
        -> equal? #black 0.0.0              -> equal? #black :color
        -> equal? #black '1'                -> equal? #black "#000000"
        -> equal? #black "000000"           -> equal? [#black] [black] 
        -> equal? #black 'black             -> equal? [#black] [.black]
        -> equal? [#black] [.black:]        -> equal? #black  {/#000000/}                 
        -> equal? #black{/000000/} 
    ] => not? passed
    
    ; for :function
    ensure -> every? @[
        -> equal? var 'null?     null       -> equal? var 'true?    true  
        -> equal? var 'false?    false      -> equal? var 'version?  1.0.0      
        -> equal? var 'type?    :type       -> equal? var 'function? :function  
        -> equal? var 'char?    'a'         -> equal? @[var 'word?]  [word]     
        -> equal? @[var 'word?] [var]       -> equal? @[var 'word?]  [var:]     
        -> equal? @[var 'word?] [word:]     -> equal? var 'word?     'word?     
        -> equal? var 'var      'var        -> equal? @[var 'word?]  [.var]     
        -> equal? @[var 'word?] [.word]     -> equal? @[var 'word?]  [.var:]    
        -> equal? @[var 'word?] [.word:]    -> equal? var 'regex?    {/var/}    
        -> equal? var 'regex?   {/regex?/} 
    ] => not? passed
    
    
    topic « equal? - :unit
    
    ensure -> equal? `USD `USD
    ensure -> equal? `EUR `EUR
    ensure -> `USD = `USD
    ensure -> `EUR = `EUR
    passed
    
    ensure -> not? equal? `USD `EUR
    ensure -> not? equal? `EUR `USD
    ensure -> not? `EUR = `USD
    passed
    
]

topic « greater?
do [
    
    
    topic « greater? - :integer :floating :rational
    
    ensure -> greater? 2 1
    ensure -> greater? 2 1.0
    ensure -> greater? 2 to :rational @[1 1]
    ensure -> 2 > 1
    ensure -> 2 > 1.0
    ensure -> 2 > to :rational @[1 1]
    passed
    
    ensure -> not? greater? 1 1
    ensure -> not? greater? 1 1.0
    ensure -> not? greater? 1 to :rational @[1 1]
    ensure -> not? 1 > 1
    ensure -> not? 1 > 1.0
    ensure -> not? 1 > to :rational @[1 1]
    passed
    
    ensure -> not? greater? 1 2
    ensure -> not? greater? 1 2.0
    ensure -> not? greater? 1 to :rational @[2 1]
    ensure -> not? 1 > 2
    ensure -> not? 1 > 2.0
    ensure -> not? 1 > :rational @[2 1]
    passed
    
    
    ensure -> greater? 2.0 1
    ensure -> greater? 2.0 1.0
    ensure -> greater? 2.0 to :rational @[1 1]
    ensure -> 2.0 > 1
    ensure -> 2.0 > 1.0
    ensure -> 2.0 > to :rational @[1 1]
    passed
    
    ensure -> not? greater? 1.0 1
    ensure -> not? greater? 1.0 1.0
    ensure -> not? greater? 1.0 to :rational @[1 1]
    ensure -> not? 1.0 > 1
    ensure -> not? 1.0 > 1.0
    ensure -> not? 1.0 > to :rational @[1 1]
    passed
    
    ensure -> not? greater? 1.0 2
    ensure -> not? greater? 1.0 2.0
    ensure -> not? greater? 1.0 to :rational @[2 1]
    ensure -> not? 1.0 > 2
    ensure -> not? 1.0 > 2.0
    ensure -> not? 1.0 > :rational @[2 1]
    passed
    
    
    ensure -> greater? to :rational @[2 1] 1
    ensure -> greater? to :rational @[2 1] 1.0
    ensure -> greater? to :rational @[2 1] to :rational @[1 1]
    ensure -> (to :rational @[2 1]) > 1
    ensure -> (to :rational @[2 1]) > 1.0
    ensure -> (to :rational @[2 1]) > to :rational @[1 1]
    passed
    
    ensure -> not? greater? to :rational @[1 1] 1
    ensure -> not? greater? to :rational @[1 1] 1.0
    ensure -> not? greater? to :rational @[1 1] to :rational @[1 1]
    ensure -> not? (to :rational @[1 1]) > 1
    ensure -> not? (to :rational @[1 1]) > 1.0
    ensure -> not? (to :rational @[1 1]) > to :rational @[1 1]
    passed
    
    ensure -> not? greater? to :rational @[1 1] 2
    ensure -> not? greater? to :rational @[1 1] 2.0
    ensure -> not? greater? to :rational @[1 1] to :rational @[2 1]
    ensure -> not? (to :rational @[1 1]) > 2
    ensure -> not? (to :rational @[1 1]) > 2.0
    ensure -> not? (to :rational @[1 1]) > :rational @[2 1]
    passed
    
    
    topic « greater? - :quantity
    
    ; equal to
    
    ensure -> not? greater? 1`usd 1
    ensure -> not? greater? 1`m   1
    ensure -> not? greater? 1`m2  1
    ensure -> not? greater? 1`m3  1
    ensure -> not? greater? 1`c   1
    ensure -> not? greater? 1`f   1
    ensure -> not? greater? 1 1`usd
    ensure -> not? greater? 1 1`m
    ensure -> not? greater? 1 1`m2
    ensure -> not? greater? 1 1`m3
    ensure -> not? greater? 1 1`c
    ensure -> not? greater? 1 1`f
    passed
    
    ensure -> not? greater? 1`usd 1.0
    ensure -> not? greater? 1`m   1.0
    ensure -> not? greater? 1`m2  1.0
    ensure -> not? greater? 1`m3  1.0
    ensure -> not? greater? 1`c   1.0
    ensure -> not? greater? 1`f   1.0
    ensure -> not? greater? 1.0 1`usd
    ensure -> not? greater? 1.0 1`m
    ensure -> not? greater? 1.0 1`m2
    ensure -> not? greater? 1.0 1`m3
    ensure -> not? greater? 1.0 1`c
    ensure -> not? greater? 1.0 1`f
    passed
    
    ensure -> not? greater? 1`usd to :rational @[5 5]
    ensure -> not? greater? 1`m   to :rational @[5 5]
    ensure -> not? greater? 1`m2  to :rational @[5 5]
    ensure -> not? greater? 1`m3  to :rational @[5 5]
    ensure -> not? greater? 1`c   to :rational @[5 5]
    ensure -> not? greater? 1`f   to :rational @[5 5] 
    ensure -> not? greater? to :rational @[5 5] 1`usd
    ensure -> not? greater? to :rational @[5 5] 1`m
    ensure -> not? greater? to :rational @[5 5] 1`m2
    ensure -> not? greater? to :rational @[5 5] 1`m3
    ensure -> not? greater? to :rational @[5 5] 1`c
    ensure -> not? greater? to :rational @[5 5] 1`f
    passed
    
    
    ; less than
    
    ensure -> not? greater? 1`usd 2
    ensure -> not? greater? 1`m   2
    ensure -> not? greater? 1`m2  2
    ensure -> not? greater? 1`m3  2
    ensure -> not? greater? 1`c   2
    ensure -> not? greater? 1`f   2
    ensure -> not? greater? 1 2`usd
    ensure -> not? greater? 1 2`m
    ensure -> not? greater? 1 2`m2
    ensure -> not? greater? 1 2`m3
    ensure -> not? greater? 1 2`c
    ensure -> not? greater? 1 2`f
    passed
    
    ensure -> not? greater? 1`usd 2.0
    ensure -> not? greater? 1`m   2.0
    ensure -> not? greater? 1`m2  2.0
    ensure -> not? greater? 1`m3  2.0
    ensure -> not? greater? 1`c   2.0
    ensure -> not? greater? 1`f   2.0
    ensure -> not? greater? 1.0 2`usd
    ensure -> not? greater? 1.0 2`m
    ensure -> not? greater? 1.0 2`m2
    ensure -> not? greater? 1.0 2`m3
    ensure -> not? greater? 1.0 2`c
    ensure -> not? greater? 1.0 2`f
    passed
    
    ensure -> not? greater? 1`usd to :rational @[2 1]
    ensure -> not? greater? 1`m   to :rational @[2 1]
    ensure -> not? greater? 1`m2  to :rational @[2 1]
    ensure -> not? greater? 1`m3  to :rational @[2 1]
    ensure -> not? greater? 1`c   to :rational @[2 1]
    ensure -> not? greater? 1`f   to :rational @[2 1] 
    ensure -> not? greater? to :rational @[1 1] 2`usd
    ensure -> not? greater? to :rational @[1 1] 2`m
    ensure -> not? greater? to :rational @[1 1] 2`m2
    ensure -> not? greater? to :rational @[1 1] 2`m3
    ensure -> not? greater? to :rational @[1 1] 2`c
    ensure -> not? greater? to :rational @[1 1] 2`f
    passed
    
    
    ; greater than
    
    ensure -> greater? 2`usd 1
    ensure -> greater? 2`m   1
    ensure -> greater? 2`m2  1
    ensure -> greater? 2`m3  1
    ensure -> greater? 2`c   1
    ensure -> greater? 2`f   1
    ensure -> greater? 2 1`usd
    ensure -> greater? 2 1`m
    ensure -> greater? 2 1`m2
    ensure -> greater? 2 1`m3
    ensure -> greater? 2 1`c
    ensure -> greater? 2 1`f
    passed
    
    ensure -> greater? 2`usd 1.0
    ensure -> greater? 2`m   1.0
    ensure -> greater? 2`m2  1.0
    ensure -> greater? 2`m3  1.0
    ensure -> greater? 2`c   1.0
    ensure -> greater? 2`f   1.0
    ensure -> greater? 2.0 1`usd
    ensure -> greater? 2.0 1`m
    ensure -> greater? 2.0 1`m2
    ensure -> greater? 2.0 1`m3
    ensure -> greater? 2.0 1`c
    ensure -> greater? 2.0 1`f
    passed
    
    ensure -> greater? 2`usd to :rational @[5 5]
    ensure -> greater? 2`m   to :rational @[5 5]
    ensure -> greater? 2`m2  to :rational @[5 5]
    ensure -> greater? 2`m3  to :rational @[5 5]
    ensure -> greater? 2`c   to :rational @[5 5]
    ensure -> greater? 2`f   to :rational @[5 5] 
    ensure -> greater? to :rational @[2 1] 1`usd
    ensure -> greater? to :rational @[2 1] 1`m
    ensure -> greater? to :rational @[2 1] 1`m2
    ensure -> greater? to :rational @[2 1] 1`m3
    ensure -> greater? to :rational @[2 1] 1`c
    ensure -> greater? to :rational @[2 1] 1`f
    passed
    
    
    ensure -> not? greater? 1.5`m 150`cm 
    ensure -> greater? 2`m 2`cm
    passed 
    
    
    topic « greater? - :null
    
    ensure -> not? greater? null null
    ensure -> not? greater? null ø
    ensure -> not? greater? ø ø
    ensure -> not? greater? ø null
    ensure -> not? null > null
    ensure -> not? null > ø
    ensure -> not? ø > ø
    ensure -> not? ø > null
    passed
    
    ensure -> not? greater? ø 1
    ensure -> not? greater? ø 1.0
    ensure -> not? greater? ø "ø"
    ensure -> not? greater? ø 'ø'
    ensure -> not? ø > 1
    ensure -> not? ø > 1.0
    ensure -> not? ø > "ø"
    ensure -> not? ø > 'ø'
    passed
    
    
    topic « greater? - :logical
    
    ensure -> not? greater? true true
    ensure -> not? greater? true (1 > 0)
    ensure -> not? true > true
    ensure -> not? true > (1 > 0)
    passed
    
    ensure -> not? greater? true maybe
    ensure -> not? greater? true false
    ensure -> not? true > maybe
    ensure -> not? true > false
    passed
    
    
    topic « greater? - :complex
    
    ensure -> greater? to :complex [2 2] to :complex [1 2]
    ensure -> greater? to :complex [1 3] to :complex [1 2]
    ensure -> (to :complex [2 2]) > (to :complex [1 2])
    ensure -> (to :complex [1 3]) > (to :complex [1 2])
    passed
    
    ; equal to
    ensure -> not? greater? to :complex [1 2] to :complex [1 2] 
    ensure -> not? (to :complex [1 2]) > (to :complex [1 2]) 
    passed
    
    ; less than
    ensure -> not? greater? to :complex [0 2] to :complex [1 2] 
    ensure -> not? greater? to :complex [1 1] to :complex [1 2]
    ensure -> not? (to :complex [0 2]) > (to :complex [1 2]) 
    ensure -> not? (to :complex [1 1]) > (to :complex [1 2])
    passed
    
    
    topic « greater? - :version
    
    ensure -> greater? 1.2.3 1.2.2
    ensure -> 1.2.3 > 1.2.2
    passed
    
    ensure -> not? greater? 1.2.3 1.2.3
    ensure -> not? 1.2.3 > 1.2.3
    passed
    
    ensure -> greater? 1.2.3 1.2.3-pre
    ensure -> not? greater? 1.2.3-dev 1.2.3 
    ensure -> 1.2.3 > 1.2.3-pre
    ensure -> not? 1.2.3-dev > 1.2.3
    passed
    
    
    topic « greater? - :type
    
    ensure -> not? greater? :a :b
    ensure -> not? greater? :char :char
    ensure -> not? greater? :string type "a"
    ensure -> not? greater? :integer type 1
    ensure -> not? greater? :floating type 1.5
    passed
    
    ensure -> not? greater? :char :string
    ensure -> not? greater? :integer :string
    ensure -> not? greater? :floating :integer   
    ensure -> not? greater? :string :integer
    ensure -> not? greater? :string :char
    ensure -> not? greater? :integer :floating
    passed
    
    
    topic « greater? - :char
    
    ensure -> greater? 'b' 'a'
    ensure -> not? greater? 'a' 'b'
    ensure -> not? greater? 'a' "a"
    ensure -> not? greater? '1' 1
    passed
    
    
    topic « greater? - :string
    
    ensure -> not? greater? "Art" "Arturo" -- "uro"
    ensure -> not? "Art" > "Arturo" -- "uro"
    passed
    
    ensure -> greater? "B" "A"  
    ensure -> greater? "Bob" "Art"
    ensure -> greater? "Artu" "Art"
    passed
    
    ensure -> not? greater? "b" 'a'
    ensure -> not? greater? "b" 'a
    ensure -> not? greater? "b" to :word "a"
    ensure -> not? greater? "b" to :label "a"
    ensure -> not? greater? "b" to :attribute "a"
    ensure -> not? greater? "b" to :attributelabel "a"
    ensure -> not? greater? "b" to :type "a"
    passed
    
    topic « greater? - :word
    
    ensure -> greater? to :word "b" to :word "a"
    ensure -> not? greater? to :word "a" to :word "a"
    ensure -> not? greater? to :word "a" to :word "b"
    passed
    
    ensure -> not? greater? to :word "b" "a"
    ensure -> not? greater? to :word "b" 'a'
    ensure -> not? greater? to :word "b" 'a
    ensure -> not? greater? to :word "b" to :label "a"
    ensure -> not? greater? to :word "b" to :attribute "a"
    ensure -> not? greater? to :word "b" to :attributelabel "a"
    ensure -> not? greater? to :word "b" to :type "a"
    passed
    
    
    topic « greater? - :label
    
    ensure -> greater? to :label "b" to :label "a"
    ensure -> not? greater? to :label "a" to :label "a"
    ensure -> not? greater? to :label "a" to :label "b"
    passed
    
    ensure -> not? greater? to :label "b" "a"
    ensure -> not? greater? to :label "b" 'a'
    ensure -> not? greater? to :label "b" 'a
    ensure -> not? greater? to :label "b" to :word "a"
    ensure -> not? greater? to :label "b" to :attribute "a"
    ensure -> not? greater? to :label "b" to :attributelabel "a"
    ensure -> not? greater? to :label "b" to :type "a"
    passed
    
    
    topic « greater? - :literal
    
    ensure -> greater? 'b 'a
    ensure -> not? greater? 'a 'a
    ensure -> not? greater? 'a 'b
    passed
    
    ensure -> not? greater? 'b "a"
    ensure -> not? greater? 'b 'a'
    ensure -> not? greater? 'b to :word "a"
    ensure -> not? greater? 'b to :label "a"
    ensure -> not? greater? 'b to :attribute "a"
    ensure -> not? greater? 'b to :attributelabel "a"
    ensure -> not? greater? 'b to :type "a"
    passed
    
    
    topic « greater? - :path
    
    a: #[name: "John", surname: "Doe"]
    b: @["Joe" "Jane" "Jesse"]
    
    ensure -> not? greater? a\name "John" 
    ensure -> not? greater? a\surname "Doe" 
    ensure -> greater? a\name "Jane" 
    ensure -> not? greater? a\name 1 
    passed
    
    ensure -> not? greater? a\name "Kennedy" 
    ensure -> not? greater? a\surname "Moe" 
    ensure -> not? greater? a\name "Payne" 
    ensure -> not? greater? b\2 "Walter" 
    passed
    
    ensure -> not? greater? b\0 "Joe" 
    ensure -> not? greater? b\1 "Jane" 
    ensure -> not? greater? b\2 "Jesse" 
    passed
    
    ensure -> not? greater? [b\0] [b\0]
    ensure -> not? greater? [a\name] [a\name]
    ensure -> not? greater? [b\0] [b\1]
    ; ensure -> greater? [a\name] [a\surname]
    passed
    
    
    topic « greater? - :pathLabel
       
    ensure -> not? greater? [a\name: "John"]   [a\name: "John"]
    ensure -> not? greater? [a\surname: "Doe"] [b\surname: "Doe" ]
    ensure -> not? greater? [a\name: "John"]   [b\name: "Jane"]
    ensure -> not? greater? [a\name: "John"]   [b\name: "John"]
    passed
    
    
    topic « greater? - :attribute
    
    ensure -> greater? to :attribute "b" to :attribute "a"
    ensure -> not? greater? to :attribute "a" to :attribute "a"
    ensure -> not? greater? to :attribute "a" to :attribute "b"
    passed
    
    ensure -> not? greater? to :attribute "b" "a"
    ensure -> not? greater? to :attribute "b" 'a'
    ensure -> not? greater? to :attribute "b" 'a
    ensure -> not? greater? to :attribute "b" to :word "a"
    ensure -> not? greater? to :attribute "b" to :label "a"
    ensure -> not? greater? to :attribute "b" to :attributelabel "a"
    ensure -> not? greater? to :attribute "b" to :type "a"
    passed

    
    topic « greater? - :attributelabel
    
    ensure -> greater? to :attributelabel "b" to :attributelabel "a"
    ensure -> not? greater? to :attributelabel "a" to :attributelabel "a"
    ensure -> not? greater? to :attributelabel "a" to :attributelabel "b"
    passed
    
    ensure -> not? greater? to :attributelabel "less" "a"
    ensure -> not? greater? to :attributelabel "less" 'a'
    ensure -> not? greater? to :attributelabel "less" 'a
    ensure -> not? greater? to :attributelabel "less" to :word "a"
    ensure -> not? greater? to :attributelabel "less" to :label "a"
    ensure -> not? greater? to :attributelabel "less" to :attribute "a"
    ensure -> not? greater? to :attributelabel "b" 
                            to :type "a"
    passed
    
    
    topic « greater? - :symbol
    
    ensure -> not? greater? to :symbol "+" to :symbol "+"
    ensure -> not? greater? to :symbol "+" to :symbol "-"
    ensure -> not? greater? to :symbol "+" to :symbol "++"
    ensure -> not? greater? to :symbol "+" '+'
    ensure -> not? greater? to :symbol "+" {+}
    ensure -> not? greater? to :symbol "+" "+"
    ensure -> not? greater? to :symbol "+" to :word "plus"
    ensure -> not? greater? to :symbol "+" '+
    passed
    
    
    topic « greater? - :regex
    
    ensure -> regex? {/[A-Z]/}
    ensure -> not? greater? {/[A-Z]/} {/[A-Z]/} 
    ensure -> not? greater? {/[A-Z]/} {/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/}
    ensure -> not? greater? {/[A-Z]/} {[A-Z]}
    ensure -> not? greater? {/[A-Z]/} "/[A-Z]/"
    passed
    
    
    topic « greater? - :binary
    
    ensure -> not? greater? 
        to :binary "Arturo"
        to :binary "Hello world"
    ensure -> not? greater? to :binary 1 to :binary 0
    ensure -> not? greater? to :binary 1 to :binary 1
    ensure -> not? greater? to :binary 1 to :binary 10
    ensure -> not? greater? to :binary 1 to :binary 5
    passed
    
    
    topic « greater? - :bytecode
    
    x: to :bytecode [["print"][1 112 155]]
    
    ensure -> not? greater? x to :bytecode [["print"][1 112 155]]
    ensure -> not? greater? x to :bytecode [["print"][2 112 155]]
    ensure -> not? greater? x [["print"][2 112 155]]
    passed
    
    
    topic « greater? - :inline
    
    ensure -> not? greater? [(2 + 2)] [(2 + 2)]
    ensure -> not? greater? [(2 3 4 5)] [(2 3 4 5)]
    passed
    
    ensure -> not? greater? [(2 + 2)] [(2 + 1)]
    ensure -> not? greater? [(2 3 4 5)] [(2 1 4 5)]
    passed

    a: [(2 1 4 5)]
    b: [(2 3 4)] 
    ensure -> greater? a\0 b\0
    passed
    
    
    topic « greater? - :block
    
    a: [1 + 1]
    ensure -> not? greater? a [1 + 1]
    ensure -> greater? [1 1] [1]
    ensure -> greater? a [2]
    ensure -> not? greater? a 2
    ensure -> not? greater? a [1 ++ 1]
    ensure -> not? greater? [2] [1]
    ensure -> not? greater? [1] [2]
    passed
    
    
    topic « greater? - :range
    
    ensure -> not? greater? 0..5 0..5
    ensure -> not? greater? [0 1 2 3 4 5] @0..5
    ensure -> not? greater? [0 2 4] @0.. .step: 2 5
    ensure -> not? greater? @range.step: 2 0 5 @range.step: 2 0 4
    ensure -> not? greater? range.step: 2 0 5 range.step: 2 0 4
    passed
    
    
    topic « greater? - :dictionary
    
    a: #[name: "Walter" surname: "Pinkman"]
    
    ensure -> not? greater? a #[name: "Walter" surname: "Pinkman"]
    ensure -> not? greater? a #[name: "Jesse" surname: "Pinkman"]
    ensure -> not? greater? a #[name "Jesse" surname "Pinkman"]
    ensure -> not? greater? a [name "Jesse" surname "Pinkman"]
    passed
    
    
    topic « greater? - :object
    
    define :person [  
        init: method [name, age][
            this\name: capitalize name
            this\age: age
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|"
        ]
    ]
    
    define :student is :person [  
        init: method [name, age, id][
            this\name: capitalize name
            this\age: age
            this\id: id
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
        ]
    ]
    
    a: to :person ["Joe" 32]
    ensure -> not? greater? a to :person ["Joe" 32]
    ensure -> not? greater? to :person ["Joe" 32] #[name: "Joe" age: 32]
    ensure -> not? greater? to :person ["Joe" 32] to :student ["Joe" 32 15]
    passed
    
    a\name: "Jane"
    ensure -> not? greater? a to :person ["Jane" 32]
    passed
    
    define :person [  
        init: method [name, age][
            this\name: capitalize name
            this\age: age
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|"
        ]
        compare: method [that][
            if this\age > that\age -> return 1
            if this\age = that\age -> return 0
            if this\age < that\age -> return neg 1
        ]   
    ]
    
    define :student is :person [  
        init: method [name, age, id][
            this\name: capitalize name
            this\age: age
            this\id: id
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
        ]
    ]
    
    a: to :person ["John" 16]
    b: to :student ["Jane" 16 100]
    c: to :person ["John" 15]
    d: to :student ["Jane" 16 100]
    ensure -> not? greater? a b
    ensure -> not? greater? b a
    ensure -> not? greater? c d
    ensure -> greater? d c
    
    
    topic « greater? - :store
    
    a: store "test.db"
    a\name: "John" a\surname: "Doe"
    b: store "test.db"
    b\name: "John" b\surname: "Doe"
    c: store "test2.db"
    c\name: "John" c\surname: "Doe"
    d: store "test3.db"
    d\name: "Jane" d\surname: "Doe"
    
    ensure -> not? greater? a a
    ensure -> not? greater? a b
    ensure -> not? greater? b a
    passed
    
    ensure -> not? greater? a c 
    ensure -> not? greater? c a 
    ensure -> not? greater? a d 
    ensure -> not? greater? d a 
    ensure -> not? greater? c d 
    ensure -> not? greater? d c 
    passed
    
    
    topic « greater? - :color
    
    ensure -> not? greater? #000   #black
    ensure -> not? greater? #fff   #white
    ensure -> not? greater? #white #white
    ensure -> not? greater? #black #white
    ensure -> not? greater? #white #black
    passed
    
    
    topic « greater? - :function
    
    ensure -> not? greater? var 'print var 'print
    ensure -> not? greater? var 'inspect var 'print
    passed
    
    a: $[name surname][]
    A: $[name][]
    b: $[name][]
    c: $[name surname][]
    
    ; note: I commented these, because they return SigSegv
    ; ensure -> not? greater? (var 'a) ($[name surname][])
    ; ensure -> not? greater? (var 'a) (var 'c)
    ensure -> not? greater? (var 'a) (var 'A)
    ensure -> not? greater? (var 'a) (var 'b)
    passed
    
    
    topic « greater? - :database
    ; note: implement this test
    
    
    topic « greater? - :date
    
    a: to :date .format: "MMM dd" "Jan 15"
    b: to :date .format: "MMM dd" "Jan 15"
    c: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    d: to :date .format: "MMM dd" "Jan 16"
    e: now
    
    ensure -> greater? d a
    ensure -> greater? e a
    ensure -> greater? c a
    passed
    
    ensure -> not? greater? a b 
    ensure -> not? greater? a d
    passed 
    
    
    topic « greater? - :unit
    
    ensure -> not? greater? `USD `USD
    ensure -> not? greater? `EUR `EUR
    ensure -> not? greater? `USD `EUR
    ensure -> not? greater? `EUR `USD
    ensure -> not? `USD > `USD
    ensure -> not? `EUR > `EUR
    ensure -> not? `EUR > `USD
    passed
    
    
    topic « greater? - incompatible types
    
    ; NOTES: 
    ; - to avoid repetition some tests may be not explicitly included
    ; - this test part tries to cover the most of possible behaviors,
    ;     including the possility of the Comparison module be rewritten, 
    ;     avoiding future broken changes
    ; - some combinations were not made, because it's considered very
    ;     improbable to happen, even with a future rewrite of 
    ;     the Comparison module
    
    ; for :integer
    
    ensure -> not? every? @[
        -> greater? 2 1
    ] => not?
    
    ensure -> every? @[
        -> greater? 1 null          -> greater? 1 true
        -> greater? 1 false         -> greater? 1 to :complex [1 1]
        -> greater? 1 1.0.0         -> greater? 1 :integer
        -> greater? 1 '1'           -> greater? 1 "1"
        -> greater? [1] [one]       -> greater? [1] [one:]
        -> greater? 1 '1            -> greater? [1] [.1]         
        -> greater? [1] [.1:]       -> greater? [1] [one\1]
        -> greater? [1] [one\1:]    -> greater? [1] [+]          
        -> greater? 1 {/1/}         -> greater? 1 to :binary 1   
        -> greater? 1 to :binary 1  -> greater? [1] [(1)]        
        -> greater? 1 [1]           -> greater? 1 1..1           
        -> greater? 1 #[one: 1]     -> greater? 0 #black         
        -> greater? 1 var 'one?
    ] => not? passed
    
    ; for :floating
    ensure -> every? @[
        -> greater? 1.0 null            -> greater? 1.0 true
        -> greater? 1.0 false           -> greater? 1.0 to :complex [1.0 1.0]
        -> greater? 1.0 1.0.0           -> greater? 1.0 :floating
        -> greater? 1.0 '1'             -> greater? 1.0 "1.0"
        -> greater? [1.0] [one]         -> greater? [1.0] [one:]
        -> greater? 1.0 '1.0i           -> greater? [1.0] [.1]            
        -> greater? [1.0] [.1:]         -> greater? [1.0] [one\1]
        -> greater? [1.0] [one\1:]      -> greater? [1.0] [+]           
        -> greater? 1.0 {/1.0/}         -> greater? 1.0 to :binary 1.0  
        -> greater? 1.0 to :binary 1.0  -> greater? [1.0] [(1.0)]       
        -> greater? 1.0 [1]             -> greater? 1.0 1..1            
        -> greater? 1.0 #[one: 1.0]     -> greater? 0.0 #black          
        -> greater? 1.0 var 'one?
    ] => not? passed
    
    ; for :rational
    a: to :rational [1 1]
    ensure -> every? @[
        -> greater? a null          -> greater? a true
        -> greater? a false         -> greater? a to :complex [1 1]
        -> greater? a 1.0.0         -> greater? a :rational
        -> greater? a '1'           -> greater? a "1/1"
        -> greater? @[a] [one]      -> greater? @[a] [one:]
        -> greater? 1 '1            -> greater? @[a] [.1]                 
        -> greater? @[a] [.1:]      -> greater? @[a] [one\1]
        -> greater? @[a] [one\1:]   -> greater? @[a] [+]                  
        -> greater? a {/1/1/}       -> greater? a to :binary 1            
        -> greater? a to :binary 1  -> greater? @[a] [(1)]                
        -> greater? a [1]           -> greater? a 1..1                    
        -> greater? a #[one: 1]     -> greater? to :rational [1 1] #black    
        -> greater? a var 'one?
    ] => not? passed
    
    ; for :quantity
    ensure -> every? @[
        -> greater? 1`usd null          -> greater? 1`usd true
        -> greater? 1`usd false         -> greater? 1`usd to :complex [1 1]
        -> greater? 1`usd 1.0.0         -> greater? 1`usd :quantity
        -> greater? 1`usd '1'           -> greater? 1`usd "1USD"
        -> greater? [1`usd] [one]       -> greater? [1`usd] [one:]
        -> greater? 1`usd '1.0i         -> greater? [1`usd] [.1]                  
        -> greater? [1`usd] [.1:]       -> greater? [1`usd] [one\1]
        -> greater? [1`usd] [one\1:]    -> greater? [1`usd] [+]         
        -> greater? 1`usd {/1USD/}      -> greater? 1`usd to :binary 1  
        -> greater? 1`usd to :binary 1  -> greater? [1`usd] [(1)]       
        -> greater? 1`usd [1`usd]       -> greater? 1`usd 1..1          
        -> greater? 1`usd #[one: 1`usd] -> greater? 0`usd #black        
        -> greater? 1`usd var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> greater? 1`m null            -> greater? 1`m true
        -> greater? 1`m false           -> greater? 1`m to :complex [1 1]
        -> greater? 1`m 1.0.0           -> greater? 1`m :quantity
        -> greater? 1`m '1'             -> greater? 1`m "1m"
        -> greater? [1`m] [one]         -> greater? [1`m] [one:]
        -> greater? 1`m '1              -> greater? [1`m] [.1]            
        -> greater? [1`m] [.1:]         -> greater? [1`m] [one\1]
        -> greater? [1`m] [one\1:]      -> greater? [1`m] [+]             
        -> greater? 1`m {/1m/}          -> greater? 1`m to :binary 1      
        -> greater? 1`m to :binary 1    -> greater? [1`m] [(1)]           
        -> greater? 1`m [1`m]           -> greater? 1`m 1..1              
        -> greater? 1`m #[one: 1`m]     -> greater? 0`m #black            
        -> greater? 1`m var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> greater? 1`m3 null           -> greater? 1`m3 true
        -> greater? 1`m3 false          -> greater? 1`m3 to :complex [1 1]
        -> greater? 1`m3 1.0.0          -> greater? 1`m3 :quantity
        -> greater? 1`m3 '1'            -> greater? 1`m3 "1m³"
        -> greater? [1`m3] [one]        -> greater? [1`m3] [one:]
        -> greater? 1`m3 '1             -> greater? [1`m3] [.1]              
        -> greater? [1`m3] [.1:]        -> greater? [1`m3] [one\1]
        -> greater? [1`m3] [one\1:]     -> greater? [1`m3] [+]                
        -> greater? 1`m3 {/1m³/}        -> greater? 1`m3 to :binary 1         
        -> greater? 1`m3 to :binary 1   -> greater? [1`m3] [(1)]              
        -> greater? 1`m3 [1`m3]         -> greater? 1`m3 1..1                 
        -> greater? 1`m3 #[one: 1`m3]   -> greater? 0`m3 #black               
        -> greater? 1`m3 var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> greater? 1`c null            -> greater? 1`c true
        -> greater? 1`c false           -> greater? 1`c to :complex [1 1]
        -> greater? 1`c 1.0.0           -> greater? 1`c :quantity
        -> greater? 1`c '1'             -> greater? 1`c "1°C"
        -> greater? [1`c] [one]         -> greater? [1`c] [one:]
        -> greater? 1`c '1.0i           -> greater? [1`c] [.1]            
        -> greater? [1`c] [.1:]         -> greater? [1`c] [one\1]       
        -> greater? [1`c] [one\1:]      -> greater? [1`c] [+]           
        -> greater? 1`c {/1°C/}         -> greater? 1`c to :binary 1    
        -> greater? 1`c to :binary 1    -> greater? [1`c] [(1)]         
        -> greater? 1`c [1`c]           -> greater? 1`c 1..1            
        -> greater? 1`c #[one: 1`c]     -> greater? 0`c #black          
        -> greater? 1`c var 'one?
    ] => not? passed
    
    ; for :null
    ensure -> every? @[
        -> greater? null 0                  -> greater? null 0.0            
        -> greater? null to :rational [1 1] -> greater? null true
        -> greater? null false              -> greater? null to :complex [0 0]
        -> greater? null 0.0.0              -> greater? null :null
        -> greater? null 'ø'                -> greater? null "null"
        -> greater? @[null] [null]          -> greater? @[null] [null:]
        -> greater? null 'null              -> greater? @[null] [.null]               
        -> greater? @[null] [.null:]        -> greater? @[null] [null\null]
        -> greater? @[null] [null\null:]    -> greater? @[null] [ø]                   
        -> greater? null {/null/}           -> greater? null {/ø/}                    
        -> greater? null to :binary 0       -> greater? null to :binary 0             
        -> greater? @[null] [(null)]        -> greater? null [null]                   
        -> greater? null 0..0               -> greater? null #[null: null]            
        -> greater? null #black          
        -> greater? null var 'null?
    ] => not? passed
    
    ; for :logical
    ensure -> every? @[
        -> greater? true 0                  -> greater? true 0.0            
        -> greater? true to :rational [1 1] -> greater? true to :complex [0 0]
        -> greater? true 0.0.0              -> greater? true :true
        -> greater? true '0'                -> greater? true "true"
        -> greater? @[true] [true]          -> greater? @[true] [true:]
        -> greater? true 'true              -> greater? @[true] [.true]               
        -> greater? @[true] [.true:]        -> greater? @[true] [true\true]
        -> greater? @[true] [true\true:]    -> greater? @[true] [ø]                   
        -> greater? true {/true/}           -> greater? true to :binary 0             
        -> greater? true to :binary 0       -> greater? @[true] [(true)]              
        -> greater? true [true]             -> greater? true 0..0                     
        -> greater? true #[true: true]      -> greater? true #black                   
        -> greater? true var 'true?
    ] => not? passed
    
    ensure -> every? @[
        -> greater? false 0                     -> greater? false 0.0            
        -> greater? false to :rational [1 1]    -> greater? false to :complex [0 0]
        -> greater? false 0.0.0                 -> greater? false :false
        -> greater? false '0'                   -> greater? false "false"
        -> greater? @[false] [false]            -> greater? @[false] [false:]
        -> greater? false 'false                -> greater? @[false] [.false]                 
        -> greater? @[false] [.false:]          -> greater? @[false] [false\false]
        -> greater? @[false] [false\false:]     -> greater? @[false] [ø]                      
        -> greater? false {/false/}             -> greater? false to :binary 0                
        -> greater? false to :binary 0          -> greater? @[false] [(false)]                
        -> greater? false [false]               -> greater? false 0..0                        
        -> greater? false #[false: false]       -> greater? false #black                      
        -> greater? false var 'false?
    ] => not? passed
    
    ensure -> every? @[
        -> greater? maybe 0                     -> greater? maybe 0.0            
        -> greater? maybe to :rational [1 1]    -> greater? maybe to :complex [0 0]
        -> greater? maybe 0.0.0                 -> greater? maybe :maybe
        -> greater? maybe '0'                   -> greater? maybe "maybe"
        -> greater? @[maybe] [maybe]            -> greater? @[maybe] [maybe:]
        -> greater? maybe 'maybe                -> greater? @[maybe] [.maybe]                 
        -> greater? @[maybe] [.maybe:]          -> greater? @[maybe] [maybe\maybe]
        -> greater? @[maybe] [maybe\maybe:]     -> greater? @[maybe] [ø]                      
        -> greater? maybe {/maybe/}             -> greater? maybe to :binary 0                
        -> greater? maybe to :binary 0A         -> greater? @[maybe] [(maybe)]                
        -> greater? maybe [maybe]               -> greater? maybe 0..0                        
        -> greater? maybe #[maybe: maybe]       -> greater? maybe #black                      
    ] => not? passed
    
    ; for :complex
    a: to :complex [1 1]
    ensure -> every? @[
        -> greater? a 1                     -> greater? a 1.0            
        -> greater? a to :rational [1 1]    -> greater? a null                    
        -> greater? a true                  -> greater? a false
        -> greater? a 1.0.0                 -> greater? a :rational
        -> greater? a '1'                   -> greater? a "1.0+1.0i"
        -> greater? @[a] [one]              -> greater? @[a] [one:]
        -> greater? 1 '1                    -> greater? @[a] [.1]                 
        -> greater? @[a] [.1:]              -> greater? @[a] [one\1]
        -> greater? @[a] [one\1:]           -> greater? @[a] [+]                  
        -> greater? a {/1.0+1.0i/}          -> greater? a to :binary 1            
        -> greater? a to :binary 1          -> greater? @[a] [(1)]                
        -> greater? a [1]                   -> greater? a 1..1                    
        -> greater? a #[one: 1]             -> greater? to :complex [0 0] #black  
        -> greater? a var 'one?
    ] => not? passed
    
    ; for :version
    ensure -> every? @[
        -> greater? 1.0.0 1                     -> greater? 1.0.0 1.0          
        -> greater? 1.0.0 to :rational [1 1]    -> greater? 1.0.0 null                    
        -> greater? 1.0.0 true                  -> greater? 1.0.0 false                   
        -> greater? 1.0.0 to :complex [1.0 1.0] -> greater? 1.0.0 :floating
        -> greater? 1.0.0 '1'                   -> greater? 1.0.0 "1.0.0"
        -> greater? [1.0.0] [one]               -> greater? [1.0.0] [one:]
        -> greater? 1.0.0 '1                    -> greater? [1.0.0] [.1]                  
        -> greater? [1.0.0] [.1:]               -> greater? [1.0.0] [one\1]
        -> greater? [1.0.0] [one\1:]            -> greater? [1.0.0] [+]                   
        -> greater? 1.0.0 {/1.0.0/}             -> greater? 1.0.0 to :binary 1.0          
        -> greater? 1.0.0 to :binary 1.0        -> greater? [1.0.0] [(1.0.0)]             
        -> greater? 1.0.0 [1.0.0]               -> greater? 1.0.0 1..1                    
        -> greater? 1.0.0 #[one: 1.0.0]         -> greater? 0.0.0 #black                  
        -> greater? 1.0.0 var 'version?
    ] => not? passed
    
    ; for :type
    ensure -> every? @[
        -> greater? :1 1                            -> greater? :1 1.0          
        -> greater? :integer 1                      -> greater? :floating 1.0          
        -> greater? :rational to :rational [1 1]    -> greater? :null null                    
        -> greater? :true true                      -> greater? :false false                   
        -> greater? :logical false                  -> greater? :complex to :complex [1 1]   
        -> greater? :version 1.0.0                  -> greater? :T 'T'                         
        -> greater? :char 'T'                       -> greater? :string ":type"
        -> greater? [:type] [type]                  -> greater? [:word] [word]                     
        -> greater? [:type] [type:]                 -> greater? [:label] [label:]
        -> greater? :1 '1.                          -> greater? :literal '1                       
        -> greater? [:type] [.type]                 -> greater? [:attribute] [.type]              
        -> greater? [:type] [.type:]                -> greater? [:attributelabel] [.type:]                
        -> greater? [:type] [type\type]             -> greater? [:path] [type\type]
        -> greater? [:type] [type\type:]            -> greater? [:pathLabel] [type\type:]            
        -> greater? [:type] [+]                     -> greater? [:symbol] [+]                     
        -> greater? :type {/:type/}                 -> greater? :regex {/:type/}                  
        -> greater? :type to :binary 1.0            -> greater? :binary to :binary 1.0            
        -> greater? [:type] [(:type)]               -> greater? [:inline] [(:type)]               
        -> greater? :type [:type]                   -> greater? :block [:type]                    
        -> greater? :type 1..1                      -> greater? :range 1..1                       
        -> greater? :type #[type: :type]            -> greater? :dictionary #[type: :type]        
        -> greater? :type #black                    -> greater? :color #black                     
        -> greater? :type var 'type?                -> greater? :function var 'one?
    ] => not? passed
    
    ; for :char
    ensure -> every? @[
        -> greater? '1' 1.0          
        -> greater? '1' to :rational [1 1]      -> greater? 'ø' null                    
        -> greater? 't' true                    -> greater? 'f' false                   
        -> greater? '1' to :complex [1.0 1.0]   -> greater? 'T' :floating
        -> greater? ['a'] [one]                 -> greater? 'a' 'A                      
        -> greater? ['a'] [.1]                  -> greater? ['a'] [.a:]                 
        -> greater? ['a'] [a\a]                 -> greater? ['a'] [a\a:]                
        -> greater? ['+'] [+]                   -> greater? 'a' {/a/}                   
        -> greater? '1' to :binary 1            -> greater? 'a' to :binary 1            
        -> greater? ['1'] [('1')]               -> greater? 'a' ['a']                   
        -> greater? '1' 1..1                    -> greater? 'a' #[a: 'a']               
        -> greater? '1' #black                  -> greater? 'a' var 'char?
    ] => not? passed
    
    ; for :string
    ensure -> every? @[
        -> greater? "1" 1                               -> greater? "1/1" to :rational [1 1]          
        -> greater? "1.0" 1.0                           -> greater? "null" null                    
        -> greater? "" null                             -> greater? "true" true                  
        -> greater? "" false                            -> greater? "false" false                   
        -> greater? "1.0+1.0i" to :complex [1.0 1.0]    -> greater? "type" :floating
        -> greater? "floating" :floating                -> greater? ":floating" :floating
        -> greater? "1.0" :floating                     -> greater? ["a"] [a\a]
        -> greater? ["a"] [a\a:]                        -> greater? ["+"] [+]                         
        -> greater? "a" {/a/}                           -> greater? "01" to :binary 1                 
        -> greater? "1" to :binary 1                    -> greater? [""] [("")]                       
        -> greater? "" [""]                             -> greater? "1" 1..1                          
        -> greater? "a" #[a: "a"]                       -> greater? "#000000" #black                  
        -> greater? "000000" #black                     -> greater? "" var 'char?
    ] => not? passed
    
    ; for :word
    ensure -> every? @[        
        -> greater? [rational] @[to :rational [1 1]]      -> greater? [null]  @[null]                    
        -> greater? [true]     @[true]                    -> greater? [false] @[false]                   
        -> greater? [complex]  @[to :complex [1.0 1.0]]   -> greater? [type]  @[:floating]  
        -> greater? [floating] @[:floating]               -> greater? [a]      [a\a]                   
        -> greater? [a]         [a\a:]                    -> greater? [a]     @[{/a/}]                      
        -> greater? [binary]   @[to :binary 1]            -> greater? [one]   @[to :binary 1]              
        -> greater? [word]      [(word)]                  -> greater? [word]  @[[word]]                      
        -> greater? [range]    @[range 1 1]               -> greater? [a]     @[#[a: 'a']]               
        -> greater? [black]    @[#black ]                 -> greater? [word]  @[var 'word?]              
        -> greater? [var]      @[var 'word?]
    ] => not? passed
    
    ; for :label
    ensure -> every? @[
        -> greater? [rational:] @[to :rational [1 1]]     -> greater? [null:]     @[null]                                                        
        -> greater? [true:]     @[true]                   -> greater? [false:]    @[false]                   
        -> greater? [complex:]  @[to :complex [1.0 1.0]]  -> greater? [floating:] @[:floating]
        -> greater? [type:]     @[:floating]              -> greater? [a:]         [a\a]                     
        -> greater? [a:]         [a\a:]                   -> greater? [a:]        @[{/a:/}]                 
        -> greater? [binary:]   @[to :binary 1]           -> greater? [word:]      [(word:)]                
        -> greater? [label:]    @[[label:]]               -> greater? [a:]        @[#[a: 'a']]               
        -> greater? [black:]    @[#black ]                -> greater? [var:]      @[var 'word?]
        -> greater? [word:]     @[var 'word?]
    ] => not? passed
    
    ; for :literal
    ; NOTE: technically, '+ is not a :literal, but a :symbolLiteral type ;)
    ensure -> every? @[
        -> greater? 'integer  1                   -> greater? 'floating 1.0
        -> greater? 'rational to :rational [1 1]  -> greater? 'one      to :rational [1 1]
        -> greater? 'null     null                -> greater? 'true     true    
        -> greater? 'false    false               -> greater? 'complex  to :complex [1.0 1.0]    
        -> greater? 'type     :floating           -> greater? 'floating :floating               
        -> greater? ['a]        [a\a]             -> greater? ['+]      [+]                       
        -> greater? 'a        {/a/}               -> greater? 'binary   to :binary 1            
        -> greater? ['word]   [('word)]           -> greater? 'word     ['word]                                     
        -> greater? 'range    1..1                -> greater? 'a        #[a: 'a]                
        -> greater? 'black    #black              -> greater? 'word?    var 'word?              
        -> greater? 'var      var 'var
    ] => not? passed
    
    ; for :attribute
    ensure -> every? @[           
        -> greater? [.rational] @[to :rational [1 1]]    -> greater? [.null]     @[null]                  
        -> greater? [.true]     @[true]                  -> greater? [.false]    @[false]                 
        -> greater? [.complex]  @[to :complex [1.0 1.0]] -> greater? [.floating] @[:floating]                          
        -> greater? [.a]        @[{/a:/}]                -> greater? [.binary]   @[to :binary 1]          
        -> greater? [.word]      [(.word:)]              -> greater? [.label]    @[[.label]]                               
        -> greater? [.a]        @[#[a: 'a']]             -> greater? [.black]    @[#black]                
        -> greater? [.var]      @[var 'word?]            -> greater? [.word]     @[var 'word?]
    ] => not? passed
    
    ; for :attributelabel
    ensure -> every? @[           
        -> greater? [.rational:] @[to :rational [1 1]]    -> greater? [.null:]     @[null]                  
        -> greater? [.true:]     @[true]                  -> greater? [.false:]    @[false]                 
        -> greater? [.complex:]  @[to :complex [1.0 1.0]] -> greater? [.floating:] @[:floating]             
        -> greater? [.a:]         [a\a]                   -> greater? [.a: 'a']     [a\a: 'a']              
        -> greater? [.plus:]      [+]                     -> greater? [.a:]        @[{/a:/}]                
        -> greater? [.binary:]   @[to :binary 1]          -> greater? [.word:]      [(.word:)]               
        -> greater? [.label:]    @[[label:]]              -> greater? [.a:]        @[#[a: 'a']]             
        -> greater? [.black:]    @[#black]                -> greater? [.var:]      @[var 'word?]            
        -> greater? [.word:]     @[var 'word?]
    ] => not? passed
    
    ; for :path & :pathLabel
    ensure -> every? @[
        -> greater? [a\b:] [a\b]
        -> greater? [a\b] [a\b:]
    ] => not? passed

    ; for :regex
    ensure -> every? @[
        -> greater? {/1/} 1                               -> greater? {/1/1/} to :rational [1 1]          
        -> greater? {/1.0/} 1.0                           -> greater? {/null/} null                    
        -> greater? {//} null                             -> greater? {/true/} true                  
        -> greater? {//} false                            -> greater? {/false/} false                   
        -> greater? {/1.0+1.0i/} to :complex [1.0 1.0]    -> greater? {/type/} :floating
        -> greater? {/floating/} :floating                -> greater? {/:floating/} :floating
        -> greater? {/1.0/} :floating                     -> greater? [{/a/}] [a\a]
        -> greater? [{/a/}] [a\a:]
        -> greater? [{/\+/}] [+]                          -> greater? {/01/} to :binary 1                 
        -> greater? {/1/} to :binary 1                    -> greater? [{//}] [({//})]                     
        -> greater? {//} [""]                             -> greater? {/1/} 1..1                          
        -> greater? {/a/} #[a: "a"]                       -> greater? {/#000000/} #black                  
        -> greater? {/000000/} #black                     -> greater? {/var/} var 'regex?
        -> greater? {/regex?/} var 'regex?
    ] => not? passed
    
    ; for :binary
    ensure -> every? @[
        -> greater? to :binary 1 1                    -> greater? to :binary 1 1.0                
        -> greater? to :binary 1 to :rational [1 1]   -> greater? to :binary 1 1`usd                
        -> greater? to :binary 1 1`m                  -> greater? to :binary 1 1`m3                 
        -> greater? to :binary 1 1`c                  -> greater? to :binary 0 null                 
        -> greater? to :binary 0 true                 -> greater? to :binary 0 false                
        -> greater? to :binary 0 maybe                -> greater? to :binary 1 to :complex [1 1]                  
        -> greater? to :binary 1 1.0.0                -> greater? to :binary 1 :type              
        -> greater? to :binary 1 :binary              -> greater? to :binary 1 '1'                  
        -> greater? to :binary "a" 'a'                -> greater? to :binary 1 "01"                 
        -> greater? to :binary 1 "1"                  -> greater? @[to :binary 1] [binary]          
        -> greater? @[to :binary 1] [one]             -> greater? @[to :binary 1] [binary:]         
        -> greater? @[to :binary 1][.binary]          -> greater? @[to :binary 1] [.binary:]        
        -> greater? to :binary 1 {/01/}               -> greater? to :binary 1    {/1/}
    ] => not? passed
    
    ; for :range
    ensure -> every? @[
        -> greater? 1..1 1                        -> greater? 1..1 1.0
        -> greater? 1..1 a: to :rational [1 1]    -> greater? 1..1 1`usd
        -> greater? 1..1 1`m                      -> greater? 1..1 1`m3  
        -> greater? 1..1 1`c                      -> greater? 0..0 null 
        -> greater? 0..0 true                     -> greater? 0..0 false
        -> greater? 0..0 maybe                    -> greater? 1..1 to :complex [1 1]
        -> greater? 1..1 1.0.0                    -> greater? 1..1 :type                        
        -> greater? 1..1 :range                   -> greater? 1..1 '1' 
        -> greater? 1..1 "1"                      -> greater? 1..1 'range  
        -> greater? 1..1 {/1/}
    ] => not? passed
    
    ; for :dictionary, :object & :date
    define :person [name surname]
    
    a: to :person ["Walter" "Pinkman"]
    b: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    
    ensure -> every? @[
        -> greater? #[name: "Walter" surname: "Pinkman"] a
        -> greater? a #[name: "Walter" surname: "Pinkman"]
        -> greater? #[year: 2023 day: 15 Month: "January"] b
        -> greater? b #[year: 2023 day: 15 Month: "January"]
    ] => not? passed
    
    ; for :color
    ensure -> every? @[
        -> greater? #black 0                  -> greater? #black 0.0
        -> greater? #black to :rational [1 1] -> greater? #black 0`usd 
        -> greater? #black 0`m                -> greater? #black 0`m3
        -> greater? #black 0`c                -> greater? #black null 
        -> greater? #black true               -> greater? #black false 
        -> greater? #black maybe              -> greater? #black to :complex [0 0]
        -> greater? #black 0.0.0              -> greater? #black :color
        -> greater? #black '1'                -> greater? #black "#000000"
        -> greater? #black "000000"           -> greater? [#black] [black] 
        -> greater? #black 'black             -> greater? [#black] [.black]
        -> greater? [#black] [.black:]        -> greater? #black  {/#000000/}                 
        -> greater? #black{/000000/} 
    ] => not? passed
    
    ; for :function
    ensure -> every? @[
        -> greater? var 'null?     null       -> greater? var 'true?    true  
        -> greater? var 'false?    false 
        -> greater? var 'version?  1.0.0      -> greater? var 'type?    :type 
        -> greater? var 'function? :function  -> greater? var 'char?    'a' 
        -> greater? @[var 'word?]  [word]     -> greater? @[var 'word?] [var]      
        -> greater? @[var 'word?]  [var:]     -> greater? @[var 'word?] [word:]    
        -> greater? var 'word?     'word?     -> greater? var 'var      'var       
        -> greater? @[var 'word?]  [.var]     -> greater? @[var 'word?] [.word]    
        -> greater? @[var 'word?]  [.var:]    -> greater? @[var 'word?] [.word:]   
        -> greater? var 'regex?    {/var/}    -> greater? var 'regex?   {/regex?/} 
    ] => not? passed
    
    
]


topic « greaterOrEqual?
do [
    
    
    topic « greaterOrEqual? - :integer :floating :rational
    
    ensure -> greaterOrEqual? 2 1
    ensure -> greaterOrEqual? 2 1.0
    ensure -> greaterOrEqual? 2 to :rational @[1 1]
    ensure -> 2 >= 1
    ensure -> 2 >= 1.0
    ensure -> 2 >= to :rational @[1 1]
    passed
    
    ensure -> greaterOrEqual? 1 1
    ensure -> greaterOrEqual? 1 1.0
    ensure -> greaterOrEqual? 1 to :rational @[1 1]
    ensure -> 1 >= 1
    ensure -> 1 >= 1.0
    ensure -> 1 >= to :rational @[1 1]
    passed
    
    ensure -> not? greaterOrEqual? 1 2
    ensure -> not? greaterOrEqual? 1 2.0
    ensure -> not? greaterOrEqual? 1 to :rational @[2 1]
    ensure -> not? 1 >= 2
    ensure -> not? 1 >= 2.0
    ensure -> not? 1 >= :rational @[2 1]
    passed
    
    
    ensure -> greaterOrEqual? 2.0 1
    ensure -> greaterOrEqual? 2.0 1.0
    ensure -> greaterOrEqual? 2.0 to :rational @[1 1]
    ensure -> 2.0 >= 1
    ensure -> 2.0 >= 1.0
    ensure -> 2.0 >= to :rational @[1 1]
    passed
    
    ensure -> greaterOrEqual? 1.0 1
    ensure -> greaterOrEqual? 1.0 1.0
    ensure -> greaterOrEqual? 1.0 to :rational @[1 1]
    ensure -> 1.0 >= 1
    ensure -> 1.0 >= 1.0
    ensure -> 1.0 >= to :rational @[1 1]
    passed
    
    ensure -> not? greaterOrEqual? 1.0 2
    ensure -> not? greaterOrEqual? 1.0 2.0
    ensure -> not? greaterOrEqual? 1.0 to :rational @[2 1]
    ensure -> not? 1.0 >= 2
    ensure -> not? 1.0 >= 2.0
    ensure -> not? 1.0 >= :rational @[2 1]
    passed
    
    
    ensure -> greaterOrEqual? to :rational @[2 1] 1
    ensure -> greaterOrEqual? to :rational @[2 1] 1.0
    ensure -> greaterOrEqual? to :rational @[2 1] to :rational @[1 1]
    ensure -> (to :rational @[2 1]) >= 1
    ensure -> (to :rational @[2 1]) >= 1.0
    ensure -> (to :rational @[2 1]) >= to :rational @[1 1]
    passed
    
    ensure -> greaterOrEqual? to :rational @[1 1] 1
    ensure -> greaterOrEqual? to :rational @[1 1] 1.0
    ensure -> greaterOrEqual? to :rational @[1 1] to :rational @[1 1]
    ensure -> (to :rational @[1 1]) >= 1
    ensure -> (to :rational @[1 1]) >= 1.0
    ensure -> (to :rational @[1 1]) >= to :rational @[1 1]
    passed
    
    ensure -> not? greaterOrEqual? to :rational @[1 1] 2
    ensure -> not? greaterOrEqual? to :rational @[1 1] 2.0
    ensure -> not? greaterOrEqual? to :rational @[1 1] to :rational @[2 1]
    ensure -> not? (to :rational @[1 1]) >= 2
    ensure -> not? (to :rational @[1 1]) >= 2.0
    ensure -> not? (to :rational @[1 1]) >= :rational @[2 1]
    passed
    
    topic « greaterOrEqual? - :quantity
    
    ; equal to
    
    ensure -> greaterOrEqual? 1`usd 1
    ensure -> greaterOrEqual? 1`m   1
    ensure -> greaterOrEqual? 1`m2  1
    ensure -> greaterOrEqual? 1`m3  1
    ensure -> greaterOrEqual? 1`c   1
    ensure -> greaterOrEqual? 1`f   1
    ensure -> greaterOrEqual? 1 1`usd
    ensure -> greaterOrEqual? 1 1`m
    ensure -> greaterOrEqual? 1 1`m2
    ensure -> greaterOrEqual? 1 1`m3
    ensure -> greaterOrEqual? 1 1`c
    ensure -> greaterOrEqual? 1 1`f
    passed
    
    ensure -> greaterOrEqual? 1`usd 1.0
    ensure -> greaterOrEqual? 1`m   1.0
    ensure -> greaterOrEqual? 1`m2  1.0
    ensure -> greaterOrEqual? 1`m3  1.0
    ensure -> greaterOrEqual? 1`c   1.0
    ensure -> greaterOrEqual? 1`f   1.0
    ensure -> greaterOrEqual? 1.0 1`usd
    ensure -> greaterOrEqual? 1.0 1`m
    ensure -> greaterOrEqual? 1.0 1`m2
    ensure -> greaterOrEqual? 1.0 1`m3
    ensure -> greaterOrEqual? 1.0 1`c
    ensure -> greaterOrEqual? 1.0 1`f
    passed
    
    ensure -> greaterOrEqual? 1`usd to :rational @[5 5]
    ensure -> greaterOrEqual? 1`m   to :rational @[5 5]
    ensure -> greaterOrEqual? 1`m2  to :rational @[5 5]
    ensure -> greaterOrEqual? 1`m3  to :rational @[5 5]
    ensure -> greaterOrEqual? 1`c   to :rational @[5 5]
    ensure -> greaterOrEqual? 1`f   to :rational @[5 5] 
    ensure -> greaterOrEqual? to :rational @[5 5] 1`usd
    ensure -> greaterOrEqual? to :rational @[5 5] 1`m
    ensure -> greaterOrEqual? to :rational @[5 5] 1`m2
    ensure -> greaterOrEqual? to :rational @[5 5] 1`m3
    ensure -> greaterOrEqual? to :rational @[5 5] 1`c
    ensure -> greaterOrEqual? to :rational @[5 5] 1`f
    passed
    
    
    ; less than
    
    ensure -> not? greaterOrEqual? 1`usd 2
    ensure -> not? greaterOrEqual? 1`m   2
    ensure -> not? greaterOrEqual? 1`m2  2
    ensure -> not? greaterOrEqual? 1`m3  2
    ensure -> not? greaterOrEqual? 1`c   2
    ensure -> not? greaterOrEqual? 1`f   2
    ensure -> not? greaterOrEqual? 1 2`usd
    ensure -> not? greaterOrEqual? 1 2`m
    ensure -> not? greaterOrEqual? 1 2`m2
    ensure -> not? greaterOrEqual? 1 2`m3
    ensure -> not? greaterOrEqual? 1 2`c
    ensure -> not? greaterOrEqual? 1 2`f
    passed
    
    ensure -> not? greaterOrEqual? 1`usd 2.0
    ensure -> not? greaterOrEqual? 1`m   2.0
    ensure -> not? greaterOrEqual? 1`m2  2.0
    ensure -> not? greaterOrEqual? 1`m3  2.0
    ensure -> not? greaterOrEqual? 1`c   2.0
    ensure -> not? greaterOrEqual? 1`f   2.0
    ensure -> not? greaterOrEqual? 1.0 2`usd
    ensure -> not? greaterOrEqual? 1.0 2`m
    ensure -> not? greaterOrEqual? 1.0 2`m2
    ensure -> not? greaterOrEqual? 1.0 2`m3
    ensure -> not? greaterOrEqual? 1.0 2`c
    ensure -> not? greaterOrEqual? 1.0 2`f
    passed
    
    ensure -> not? greaterOrEqual? 1`usd to :rational @[2 1]
    ensure -> not? greaterOrEqual? 1`m   to :rational @[2 1]
    ensure -> not? greaterOrEqual? 1`m2  to :rational @[2 1]
    ensure -> not? greaterOrEqual? 1`m3  to :rational @[2 1]
    ensure -> not? greaterOrEqual? 1`c   to :rational @[2 1]
    ensure -> not? greaterOrEqual? 1`f   to :rational @[2 1] 
    ensure -> not? greaterOrEqual? to :rational @[1 1] 2`usd
    ensure -> not? greaterOrEqual? to :rational @[1 1] 2`m
    ensure -> not? greaterOrEqual? to :rational @[1 1] 2`m2
    ensure -> not? greaterOrEqual? to :rational @[1 1] 2`m3
    ensure -> not? greaterOrEqual? to :rational @[1 1] 2`c
    ensure -> not? greaterOrEqual? to :rational @[1 1] 2`f
    passed
    
    
    ; greater than
    
    ensure -> greaterOrEqual? 2`usd 1
    ensure -> greaterOrEqual? 2`m   1
    ensure -> greaterOrEqual? 2`m2  1
    ensure -> greaterOrEqual? 2`m3  1
    ensure -> greaterOrEqual? 2`c   1
    ensure -> greaterOrEqual? 2`f   1
    ensure -> greaterOrEqual? 2 1`usd
    ensure -> greaterOrEqual? 2 1`m
    ensure -> greaterOrEqual? 2 1`m2
    ensure -> greaterOrEqual? 2 1`m3
    ensure -> greaterOrEqual? 2 1`c
    ensure -> greaterOrEqual? 2 1`f
    passed
    
    ensure -> greaterOrEqual? 2`usd 1.0
    ensure -> greaterOrEqual? 2`m   1.0
    ensure -> greaterOrEqual? 2`m2  1.0
    ensure -> greaterOrEqual? 2`m3  1.0
    ensure -> greaterOrEqual? 2`c   1.0
    ensure -> greaterOrEqual? 2`f   1.0
    ensure -> greaterOrEqual? 2.0 1`usd
    ensure -> greaterOrEqual? 2.0 1`m
    ensure -> greaterOrEqual? 2.0 1`m2
    ensure -> greaterOrEqual? 2.0 1`m3
    ensure -> greaterOrEqual? 2.0 1`c
    ensure -> greaterOrEqual? 2.0 1`f
    passed
    
    ensure -> greaterOrEqual? 2`usd to :rational @[5 5]
    ensure -> greaterOrEqual? 2`m   to :rational @[5 5]
    ensure -> greaterOrEqual? 2`m2  to :rational @[5 5]
    ensure -> greaterOrEqual? 2`m3  to :rational @[5 5]
    ensure -> greaterOrEqual? 2`c   to :rational @[5 5]
    ensure -> greaterOrEqual? 2`f   to :rational @[5 5] 
    ensure -> greaterOrEqual? to :rational @[2 1] 1`usd
    ensure -> greaterOrEqual? to :rational @[2 1] 1`m
    ensure -> greaterOrEqual? to :rational @[2 1] 1`m2
    ensure -> greaterOrEqual? to :rational @[2 1] 1`m3
    ensure -> greaterOrEqual? to :rational @[2 1] 1`c
    ensure -> greaterOrEqual? to :rational @[2 1] 1`f
    passed
    
    
    ensure -> greaterOrEqual? 1.5`m 150`cm 
    ensure -> greaterOrEqual? 2`m 2`cm
    passed 
    
    
    topic « greaterOrEqual? - :null
    
    ensure -> greaterOrEqual? null null
    ensure -> greaterOrEqual? null ø
    ensure -> greaterOrEqual? ø ø
    ensure -> greaterOrEqual? ø null
    ensure -> null >= null
    ensure -> null >= ø
    ensure -> ø >= ø
    ensure -> ø >= null
    passed
    
    ensure -> not? greaterOrEqual? ø 1
    ensure -> not? greaterOrEqual? ø 1.0
    ensure -> not? greaterOrEqual? ø "ø"
    ensure -> not? greaterOrEqual? ø 'ø'
    ensure -> not? ø >= 1
    ensure -> not? ø >= 1.0
    ensure -> not? ø >= "ø"
    ensure -> not? ø >= 'ø'
    passed
    
    
    topic « greaterOrEqual? - :logical
    
    ensure -> greaterOrEqual? true true
    ensure -> greaterOrEqual? true (1 > 0)
    ensure -> true >= true
    ensure -> true >= (1 > 0)
    passed
    
    ensure -> not? greaterOrEqual? true maybe
    ensure -> not? greaterOrEqual? true false
    ensure -> not? true >= maybe
    ensure -> not? true >= false
    passed
    
    
    topic « greaterOrEqual? - :complex
    
    ; greater than
    ensure -> greaterOrEqual? to :complex [2 2] to :complex [1 2]
    ensure -> greaterOrEqual? to :complex [1 3] to :complex [1 2]
    ensure -> (to :complex [2 2]) >= (to :complex [1 2])
    ensure -> (to :complex [1 3]) >= (to :complex [1 2])
    passed
    
    ; equal to
    ensure -> greaterOrEqual? to :complex [1 2] to :complex [1 2] 
    ensure -> (to :complex [1 2]) >= (to :complex [1 2]) 
    passed
    
    ; less than
    ensure -> not? greaterOrEqual? to :complex [0 2] to :complex [1 2] 
    ensure -> not? greaterOrEqual? to :complex [1 1] to :complex [1 2]
    ensure -> not? (to :complex [0 2]) >= (to :complex [1 2]) 
    ensure -> not? (to :complex [1 1]) >= (to :complex [1 2])
    passed
    
    
    topic « greaterOrEqual? - :version
    
    ensure -> greaterOrEqual? 1.2.3 1.2.2
    ensure -> 1.2.3 >= 1.2.2
    passed
    
    ensure -> greaterOrEqual? 1.2.3 1.2.3
    ensure -> 1.2.3 >= 1.2.3
    passed
    
    ensure -> greaterOrEqual? 1.2.3 1.2.3-pre
    ensure -> not? greaterOrEqual? 1.2.3-dev 1.2.3 
    ensure -> 1.2.3 >= 1.2.3-pre
    ensure -> not? 1.2.3-dev >= 1.2.3 
    passed
    
    
    topic « greaterOrEqual? - :type
    
    ensure -> greaterOrEqual? :char :char
    ensure -> greaterOrEqual? :string type "a"
    ensure -> greaterOrEqual? :integer type 1
    ensure -> greaterOrEqual? :floating type 1.5
    passed
    
    ensure -> not? greaterOrEqual? :char :string
    ensure -> not? greaterOrEqual? :integer :string
    ensure -> not? greaterOrEqual? :floating :integer   
    ensure -> not? greaterOrEqual? :string :integer
    ensure -> not? greaterOrEqual? :string :char
    ensure -> not? greaterOrEqual? :integer :floating
    passed
    
    
    topic « greaterOrEqual? - :char
    
    ensure -> greaterOrEqual? 'a' 'a'
    ensure -> 'a' >= 'a'
    passed
    
    ensure -> 'b' >= 'a'  
    ensure -> 'z' >= 'a'  
    passed
    
    ensure -> not? greaterOrEqual? 'a' "a" 
    ensure -> not? greaterOrEqual? '1'  1
    ensure -> not? greaterOrEqual? "a" 'a' 
    ensure -> not? greaterOrEqual? 'a' 'b'
    ensure -> not? greaterOrEqual?  1  '1'
    ensure -> not? 'a' >= "a" 
    ensure -> not? '1' >=  1
    ensure -> not? "a" >= 'a' 
    ensure -> not? 'a' >= 'b'
    ensure -> not?  1  >= '1'
    passed 
    
    
    topic « greaterOrEqual? - :string
    
    ensure -> greaterOrEqual? "Art" "Arturo" -- "uro"
    ensure -> "Art" >= "Arturo" -- "uro"
    passed
    
    ensure -> greaterOrEqual? "B" "A"  
    ensure -> greaterOrEqual? "Bob" "Art"
    ensure -> greaterOrEqual? "Artu" "Art"
    passed
    
    ensure -> not? greaterOrEqual? "b" 'a'
    ensure -> not? greaterOrEqual? "b" 'b'
    ensure -> not? greaterOrEqual? "b" 'a
    ensure -> not? greaterOrEqual? "b" 'b
    ensure -> not? greaterOrEqual? "b" to :word "a"
    ensure -> not? greaterOrEqual? "b" to :word "b"
    ensure -> not? greaterOrEqual? "b" to :label "a"
    ensure -> not? greaterOrEqual? "b" to :label "b"
    ensure -> not? greaterOrEqual? "b" to :attribute "a"
    ensure -> not? greaterOrEqual? "b" to :attribute "b"
    ensure -> not? greaterOrEqual? "b" to :attributelabel "a"
    ensure -> not? greaterOrEqual? "b" to :attributelabel "b"
    ensure -> not? greaterOrEqual? "b" to :type "a"
    ensure -> not? greaterOrEqual? "b" to :type "b"
    passed
    
    
    topic « greaterOrEqual? - :word
    
    ensure -> greaterOrEqual? to :word "b" to :word "a"
    ensure -> greaterOrEqual? to :word "a" to :word "a"
    ensure -> greaterOrEqual? to :word "b" to :word "b"
    ensure -> not? greaterOrEqual? to :word "a" to :word "b"
    passed
    
    ensure -> not? greaterOrEqual? to :word "b" "a"
    ensure -> not? greaterOrEqual? to :word "b" "b"
    ensure -> not? greaterOrEqual? to :word "b" 'a'
    ensure -> not? greaterOrEqual? to :word "b" 'b'
    ensure -> not? greaterOrEqual? to :word "b" 'a
    ensure -> not? greaterOrEqual? to :word "b" 'b
    ensure -> not? greaterOrEqual? to :word "b" to :label "a"
    ensure -> not? greaterOrEqual? to :word "b" to :label "b"
    ensure -> not? greaterOrEqual? to :word "b" to :attribute "a"
    ensure -> not? greaterOrEqual? to :word "b" to :attribute "b"
    ensure -> not? greaterOrEqual? to :word "b" to :attributelabel "a"
    ensure -> not? greaterOrEqual? to :word "b" to :attributelabel "b"
    ensure -> not? greaterOrEqual? to :word "b" to :type "a"
    ensure -> not? greaterOrEqual? to :word "b" to :type "b"
    passed
    
    
    topic « greaterOrEqual? - :label
    
    ensure -> greaterOrEqual? to :label "b" to :label "a"
    ensure -> greaterOrEqual? to :label "a" to :label "a"
    ensure -> greaterOrEqual? to :label "b" to :label "b"
    ensure -> not? greaterOrEqual? to :label "a" to :label "b"
    passed
    
    ensure -> not? greaterOrEqual? to :label "b" "a"
    ensure -> not? greaterOrEqual? to :label "b" "b"
    ensure -> not? greaterOrEqual? to :label "b" 'a'
    ensure -> not? greaterOrEqual? to :label "b" 'b'
    ensure -> not? greaterOrEqual? to :label "b" 'a
    ensure -> not? greaterOrEqual? to :label "b" 'b
    ensure -> not? greaterOrEqual? to :label "b" to :word "a"
    ensure -> not? greaterOrEqual? to :label "b" to :word "b"
    ensure -> not? greaterOrEqual? to :label "b" to :attribute "a"
    ensure -> not? greaterOrEqual? to :label "b" to :attribute "b"
    ensure -> not? greaterOrEqual? to :label "b" to :attributelabel "a"
    ensure -> not? greaterOrEqual? to :label "b" to :attributelabel "b"
    ensure -> not? greaterOrEqual? to :label "b" to :type "a"
    ensure -> not? greaterOrEqual? to :label "b" to :type "b"
    passed
    
    
    topic « greaterOrEqual? - :literal
    
    ensure -> greaterOrEqual? 'b 'a
    ensure -> greaterOrEqual? 'a 'a
    ensure -> greaterOrEqual? 'b 'b
    ensure -> not? greaterOrEqual? 'a 'b
    passed
    
    ensure -> not? greaterOrEqual? 'b "a"
    ensure -> not? greaterOrEqual? 'b "b"
    ensure -> not? greaterOrEqual? 'b 'a'
    ensure -> not? greaterOrEqual? 'b 'b'
    ensure -> not? greaterOrEqual? 'b to :word "a"
    ensure -> not? greaterOrEqual? 'b to :word "b"
    ensure -> not? greaterOrEqual? 'b to :label "a"
    ensure -> not? greaterOrEqual? 'b to :label "b"
    ensure -> not? greaterOrEqual? 'b to :attribute "a"
    ensure -> not? greaterOrEqual? 'b to :attribute "b"
    ensure -> not? greaterOrEqual? 'b to :attributelabel "a"
    ensure -> not? greaterOrEqual? 'b to :attributelabel "b"
    ensure -> not? greaterOrEqual? 'b to :type "a"
    ensure -> not? greaterOrEqual? 'b to :type "b"
    passed
    
    
    topic « greaterOrEqual? - :path
    
    a: #[name: "John", surname: "Doe"]
    b: @["Joe" "Jane" "Jesse"]
    
    ensure -> greaterOrEqual? a\name "John" 
    ensure -> greaterOrEqual? a\surname "Doe" 
    ensure -> greaterOrEqual? a\name "Jane" 
    ensure -> not? greaterOrEqual? a\name 1 
    passed
    
    ensure -> not? greaterOrEqual? a\name "Kennedy" 
    ensure -> not? greaterOrEqual? a\surname "Moe" 
    ensure -> not? greaterOrEqual? a\name "Payne" 
    ensure -> not? greaterOrEqual? b\2 "Walter" 
    passed
    
    ensure -> greaterOrEqual? b\0 "Joe" 
    ensure -> greaterOrEqual? b\1 "Jane" 
    ensure -> greaterOrEqual? b\2 "Jesse" 
    passed
    
    ensure -> greaterOrEqual? [b\0] [b\0]
    ensure -> greaterOrEqual? [a\name] [a\name]
    ensure -> not? greaterOrEqual? [b\0] [b\1]
    ; ensure -> greaterOrEqual? [a\name] [a\surname]
    passed
    
    
    topic « greaterOrEqual? - :pathLabel
       
    ensure -> greaterOrEqual? [a\name: "John"]   [a\name: "John"]
    ensure -> not? greaterOrEqual? [a\surname: "Doe"] [b\surname: "Doe" ]
    ensure -> not? greaterOrEqual? [a\name: "John"]   [b\name: "Jane"]
    ensure -> not? greaterOrEqual? [a\name: "John"]   [b\name: "John"]
    passed
    
    
    topic « greaterOrEqual? - :attribute
    
    ensure -> greaterOrEqual? to :attribute "b" to :attribute "a"
    ensure -> greaterOrEqual? to :attribute "a" to :attribute "a"
    ensure -> greaterOrEqual? to :attribute "b" to :attribute "b"
    ensure -> not? greaterOrEqual? to :attribute "a" to :attribute "b"
    passed
    
    ensure -> not? greaterOrEqual? to :attribute "b" "a"
    ensure -> not? greaterOrEqual? to :attribute "b" "b"
    ensure -> not? greaterOrEqual? to :attribute "b" 'a'
    ensure -> not? greaterOrEqual? to :attribute "b" 'b'
    ensure -> not? greaterOrEqual? to :attribute "b" 'a
    ensure -> not? greaterOrEqual? to :attribute "b" 'b
    ensure -> not? greaterOrEqual? to :attribute "b" to :word "a"
    ensure -> not? greaterOrEqual? to :attribute "b" to :word "b"
    ensure -> not? greaterOrEqual? to :attribute "b" to :label "a"
    ensure -> not? greaterOrEqual? to :attribute "b" to :label "b"
    ensure -> not? greaterOrEqual? to :attribute "b" to :attributelabel "a"
    ensure -> not? greaterOrEqual? to :attribute "b" to :attributelabel "b"
    ensure -> not? greaterOrEqual? to :attribute "b" to :type "a"
    ensure -> not? greaterOrEqual? to :attribute "b" to :type "b"
    passed
    
    
    topic « greaterOrEqual? - :attributelabel
    
    ensure -> greaterOrEqual? to :attributelabel "b" to :attributelabel "a"
    ensure -> greaterOrEqual? to :attributelabel "a" to :attributelabel "a"
    ensure -> greaterOrEqual? to :attributelabel "b" to :attributelabel "b"
    ensure -> not? greaterOrEqual? to :attributelabel "a" to :attributelabel "b"
    passed
    
    ensure -> not? greaterOrEqual? to :attributelabel "b" "a"
    ensure -> not? greaterOrEqual? to :attributelabel "b" "b"
    ensure -> not? greaterOrEqual? to :attributelabel "b" 'a'
    ensure -> not? greaterOrEqual? to :attributelabel "b" 'b'
    ensure -> not? greaterOrEqual? to :attributelabel "b" 'a
    ensure -> not? greaterOrEqual? to :attributelabel "b" 'b
    ensure -> not? greaterOrEqual? to :attributelabel "b" to :word "a"
    ensure -> not? greaterOrEqual? to :attributelabel "b" to :word "b"
    ensure -> not? greaterOrEqual? to :attributelabel "b" to :label "a"
    ensure -> not? greaterOrEqual? to :attributelabel "b" to :label "b"
    ensure -> not? greaterOrEqual? to :attributelabel "b" to :attribute "a"
    ensure -> not? greaterOrEqual? to :attributelabel "b" to :attribute "b"
    ensure -> not? greaterOrEqual? to :attributelabel "b" to :type "a"
    ensure -> not? greaterOrEqual? to :attributelabel "b" to :type "b"
    passed
    
    
    topic « greaterOrEqual? - :symbol
    
    ensure -> greaterOrEqual? to :symbol "+" to :symbol "+"
    ensure -> not? greaterOrEqual? to :symbol "+" to :symbol "-"
    ensure -> not? greaterOrEqual? to :symbol "+" to :symbol "++"
    ensure -> not? greaterOrEqual? to :symbol "+" '+'
    ensure -> not? greaterOrEqual? to :symbol "+" {+}
    ensure -> not? greaterOrEqual? to :symbol "+" "+"
    ensure -> not? greaterOrEqual? to :symbol "+" to :word "plus"
    ensure -> not? greaterOrEqual? to :symbol "+" '+
    passed
    
    
    topic « greaterOrEqual? - :regex
    
    ensure -> regex? {/[A-Z]/}
    ensure -> greaterOrEqual? {/[A-Z]/} {/[A-Z]/} 
    ensure -> not? greaterOrEqual? {/[A-Z]/} {/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/}
    ensure -> not? greaterOrEqual? {/[A-Z]/} {[A-Z]}
    ensure -> not? greaterOrEqual? {/[A-Z]/} "/[A-Z]/"
    passed
    
    
    topic « greaterOrEqual? - :binary
    
    ensure -> not? greaterOrEqual? 
        to :binary "Arturo"
        to :binary "Hello world"
    ensure -> not? greaterOrEqual? to :binary 1 to :binary 0
    ensure -> greaterOrEqual? to :binary 1 to :binary 1
    ensure -> not? greaterOrEqual? to :binary 1 to :binary 10
    ensure -> not? greaterOrEqual? to :binary 1 to :binary 5
    passed
    
    
    topic « greaterOrEqual? - :bytecode
    
    x: to :bytecode [["print"][1 112 155]]
    
    ensure -> greaterOrEqual? x to :bytecode [["print"][1 112 155]]
    ensure -> not? greaterOrEqual? x to :bytecode [["print"][2 112 155]]
    ensure -> not? greaterOrEqual? x [["print"][2 112 155]]
    passed
    
    
    topic « greaterOrEqual? - :inline
    
    ensure -> greaterOrEqual? [(2 + 2)] [(2 + 2)]
    ensure -> greaterOrEqual? [(2 3 4 5)] [(2 3 4 5)]
    passed
    
    ensure -> not? greaterOrEqual? [(2 + 2)] [(2 + 1)]
    ensure -> not? greaterOrEqual? [(2 3 4 5)] [(2 1 4 5)]
    passed

    a: [(2 1 4 5)]
    b: [(2 3 4)] 
    ensure -> greaterOrEqual? a\0 b\0
    passed
    
    
    topic « greaterOrEqual? - :block
    
    a: [1 + 1]
    ensure -> greaterOrEqual? a [1 + 1]
    ensure -> greaterOrEqual? [1 1] [1]
    ensure -> greaterOrEqual? a [2]
    ensure -> not? greaterOrEqual? a 2
    ensure -> not? greaterOrEqual? a [1 ++ 1]
    ensure -> not? greaterOrEqual? [2] [1]
    ensure -> not? greaterOrEqual? [1] [2]
    passed
    
    
    topic « greaterOrEqual? - :range
    
    ensure -> greaterOrEqual? 0..5 0..5
    ensure -> greaterOrEqual? [0 1 2 3 4 5] @0..5
    ensure -> greaterOrEqual? [0 2 4] @0.. .step: 2 5
    ensure -> greaterOrEqual? @range.step: 2 0 5 @range.step: 2 0 4
    ensure -> not? greaterOrEqual? range.step: 2 0 5 range.step: 2 0 4
    passed
    
    
    topic « greaterOrEqual? - :dictionary
    
    a: #[name: "Walter" surname: "Pinkman"]
    
    ensure -> greaterOrEqual? a #[name: "Walter" surname: "Pinkman"]
    ensure -> not? greaterOrEqual? a #[name: "Jesse" surname: "Pinkman"]
    ensure -> not? greaterOrEqual? a #[name "Jesse" surname "Pinkman"]
    ensure -> not? greaterOrEqual? a [name "Jesse" surname "Pinkman"]
    passed
    
    
    topic « greaterOrEqual? - :object
    
    define :person [  
        init: method [name, age][
            this\name: capitalize name
            this\age: age
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|"
        ] 
    ]
    
    define :student is :person [  
        init: method [name, age, id][
            this\name: capitalize name
            this\age: age
            this\id: id
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
        ]
    ]
    
    a: to :person ["Joe" 32]
    ensure -> greaterOrEqual? a to :person ["Joe" 32]
    ensure -> not? greaterOrEqual? to :person ["Joe" 32] #[name: "Joe" age: 32]
    ensure -> not? greaterOrEqual? to :person ["Joe" 32] to :student ["Joe" 32 15]
    passed
    
    a\name: "Jane"
    ensure -> greaterOrEqual? a to :person ["Jane" 32]
    passed
    
    define :person [  
        init: method [name, age][
            this\name: capitalize name
            this\age: age
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|"
        ]
        compare: method [that][
            if this\age > that\age -> return 1
            if this\age = that\age -> return 0
            if this\age < that\age -> return neg 1
        ]   
    ]
    
    define :student is :person [  
        init: method [name, age, id][
            this\name: capitalize name
            this\age: age
            this\id: id
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
        ]
    ]
    
    a: to :person ["John" 16]
    b: to :student ["Jane" 16 100]
    c: to :person ["John" 15]
    d: to :student ["Jane" 16 100]
    ensure -> greaterOrEqual? a b
    ensure -> greaterOrEqual? b a
    ensure -> not? greaterOrEqual? c d
    ensure -> greaterOrEqual? d c
    
    
    topic « greaterOrEqual? - :store
    
    a: store "test.db"
    a\name: "John" a\surname: "Doe"
    b: store "test.db"
    b\name: "John" b\surname: "Doe"
    c: store "test2.db"
    c\name: "John" c\surname: "Doe"
    d: store "test3.db"
    d\name: "Jane" d\surname: "Doe"
    
    ensure -> greaterOrEqual? a a
    ensure -> greaterOrEqual? a b
    ensure -> greaterOrEqual? b a
    passed
    
    ensure -> not? greaterOrEqual? a c 
    ensure -> not? greaterOrEqual? c a 
    ensure -> not? greaterOrEqual? a d 
    ensure -> not? greaterOrEqual? d a 
    ensure -> not? greaterOrEqual? c d 
    ensure -> not? greaterOrEqual? d c 
    passed
    
    
    topic « greaterOrEqual? - :color
    
    ensure -> greaterOrEqual? #000   #black
    ensure -> greaterOrEqual? #fff   #white
    ensure -> greaterOrEqual? #white #white
    ensure -> not? greaterOrEqual? #black #white
    ensure -> not? greaterOrEqual? #white #black
    passed
    
    
    topic « greaterOrEqual? - :function
    
    ensure -> greaterOrEqual? var 'print var 'print
    ensure -> not? greaterOrEqual? var 'inspect var 'print
    passed
    
    a: $[name surname][]
    A: $[name][]
    b: $[name][]
    c: $[name surname][]
    
    ; note: I commented these, because they return SigSegv
    ; ensure -> greaterOrEqual? (var 'a) ($[name surname][])
    ; ensure -> greaterOrEqual? (var 'a) (var 'c)
    ensure -> not? greaterOrEqual? (var 'a) (var 'A)
    ensure -> not? greaterOrEqual? (var 'a) (var 'b)
    passed
    
    
    topic « greaterOrEqual? - :database
    ; note: implement this test
    
    
    topic « greaterOrEqual? - :date
    
    a: to :date .format: "MMM dd" "Jan 15"
    b: to :date .format: "MMM dd" "Jan 15"
    c: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    d: to :date .format: "MMM dd" "Jan 16"
    e: now
    
    ensure -> greaterOrEqual? d a
    ensure -> greaterOrEqual? e a
    ensure -> greaterOrEqual? c a
    passed
    
    ensure -> greaterOrEqual? a b 
    ensure -> not? greaterOrEqual? a d
    passed 
    
    topic « greaterOrEqual? - :unit
    
    ensure -> greaterOrEqual? `USD `USD
    ensure -> greaterOrEqual? `EUR `EUR
    ensure -> `USD >= `USD
    ensure -> `EUR >= `EUR
    passed
    
    ensure -> not? greaterOrEqual? `USD `EUR
    ensure -> not? greaterOrEqual? `EUR `USD
    ensure -> not? `EUR >= `USD
    passed
    
    
    topic « greaterOrEqual? - incompatible types
    
    ; NOTES: 
    ; - to avoid repetition some tests may be not explicitly included
    ; - this test part tries to cover the most of possible behaviors,
    ;     including the possility of the Comparison module be rewritten, 
    ;     avoiding future broken changes
    ; - some combinations were not made, because it's considered very
    ;     improbable to happen, even with a future rewrite of 
    ;     the Comparison module
    
    ; for :integer
    
    ensure -> not? every? @[
        -> greaterOrEqual? 1 1
        -> greaterOrEqual? 2 1
    ] => not?
    
    ensure -> every? @[
        -> greaterOrEqual? 1 null          -> greaterOrEqual? 1 true
        -> greaterOrEqual? 1 false         -> greaterOrEqual? 1 to :complex [1 1]
        -> greaterOrEqual? 1 1.0.0         -> greaterOrEqual? 1 :integer
        -> greaterOrEqual? 1 '1'           -> greaterOrEqual? 1 "1"
        -> greaterOrEqual? [1] [one]       -> greaterOrEqual? [1] [one:]
        -> greaterOrEqual? 1 '1            -> greaterOrEqual? [1] [.1]         
        -> greaterOrEqual? [1] [.1:]       -> greaterOrEqual? [1] [one\1]
        -> greaterOrEqual? [1] [one\1:]    -> greaterOrEqual? [1] [+]          
        -> greaterOrEqual? 1 {/1/}         -> greaterOrEqual? 1 to :binary 1   
        -> greaterOrEqual? 1 to :binary 1  -> greaterOrEqual? [1] [(1)]        
        -> greaterOrEqual? 1 [1]           -> greaterOrEqual? 1 1..1           
        -> greaterOrEqual? 1 #[one: 1]     -> greaterOrEqual? 0 #black         
        -> greaterOrEqual? 1 var 'one?
    ] => not? passed
    
    ; for :floating
    ensure -> every? @[
        -> greaterOrEqual? 1.0 null            -> greaterOrEqual? 1.0 true
        -> greaterOrEqual? 1.0 false           -> greaterOrEqual? 1.0 to :complex [1.0 1.0]
        -> greaterOrEqual? 1.0 1.0.0           -> greaterOrEqual? 1.0 :floating
        -> greaterOrEqual? 1.0 '1'             -> greaterOrEqual? 1.0 "1.0"
        -> greaterOrEqual? [1.0] [one]         -> greaterOrEqual? [1.0] [one:]
        -> greaterOrEqual? 1.0 '1.0i           -> greaterOrEqual? [1.0] [.1]            
        -> greaterOrEqual? [1.0] [.1:]         -> greaterOrEqual? [1.0] [one\1]
        -> greaterOrEqual? [1.0] [one\1:]      -> greaterOrEqual? [1.0] [+]           
        -> greaterOrEqual? 1.0 {/1.0/}         -> greaterOrEqual? 1.0 to :binary 1.0  
        -> greaterOrEqual? 1.0 to :binary 1.0  -> greaterOrEqual? [1.0] [(1.0)]       
        -> greaterOrEqual? 1.0 [1]             -> greaterOrEqual? 1.0 1..1            
        -> greaterOrEqual? 1.0 #[one: 1.0]     -> greaterOrEqual? 0.0 #black          
        -> greaterOrEqual? 1.0 var 'one?
    ] => not? passed
    
    ; for :rational
    a: to :rational [1 1]
    ensure -> every? @[
        -> greaterOrEqual? a null          -> greaterOrEqual? a true
        -> greaterOrEqual? a false         -> greaterOrEqual? a to :complex [1 1]
        -> greaterOrEqual? a 1.0.0         -> greaterOrEqual? a :rational
        -> greaterOrEqual? a '1'           -> greaterOrEqual? a "1/1"
        -> greaterOrEqual? @[a] [one]      -> greaterOrEqual? @[a] [one:]
        -> greaterOrEqual? 1 '1            -> greaterOrEqual? @[a] [.1]                 
        -> greaterOrEqual? @[a] [.1:]      -> greaterOrEqual? @[a] [one\1]
        -> greaterOrEqual? @[a] [one\1:]   -> greaterOrEqual? @[a] [+]                  
        -> greaterOrEqual? a {/1/1/}       -> greaterOrEqual? a to :binary 1            
        -> greaterOrEqual? a to :binary 1  -> greaterOrEqual? @[a] [(1)]                
        -> greaterOrEqual? a [1]           -> greaterOrEqual? a 1..1                    
        -> greaterOrEqual? a #[one: 1]     -> greaterOrEqual? to :rational [1 1] #black    
        -> greaterOrEqual? a var 'one?
    ] => not? passed
    
    ; for :quantity
    ensure -> every? @[
        -> greaterOrEqual? 1`usd null          -> greaterOrEqual? 1`usd true
        -> greaterOrEqual? 1`usd false         -> greaterOrEqual? 1`usd to :complex [1 1]
        -> greaterOrEqual? 1`usd 1.0.0         -> greaterOrEqual? 1`usd :quantity
        -> greaterOrEqual? 1`usd '1'           -> greaterOrEqual? 1`usd "1USD"
        -> greaterOrEqual? [1`usd] [one]       -> greaterOrEqual? [1`usd] [one:]
        -> greaterOrEqual? 1`usd '1.0i         -> greaterOrEqual? [1`usd] [.1]                  
        -> greaterOrEqual? [1`usd] [.1:]       -> greaterOrEqual? [1`usd] [one\1]
        -> greaterOrEqual? [1`usd] [one\1:]    -> greaterOrEqual? [1`usd] [+]         
        -> greaterOrEqual? 1`usd {/1USD/}      -> greaterOrEqual? 1`usd to :binary 1  
        -> greaterOrEqual? 1`usd to :binary 1  -> greaterOrEqual? [1`usd] [(1)]       
        -> greaterOrEqual? 1`usd [1`usd]       -> greaterOrEqual? 1`usd 1..1          
        -> greaterOrEqual? 1`usd #[one: 1`usd] -> greaterOrEqual? 0`usd #black        
        -> greaterOrEqual? 1`usd var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> greaterOrEqual? 1`m null            -> greaterOrEqual? 1`m true
        -> greaterOrEqual? 1`m false           -> greaterOrEqual? 1`m to :complex [1 1]
        -> greaterOrEqual? 1`m 1.0.0           -> greaterOrEqual? 1`m :quantity
        -> greaterOrEqual? 1`m '1'             -> greaterOrEqual? 1`m "1m"
        -> greaterOrEqual? [1`m] [one]         -> greaterOrEqual? [1`m] [one:]
        -> greaterOrEqual? 1`m '1              -> greaterOrEqual? [1`m] [.1]            
        -> greaterOrEqual? [1`m] [.1:]         -> greaterOrEqual? [1`m] [one\1]
        -> greaterOrEqual? [1`m] [one\1:]      -> greaterOrEqual? [1`m] [+]             
        -> greaterOrEqual? 1`m {/1m/}          -> greaterOrEqual? 1`m to :binary 1      
        -> greaterOrEqual? 1`m to :binary 1    -> greaterOrEqual? [1`m] [(1)]           
        -> greaterOrEqual? 1`m [1`m]           -> greaterOrEqual? 1`m 1..1              
        -> greaterOrEqual? 1`m #[one: 1`m]     -> greaterOrEqual? 0`m #black            
        -> greaterOrEqual? 1`m var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> greaterOrEqual? 1`m3 null           -> greaterOrEqual? 1`m3 true
        -> greaterOrEqual? 1`m3 false          -> greaterOrEqual? 1`m3 to :complex [1 1]
        -> greaterOrEqual? 1`m3 1.0.0          -> greaterOrEqual? 1`m3 :quantity
        -> greaterOrEqual? 1`m3 '1'            -> greaterOrEqual? 1`m3 "1m³"
        -> greaterOrEqual? [1`m3] [one]        -> greaterOrEqual? [1`m3] [one:]
        -> greaterOrEqual? 1`m3 '1             -> greaterOrEqual? [1`m3] [.1]              
        -> greaterOrEqual? [1`m3] [.1:]        -> greaterOrEqual? [1`m3] [one\1]
        -> greaterOrEqual? [1`m3] [one\1:]     -> greaterOrEqual? [1`m3] [+]                
        -> greaterOrEqual? 1`m3 {/1m³/}        -> greaterOrEqual? 1`m3 to :binary 1         
        -> greaterOrEqual? 1`m3 to :binary 1   -> greaterOrEqual? [1`m3] [(1)]              
        -> greaterOrEqual? 1`m3 [1`m3]         -> greaterOrEqual? 1`m3 1..1                 
        -> greaterOrEqual? 1`m3 #[one: 1`m3]   -> greaterOrEqual? 0`m3 #black               
        -> greaterOrEqual? 1`m3 var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> greaterOrEqual? 1`c null            -> greaterOrEqual? 1`c true
        -> greaterOrEqual? 1`c false           -> greaterOrEqual? 1`c to :complex [1 1]
        -> greaterOrEqual? 1`c 1.0.0           -> greaterOrEqual? 1`c :quantity
        -> greaterOrEqual? 1`c '1'             -> greaterOrEqual? 1`c "1°C"
        -> greaterOrEqual? [1`c] [one]         -> greaterOrEqual? [1`c] [one:]
        -> greaterOrEqual? 1`c '1.0i           -> greaterOrEqual? [1`c] [.1]            
        -> greaterOrEqual? [1`c] [.1:]         -> greaterOrEqual? [1`c] [one\1]       
        -> greaterOrEqual? [1`c] [one\1:]      -> greaterOrEqual? [1`c] [+]           
        -> greaterOrEqual? 1`c {/1°C/}         -> greaterOrEqual? 1`c to :binary 1    
        -> greaterOrEqual? 1`c to :binary 1    -> greaterOrEqual? [1`c] [(1)]         
        -> greaterOrEqual? 1`c [1`c]           -> greaterOrEqual? 1`c 1..1            
        -> greaterOrEqual? 1`c #[one: 1`c]     -> greaterOrEqual? 0`c #black          
        -> greaterOrEqual? 1`c var 'one?
    ] => not? passed
    
    ; for :null
    ensure -> every? @[
        -> greaterOrEqual? null 0                  -> greaterOrEqual? null 0.0            
        -> greaterOrEqual? null to :rational [1 1] -> greaterOrEqual? null true
        -> greaterOrEqual? null false              -> greaterOrEqual? null to :complex [0 0]
        -> greaterOrEqual? null 0.0.0              -> greaterOrEqual? null :null
        -> greaterOrEqual? null 'ø'                -> greaterOrEqual? null "null"
        -> greaterOrEqual? @[null] [null]          -> greaterOrEqual? @[null] [null:]
        -> greaterOrEqual? null 'null              -> greaterOrEqual? @[null] [.null]               
        -> greaterOrEqual? @[null] [.null:]        -> greaterOrEqual? @[null] [null\null]
        -> greaterOrEqual? @[null] [null\null:]    -> greaterOrEqual? @[null] [ø]                   
        -> greaterOrEqual? null {/null/}           -> greaterOrEqual? null {/ø/}                    
        -> greaterOrEqual? null to :binary 0       -> greaterOrEqual? null to :binary 0             
        -> greaterOrEqual? @[null] [(null)]        -> greaterOrEqual? null [null]                   
        -> greaterOrEqual? null 0..0               -> greaterOrEqual? null #[null: null]            
        -> greaterOrEqual? null #black          
        -> greaterOrEqual? null var 'null?
    ] => not? passed
    
    ; for :logical
    ensure -> every? @[
        -> greaterOrEqual? true 0                  -> greaterOrEqual? true 0.0            
        -> greaterOrEqual? true to :rational [1 1] -> greaterOrEqual? true to :complex [0 0]
        -> greaterOrEqual? true 0.0.0              -> greaterOrEqual? true :true
        -> greaterOrEqual? true '0'                -> greaterOrEqual? true "true"
        -> greaterOrEqual? @[true] [true]          -> greaterOrEqual? @[true] [true:]
        -> greaterOrEqual? true 'true              -> greaterOrEqual? @[true] [.true]               
        -> greaterOrEqual? @[true] [.true:]        -> greaterOrEqual? @[true] [true\true]
        -> greaterOrEqual? @[true] [true\true:]    -> greaterOrEqual? @[true] [ø]                   
        -> greaterOrEqual? true {/true/}           -> greaterOrEqual? true to :binary 0             
        -> greaterOrEqual? true to :binary 0       -> greaterOrEqual? @[true] [(true)]              
        -> greaterOrEqual? true [true]             -> greaterOrEqual? true 0..0                     
        -> greaterOrEqual? true #[true: true]      -> greaterOrEqual? true #black                   
        -> greaterOrEqual? true var 'true?
    ] => not? passed
    
    ensure -> every? @[
        -> greaterOrEqual? false 0                     -> greaterOrEqual? false 0.0            
        -> greaterOrEqual? false to :rational [1 1]    -> greaterOrEqual? false to :complex [0 0]
        -> greaterOrEqual? false 0.0.0                 -> greaterOrEqual? false :false
        -> greaterOrEqual? false '0'                   -> greaterOrEqual? false "false"
        -> greaterOrEqual? @[false] [false]            -> greaterOrEqual? @[false] [false:]
        -> greaterOrEqual? false 'false                -> greaterOrEqual? @[false] [.false]                 
        -> greaterOrEqual? @[false] [.false:]          -> greaterOrEqual? @[false] [false\false]
        -> greaterOrEqual? @[false] [false\false:]     -> greaterOrEqual? @[false] [ø]                      
        -> greaterOrEqual? false {/false/}             -> greaterOrEqual? false to :binary 0                
        -> greaterOrEqual? false to :binary 0          -> greaterOrEqual? @[false] [(false)]                
        -> greaterOrEqual? false [false]               -> greaterOrEqual? false 0..0                        
        -> greaterOrEqual? false #[false: false]       -> greaterOrEqual? false #black                      
        -> greaterOrEqual? false var 'false?
    ] => not? passed
    
    ensure -> every? @[
        -> greaterOrEqual? maybe 0                     -> greaterOrEqual? maybe 0.0            
        -> greaterOrEqual? maybe to :rational [1 1]    -> greaterOrEqual? maybe to :complex [0 0]
        -> greaterOrEqual? maybe 0.0.0                 -> greaterOrEqual? maybe :maybe
        -> greaterOrEqual? maybe '0'                   -> greaterOrEqual? maybe "maybe"
        -> greaterOrEqual? @[maybe] [maybe]            -> greaterOrEqual? @[maybe] [maybe:]
        -> greaterOrEqual? maybe 'maybe                -> greaterOrEqual? @[maybe] [.maybe]                 
        -> greaterOrEqual? @[maybe] [.maybe:]          -> greaterOrEqual? @[maybe] [maybe\maybe]
        -> greaterOrEqual? @[maybe] [maybe\maybe:]     -> greaterOrEqual? @[maybe] [ø]                      
        -> greaterOrEqual? maybe {/maybe/}             -> greaterOrEqual? maybe to :binary 0                
        -> greaterOrEqual? maybe to :binary 0A         -> greaterOrEqual? @[maybe] [(maybe)]                
        -> greaterOrEqual? maybe [maybe]               -> greaterOrEqual? maybe 0..0                        
        -> greaterOrEqual? maybe #[maybe: maybe]       -> greaterOrEqual? maybe #black                      
    ] => not? passed
    
    ; for :complex
    a: to :complex [1 1]
    ensure -> every? @[
        -> greaterOrEqual? a 1                     -> greaterOrEqual? a 1.0            
        -> greaterOrEqual? a to :rational [1 1]    -> greaterOrEqual? a null                    
        -> greaterOrEqual? a true                  -> greaterOrEqual? a false
        -> greaterOrEqual? a 1.0.0                 -> greaterOrEqual? a :rational
        -> greaterOrEqual? a '1'                   -> greaterOrEqual? a "1.0+1.0i"
        -> greaterOrEqual? @[a] [one]              -> greaterOrEqual? @[a] [one:]
        -> greaterOrEqual? 1 '1                    -> greaterOrEqual? @[a] [.1]                 
        -> greaterOrEqual? @[a] [.1:]              -> greaterOrEqual? @[a] [one\1]
        -> greaterOrEqual? @[a] [one\1:]           -> greaterOrEqual? @[a] [+]                  
        -> greaterOrEqual? a {/1.0+1.0i/}          -> greaterOrEqual? a to :binary 1            
        -> greaterOrEqual? a to :binary 1          -> greaterOrEqual? @[a] [(1)]                
        -> greaterOrEqual? a [1]                   -> greaterOrEqual? a 1..1                    
        -> greaterOrEqual? a #[one: 1]             -> greaterOrEqual? to :complex [0 0] #black  
        -> greaterOrEqual? a var 'one?
    ] => not? passed
    
    ; for :version
    ensure -> every? @[
        -> greaterOrEqual? 1.0.0 1                     -> greaterOrEqual? 1.0.0 1.0          
        -> greaterOrEqual? 1.0.0 to :rational [1 1]    -> greaterOrEqual? 1.0.0 null                    
        -> greaterOrEqual? 1.0.0 true                  -> greaterOrEqual? 1.0.0 false                   
        -> greaterOrEqual? 1.0.0 to :complex [1.0 1.0] -> greaterOrEqual? 1.0.0 :floating
        -> greaterOrEqual? 1.0.0 '1'                   -> greaterOrEqual? 1.0.0 "1.0.0"
        -> greaterOrEqual? [1.0.0] [one]               -> greaterOrEqual? [1.0.0] [one:]
        -> greaterOrEqual? 1.0.0 '1                    -> greaterOrEqual? [1.0.0] [.1]                  
        -> greaterOrEqual? [1.0.0] [.1:]               -> greaterOrEqual? [1.0.0] [one\1]
        -> greaterOrEqual? [1.0.0] [one\1:]            -> greaterOrEqual? [1.0.0] [+]                   
        -> greaterOrEqual? 1.0.0 {/1.0.0/}             -> greaterOrEqual? 1.0.0 to :binary 1.0          
        -> greaterOrEqual? 1.0.0 to :binary 1.0        -> greaterOrEqual? [1.0.0] [(1.0.0)]             
        -> greaterOrEqual? 1.0.0 [1.0.0]               -> greaterOrEqual? 1.0.0 1..1                    
        -> greaterOrEqual? 1.0.0 #[one: 1.0.0]         -> greaterOrEqual? 0.0.0 #black                  
        -> greaterOrEqual? 1.0.0 var 'version?
    ] => not? passed
    
    ; for :type
    ensure -> every? @[
        -> greaterOrEqual? :1 1                            -> greaterOrEqual? :1 1.0          
        -> greaterOrEqual? :integer 1                      -> greaterOrEqual? :floating 1.0          
        -> greaterOrEqual? :rational to :rational [1 1]    -> greaterOrEqual? :null null                    
        -> greaterOrEqual? :true true                      -> greaterOrEqual? :false false                   
        -> greaterOrEqual? :logical false                  -> greaterOrEqual? :complex to :complex [1 1]   
        -> greaterOrEqual? :version 1.0.0                  -> greaterOrEqual? :T 'T'                         
        -> greaterOrEqual? :char 'T'                       -> greaterOrEqual? :string ":type"
        -> greaterOrEqual? [:type] [type]                  -> greaterOrEqual? [:word] [word]                     
        -> greaterOrEqual? [:type] [type:]                 -> greaterOrEqual? [:label] [label:]
        -> greaterOrEqual? :1 '1.                          -> greaterOrEqual? :literal '1                       
        -> greaterOrEqual? [:type] [.type]                 -> greaterOrEqual? [:attribute] [.type]              
        -> greaterOrEqual? [:type] [.type:]                -> greaterOrEqual? [:attributelabel] [.type:]                
        -> greaterOrEqual? [:type] [type\type]             -> greaterOrEqual? [:path] [type\type]
        -> greaterOrEqual? [:type] [type\type:]            -> greaterOrEqual? [:pathLabel] [type\type:]            
        -> greaterOrEqual? [:type] [+]                     -> greaterOrEqual? [:symbol] [+]                     
        -> greaterOrEqual? :type {/:type/}                 -> greaterOrEqual? :regex {/:type/}                  
        -> greaterOrEqual? :type to :binary 1.0            -> greaterOrEqual? :binary to :binary 1.0            
        -> greaterOrEqual? [:type] [(:type)]               -> greaterOrEqual? [:inline] [(:type)]               
        -> greaterOrEqual? :type [:type]                   -> greaterOrEqual? :block [:type]                    
        -> greaterOrEqual? :type 1..1                      -> greaterOrEqual? :range 1..1                       
        -> greaterOrEqual? :type #[type: :type]            -> greaterOrEqual? :dictionary #[type: :type]        
        -> greaterOrEqual? :type #black                    -> greaterOrEqual? :color #black                     
        -> greaterOrEqual? :type var 'type?                -> greaterOrEqual? :function var 'one?
    ] => not? passed
    
    ; for :char
    ensure -> every? @[
        -> greaterOrEqual? '1' 1.0          
        -> greaterOrEqual? '1' to :rational [1 1]      -> greaterOrEqual? 'ø' null                    
        -> greaterOrEqual? 't' true                    -> greaterOrEqual? 'f' false                   
        -> greaterOrEqual? '1' to :complex [1.0 1.0]   -> greaterOrEqual? 'T' :floating
        -> greaterOrEqual? ['a'] [one]                 -> greaterOrEqual? 'a' 'A                      
        -> greaterOrEqual? ['a'] [.1]                  -> greaterOrEqual? ['a'] [.a:]                 
        -> greaterOrEqual? ['a'] [a\a]                 -> greaterOrEqual? ['a'] [a\a:]                
        -> greaterOrEqual? ['+'] [+]                   -> greaterOrEqual? 'a' {/a/}                   
        -> greaterOrEqual? '1' to :binary 1            -> greaterOrEqual? 'a' to :binary 1            
        -> greaterOrEqual? ['1'] [('1')]               -> greaterOrEqual? 'a' ['a']                   
        -> greaterOrEqual? '1' 1..1                    -> greaterOrEqual? 'a' #[a: 'a']               
        -> greaterOrEqual? '1' #black                  -> greaterOrEqual? 'a' var 'char?
    ] => not? passed
    
    ; for :string
    ensure -> every? @[
        -> greaterOrEqual? "1" 1                               -> greaterOrEqual? "1/1" to :rational [1 1]          
        -> greaterOrEqual? "1.0" 1.0                           -> greaterOrEqual? "null" null                    
        -> greaterOrEqual? "" null                             -> greaterOrEqual? "true" true                  
        -> greaterOrEqual? "" false                            -> greaterOrEqual? "false" false                   
        -> greaterOrEqual? "1.0+1.0i" to :complex [1.0 1.0]    -> greaterOrEqual? "type" :floating
        -> greaterOrEqual? "floating" :floating                -> greaterOrEqual? ":floating" :floating
        -> greaterOrEqual? "1.0" :floating                     -> greaterOrEqual? ["a"] [a\a]
        -> greaterOrEqual? ["a"] [a\a:]                        -> greaterOrEqual? ["+"] [+]                         
        -> greaterOrEqual? "a" {/a/}                           -> greaterOrEqual? "01" to :binary 1                 
        -> greaterOrEqual? "1" to :binary 1                    -> greaterOrEqual? [""] [("")]                       
        -> greaterOrEqual? "" [""]                             -> greaterOrEqual? "1" 1..1                          
        -> greaterOrEqual? "a" #[a: "a"]                       -> greaterOrEqual? "#000000" #black                  
        -> greaterOrEqual? "000000" #black                     -> greaterOrEqual? "" var 'char?
    ] => not? passed
    
    ; for :word
    ensure -> every? @[        
        -> greaterOrEqual? [rational] @[to :rational [1 1]]      -> greaterOrEqual? [null]  @[null]                    
        -> greaterOrEqual? [true]     @[true]                    -> greaterOrEqual? [false] @[false]                   
        -> greaterOrEqual? [complex]  @[to :complex [1.0 1.0]]   -> greaterOrEqual? [type]  @[:floating]  
        -> greaterOrEqual? [floating] @[:floating]               -> greaterOrEqual? [a]      [a\a]                   
        -> greaterOrEqual? [a]         [a\a:]                    -> greaterOrEqual? [a]     @[{/a/}]                      
        -> greaterOrEqual? [binary]   @[to :binary 1]            -> greaterOrEqual? [one]   @[to :binary 1]              
        -> greaterOrEqual? [word]      [(word)]                  -> greaterOrEqual? [word]  @[[word]]                      
        -> greaterOrEqual? [range]    @[range 1 1]               -> greaterOrEqual? [a]     @[#[a: 'a']]               
        -> greaterOrEqual? [black]    @[#black ]                 -> greaterOrEqual? [word]  @[var 'word?]              
        -> greaterOrEqual? [var]      @[var 'word?]
    ] => not? passed
    
    ; for :label
    ensure -> every? @[
        -> greaterOrEqual? [rational:] @[to :rational [1 1]]     -> greaterOrEqual? [null:]     @[null]                                                        
        -> greaterOrEqual? [true:]     @[true]                   -> greaterOrEqual? [false:]    @[false]                   
        -> greaterOrEqual? [complex:]  @[to :complex [1.0 1.0]]  -> greaterOrEqual? [floating:] @[:floating]
        -> greaterOrEqual? [type:]     @[:floating]              -> greaterOrEqual? [a:]         [a\a]                     
        -> greaterOrEqual? [a:]         [a\a:]                   -> greaterOrEqual? [a:]        @[{/a:/}]                 
        -> greaterOrEqual? [binary:]   @[to :binary 1]           -> greaterOrEqual? [word:]      [(word:)]                
        -> greaterOrEqual? [label:]    @[[label:]]               -> greaterOrEqual? [a:]        @[#[a: 'a']]               
        -> greaterOrEqual? [black:]    @[#black ]                -> greaterOrEqual? [var:]      @[var 'word?]
        -> greaterOrEqual? [word:]     @[var 'word?]
    ] => not? passed
    
    ; for :literal
    ; NOTE: technically, '+ is not a :literal, but a :symbolLiteral type ;)
    ensure -> every? @[
        -> greaterOrEqual? 'integer  1                   -> greaterOrEqual? 'floating 1.0
        -> greaterOrEqual? 'rational to :rational [1 1]  -> greaterOrEqual? 'one      to :rational [1 1]
        -> greaterOrEqual? 'null     null                -> greaterOrEqual? 'true     true    
        -> greaterOrEqual? 'false    false               -> greaterOrEqual? 'complex  to :complex [1.0 1.0]    
        -> greaterOrEqual? 'type     :floating           -> greaterOrEqual? 'floating :floating               
        -> greaterOrEqual? ['a]        [a\a]             -> greaterOrEqual? ['+]      [+]                       
        -> greaterOrEqual? 'a        {/a/}               -> greaterOrEqual? 'binary   to :binary 1            
        -> greaterOrEqual? ['word]   [('word)]           -> greaterOrEqual? 'word     ['word]                                     
        -> greaterOrEqual? 'range    1..1                -> greaterOrEqual? 'a        #[a: 'a]                
        -> greaterOrEqual? 'black    #black              -> greaterOrEqual? 'word?    var 'word?              
        -> greaterOrEqual? 'var      var 'var
    ] => not? passed
    
    ; for :attribute
    ensure -> every? @[           
        -> greaterOrEqual? [.rational] @[to :rational [1 1]]    -> greaterOrEqual? [.null]     @[null]                  
        -> greaterOrEqual? [.true]     @[true]                  -> greaterOrEqual? [.false]    @[false]                 
        -> greaterOrEqual? [.complex]  @[to :complex [1.0 1.0]] -> greaterOrEqual? [.floating] @[:floating]                          
        -> greaterOrEqual? [.a]        @[{/a:/}]                -> greaterOrEqual? [.binary]   @[to :binary 1]          
        -> greaterOrEqual? [.word]      [(.word:)]              -> greaterOrEqual? [.label]    @[[.label]]                               
        -> greaterOrEqual? [.a]        @[#[a: 'a']]             -> greaterOrEqual? [.black]    @[#black]                
        -> greaterOrEqual? [.var]      @[var 'word?]            -> greaterOrEqual? [.word]     @[var 'word?]
    ] => not? passed
    
    ; for :attributelabel
    ensure -> every? @[           
        -> greaterOrEqual? [.rational:] @[to :rational [1 1]]    -> greaterOrEqual? [.null:]     @[null]                  
        -> greaterOrEqual? [.true:]     @[true]                  -> greaterOrEqual? [.false:]    @[false]                 
        -> greaterOrEqual? [.complex:]  @[to :complex [1.0 1.0]] -> greaterOrEqual? [.floating:] @[:floating]             
        -> greaterOrEqual? [.a:]         [a\a]                   -> greaterOrEqual? [.a: 'a']     [a\a: 'a']              
        -> greaterOrEqual? [.plus:]      [+]                     -> greaterOrEqual? [.a:]        @[{/a:/}]                
        -> greaterOrEqual? [.binary:]   @[to :binary 1]          -> greaterOrEqual? [.word:]      [(.word:)]               
        -> greaterOrEqual? [.label:]    @[[label:]]              -> greaterOrEqual? [.a:]        @[#[a: 'a']]             
        -> greaterOrEqual? [.black:]    @[#black]                -> greaterOrEqual? [.var:]      @[var 'word?]            
        -> greaterOrEqual? [.word:]     @[var 'word?]
    ] => not? passed
    
    ; for :path & :pathLabel
    ensure -> every? @[
        -> greaterOrEqual? [a\b:] [a\b]
        -> greaterOrEqual? [a\b] [a\b:]
    ] => not? passed

    ; for :regex
    ensure -> every? @[
        -> greaterOrEqual? {/1/} 1                               -> greaterOrEqual? {/1/1/} to :rational [1 1]          
        -> greaterOrEqual? {/1.0/} 1.0                           -> greaterOrEqual? {/null/} null                    
        -> greaterOrEqual? {//} null                             -> greaterOrEqual? {/true/} true                  
        -> greaterOrEqual? {//} false                            -> greaterOrEqual? {/false/} false                   
        -> greaterOrEqual? {/1.0+1.0i/} to :complex [1.0 1.0]    -> greaterOrEqual? {/type/} :floating
        -> greaterOrEqual? {/floating/} :floating                -> greaterOrEqual? {/:floating/} :floating
        -> greaterOrEqual? {/1.0/} :floating                     -> greaterOrEqual? [{/a/}] [a\a]
        -> greaterOrEqual? [{/a/}] [a\a:]
        -> greaterOrEqual? [{/\+/}] [+]                          -> greaterOrEqual? {/01/} to :binary 1                 
        -> greaterOrEqual? {/1/} to :binary 1                    -> greaterOrEqual? [{//}] [({//})]                     
        -> greaterOrEqual? {//} [""]                             -> greaterOrEqual? {/1/} 1..1                          
        -> greaterOrEqual? {/a/} #[a: "a"]                       -> greaterOrEqual? {/#000000/} #black                  
        -> greaterOrEqual? {/000000/} #black                     -> greaterOrEqual? {/var/} var 'regex?
        -> greaterOrEqual? {/regex?/} var 'regex?
    ] => not? passed
    
    ; for :binary
    ensure -> every? @[
        -> greaterOrEqual? to :binary 1 1                    -> greaterOrEqual? to :binary 1 1.0                
        -> greaterOrEqual? to :binary 1 to :rational [1 1]   -> greaterOrEqual? to :binary 1 1`usd                
        -> greaterOrEqual? to :binary 1 1`m                  -> greaterOrEqual? to :binary 1 1`m3                 
        -> greaterOrEqual? to :binary 1 1`c                  -> greaterOrEqual? to :binary 0 null                 
        -> greaterOrEqual? to :binary 0 true                 -> greaterOrEqual? to :binary 0 false                
        -> greaterOrEqual? to :binary 0 maybe                -> greaterOrEqual? to :binary 1 to :complex [1 1]                  
        -> greaterOrEqual? to :binary 1 1.0.0                -> greaterOrEqual? to :binary 1 :type              
        -> greaterOrEqual? to :binary 1 :binary              -> greaterOrEqual? to :binary 1 '1'                  
        -> greaterOrEqual? to :binary "a" 'a'                -> greaterOrEqual? to :binary 1 "01"                 
        -> greaterOrEqual? to :binary 1 "1"                  -> greaterOrEqual? @[to :binary 1] [binary]          
        -> greaterOrEqual? @[to :binary 1] [one]             -> greaterOrEqual? @[to :binary 1] [binary:]         
        -> greaterOrEqual? @[to :binary 1][.binary]          -> greaterOrEqual? @[to :binary 1] [.binary:]        
        -> greaterOrEqual? to :binary 1 {/01/}               -> greaterOrEqual? to :binary 1    {/1/}
    ] => not? passed
    
    ; for :range
    ensure -> every? @[
        -> greaterOrEqual? 1..1 1                        -> greaterOrEqual? 1..1 1.0
        -> greaterOrEqual? 1..1 a: to :rational [1 1]    -> greaterOrEqual? 1..1 1`usd
        -> greaterOrEqual? 1..1 1`m                      -> greaterOrEqual? 1..1 1`m3  
        -> greaterOrEqual? 1..1 1`c                      -> greaterOrEqual? 0..0 null 
        -> greaterOrEqual? 0..0 true                     -> greaterOrEqual? 0..0 false
        -> greaterOrEqual? 0..0 maybe                    -> greaterOrEqual? 1..1 to :complex [1 1]
        -> greaterOrEqual? 1..1 1.0.0                    -> greaterOrEqual? 1..1 :type                        
        -> greaterOrEqual? 1..1 :range                   -> greaterOrEqual? 1..1 '1' 
        -> greaterOrEqual? 1..1 "1"                      -> greaterOrEqual? 1..1 'range  
        -> greaterOrEqual? 1..1 {/1/}
    ] => not? passed
    
    ; for :dictionary, :object & :date
    define :person [name surname]
    
    a: to :person ["Walter" "Pinkman"]
    b: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    
    ensure -> every? @[
        -> greaterOrEqual? #[name: "Walter" surname: "Pinkman"] a
        -> greaterOrEqual? a #[name: "Walter" surname: "Pinkman"]
        -> greaterOrEqual? #[year: 2023 day: 15 Month: "January"] b
        -> greaterOrEqual? b #[year: 2023 day: 15 Month: "January"]
    ] => not? passed
    
    ; for :color
    ensure -> every? @[
        -> greaterOrEqual? #black 0                  -> greaterOrEqual? #black 0.0
        -> greaterOrEqual? #black to :rational [1 1] -> greaterOrEqual? #black 0`usd 
        -> greaterOrEqual? #black 0`m                -> greaterOrEqual? #black 0`m3
        -> greaterOrEqual? #black 0`c                -> greaterOrEqual? #black null 
        -> greaterOrEqual? #black true               -> greaterOrEqual? #black false 
        -> greaterOrEqual? #black maybe              -> greaterOrEqual? #black to :complex [0 0]
        -> greaterOrEqual? #black 0.0.0              -> greaterOrEqual? #black :color
        -> greaterOrEqual? #black '1'                -> greaterOrEqual? #black "#000000"
        -> greaterOrEqual? #black "000000"           -> greaterOrEqual? [#black] [black] 
        -> greaterOrEqual? #black 'black             -> greaterOrEqual? [#black] [.black]
        -> greaterOrEqual? [#black] [.black:]        -> greaterOrEqual? #black  {/#000000/}                 
        -> greaterOrEqual? #black{/000000/} 
    ] => not? passed
    
    ; for :function
    ensure -> every? @[
        -> greaterOrEqual? var 'null?     null       -> greaterOrEqual? var 'true?    true  
        -> greaterOrEqual? var 'false?    false 
        -> greaterOrEqual? var 'version?  1.0.0      -> greaterOrEqual? var 'type?    :type 
        -> greaterOrEqual? var 'function? :function  -> greaterOrEqual? var 'char?    'a' 
        -> greaterOrEqual? @[var 'word?]  [word]     -> greaterOrEqual? @[var 'word?] [var]      
        -> greaterOrEqual? @[var 'word?]  [var:]     -> greaterOrEqual? @[var 'word?] [word:]    
        -> greaterOrEqual? var 'word?     'word?     -> greaterOrEqual? var 'var      'var       
        -> greaterOrEqual? @[var 'word?]  [.var]     -> greaterOrEqual? @[var 'word?] [.word]    
        -> greaterOrEqual? @[var 'word?]  [.var:]    -> greaterOrEqual? @[var 'word?] [.word:]   
        -> greaterOrEqual? var 'regex?    {/var/}    -> greaterOrEqual? var 'regex?   {/regex?/} 
    ] => not? passed
    
    
]


topic « less?
do [
    
    
    topic « less? - :integer :floating :rational
    
    ensure -> less? 1 2
    ensure -> less? 1 2.0
    ensure -> less? 1 to :rational @[2 1]
    ensure -> 1 < 2
    ensure -> 1 < 2.0
    ensure -> 1 < to :rational @[2 1]
    passed
    
    ensure -> not? less? 1 1
    ensure -> not? less? 1 1.0
    ensure -> not? less? 1 to :rational @[1 1]
    ensure -> not? 1 < 1
    ensure -> not? 1 < 1.0
    ensure -> not? 1 < to :rational @[1 1]
    passed
    
    ensure -> not? less? 2 1
    ensure -> not? less? 2 1.0
    ensure -> not? less? 2 to :rational @[1 1]
    ensure -> not? 2 < 1
    ensure -> not? 2 < 1.0
    ensure -> not? 2 < :rational @[1 1]
    passed
    
    
    ensure -> less? 1.0 2
    ensure -> less? 1.0 2.0
    ensure -> less? 1.0 to :rational @[2 1]
    ensure -> 1.0 < 2
    ensure -> 1.0 < 2.0
    ensure -> 1.0 < to :rational @[2 1]
    passed
    
    ensure -> not? less? 1.0 1
    ensure -> not? less? 1.0 1.0
    ensure -> not? less? 1.0 to :rational @[1 1]
    ensure -> not? 1.0 < 1
    ensure -> not? 1.0 < 1.0
    ensure -> not? 1.0 < to :rational @[1 1]
    passed
    
    ensure -> not? less? 2.0 1
    ensure -> not? less? 2.0 1.0
    ensure -> not? less? 2.0 to :rational @[1 1]
    ensure -> not? 2.0 < 1
    ensure -> not? 2.0 < 1.0
    ensure -> not? 2.0 < :rational @[1 1]
    passed
    
    
    ensure -> less? to :rational @[1 1] 2
    ensure -> less? to :rational @[1 1] 2.0
    ensure -> less? to :rational @[1 1] to :rational @[2 1]
    ensure -> (to :rational @[1 1]) < 2
    ensure -> (to :rational @[1 1]) < 2.0
    ensure -> (to :rational @[1 1]) < to :rational @[2 1]
    passed
    
    ensure -> not? less? to :rational @[1 1] 1
    ensure -> not? less? to :rational @[1 1] 1.0
    ensure -> not? less? to :rational @[1 1] to :rational @[1 1]
    ensure -> not? (to :rational @[1 1]) < 1
    ensure -> not? (to :rational @[1 1]) < 1.0
    ensure -> not? (to :rational @[1 1]) < to :rational @[1 1]
    passed
    
    ensure -> not? less? to :rational @[2 1] 1
    ensure -> not? less? to :rational @[2 1] 1.0
    ensure -> not? less? to :rational @[2 1] to :rational @[1 1]
    ensure -> not? (to :rational @[2 1]) < 1
    ensure -> not? (to :rational @[2 1]) < 1.0
    ensure -> not? (to :rational @[2 1]) < :rational @[1 1]
    passed
    
    
    topic « less? - :quantity
    
    ; equal to
    
    ensure -> not? less? 1`usd 1
    ensure -> not? less? 1`m   1
    ensure -> not? less? 1`m2  1
    ensure -> not? less? 1`m3  1
    ensure -> not? less? 1`c   1
    ensure -> not? less? 1`f   1
    ensure -> not? less? 1 1`usd
    ensure -> not? less? 1 1`m
    ensure -> not? less? 1 1`m2
    ensure -> not? less? 1 1`m3
    ensure -> not? less? 1 1`c
    ensure -> not? less? 1 1`f
    passed
    
    ensure -> not? less? 1`usd 1.0
    ensure -> not? less? 1`m   1.0
    ensure -> not? less? 1`m2  1.0
    ensure -> not? less? 1`m3  1.0
    ensure -> not? less? 1`c   1.0
    ensure -> not? less? 1`f   1.0
    ensure -> not? less? 1.0 1`usd
    ensure -> not? less? 1.0 1`m
    ensure -> not? less? 1.0 1`m2
    ensure -> not? less? 1.0 1`m3
    ensure -> not? less? 1.0 1`c
    ensure -> not? less? 1.0 1`f
    passed
    
    ensure -> not? less? 1`usd to :rational @[5 5]
    ensure -> not? less? 1`m   to :rational @[5 5]
    ensure -> not? less? 1`m2  to :rational @[5 5]
    ensure -> not? less? 1`m3  to :rational @[5 5]
    ensure -> not? less? 1`c   to :rational @[5 5]
    ensure -> not? less? 1`f   to :rational @[5 5] 
    ensure -> not? less? to :rational @[5 5] 1`usd
    ensure -> not? less? to :rational @[5 5] 1`m
    ensure -> not? less? to :rational @[5 5] 1`m2
    ensure -> not? less? to :rational @[5 5] 1`m3
    ensure -> not? less? to :rational @[5 5] 1`c
    ensure -> not? less? to :rational @[5 5] 1`f
    passed
    
    
    ; less than
    
    ensure -> less? 1`usd 2
    ensure -> less? 1`m   2
    ensure -> less? 1`m2  2
    ensure -> less? 1`m3  2
    ensure -> less? 1`c   2
    ensure -> less? 1`f   2
    ensure -> less? 1 2`usd
    ensure -> less? 1 2`m
    ensure -> less? 1 2`m2
    ensure -> less? 1 2`m3
    ensure -> less? 1 2`c
    ensure -> less? 1 2`f
    passed
    
    ensure -> less? 1`usd 2.0
    ensure -> less? 1`m   2.0
    ensure -> less? 1`m2  2.0
    ensure -> less? 1`m3  2.0
    ensure -> less? 1`c   2.0
    ensure -> less? 1`f   2.0
    ensure -> less? 1.0 2`usd
    ensure -> less? 1.0 2`m
    ensure -> less? 1.0 2`m2
    ensure -> less? 1.0 2`m3
    ensure -> less? 1.0 2`c
    ensure -> less? 1.0 2`f
    passed
    
    ensure -> less? 1`usd to :rational @[2 1]
    ensure -> less? 1`m   to :rational @[2 1]
    ensure -> less? 1`m2  to :rational @[2 1]
    ensure -> less? 1`m3  to :rational @[2 1]
    ensure -> less? 1`c   to :rational @[2 1]
    ensure -> less? 1`f   to :rational @[2 1] 
    ensure -> less? to :rational @[1 1] 2`usd
    ensure -> less? to :rational @[1 1] 2`m
    ensure -> less? to :rational @[1 1] 2`m2
    ensure -> less? to :rational @[1 1] 2`m3
    ensure -> less? to :rational @[1 1] 2`c
    ensure -> less? to :rational @[1 1] 2`f
    passed
    
    
    ; greater than
    
    ensure -> not? less? 2`usd 1
    ensure -> not? less? 2`m   1
    ensure -> not? less? 2`m2  1
    ensure -> not? less? 2`m3  1
    ensure -> not? less? 2`c   1
    ensure -> not? less? 2`f   1
    ensure -> not? less? 2 1`usd
    ensure -> not? less? 2 1`m
    ensure -> not? less? 2 1`m2
    ensure -> not? less? 2 1`m3
    ensure -> not? less? 2 1`c
    ensure -> not? less? 2 1`f
    passed
    
    ensure -> not? less? 2`usd 1.0
    ensure -> not? less? 2`m   1.0
    ensure -> not? less? 2`m2  1.0
    ensure -> not? less? 2`m3  1.0
    ensure -> not? less? 2`c   1.0
    ensure -> not? less? 2`f   1.0
    ensure -> not? less? 2.0 1`usd
    ensure -> not? less? 2.0 1`m
    ensure -> not? less? 2.0 1`m2
    ensure -> not? less? 2.0 1`m3
    ensure -> not? less? 2.0 1`c
    ensure -> not? less? 2.0 1`f
    passed
    
    ensure -> not? less? 2`usd to :rational @[5 5]
    ensure -> not? less? 2`m   to :rational @[5 5]
    ensure -> not? less? 2`m2  to :rational @[5 5]
    ensure -> not? less? 2`m3  to :rational @[5 5]
    ensure -> not? less? 2`c   to :rational @[5 5]
    ensure -> not? less? 2`f   to :rational @[5 5] 
    ensure -> not? less? to :rational @[2 1] 1`usd
    ensure -> not? less? to :rational @[2 1] 1`m
    ensure -> not? less? to :rational @[2 1] 1`m2
    ensure -> not? less? to :rational @[2 1] 1`m3
    ensure -> not? less? to :rational @[2 1] 1`c
    ensure -> not? less? to :rational @[2 1] 1`f
    passed
    
    
    ensure -> not? less? 1.5`m 150`cm 
    ensure -> not? less? 2`m 2`cm
    passed 
    
    
    topic « less? - :null
    ; always returns `false`
    
    ensure -> not? less? null null
    ensure -> not? less? null ø
    ensure -> not? less? ø ø
    ensure -> not? less? ø null
    ensure -> not? null < null
    ensure -> not? null < ø
    ensure -> not? ø < ø
    ensure -> not? ø < null
    passed
    
    ensure -> not? less? ø 1
    ensure -> not? less? ø 1.0
    ensure -> not? less? ø "ø"
    ensure -> not? less? ø 'ø'
    ensure -> not? ø < 1
    ensure -> not? ø < 1.0
    ensure -> not? ø < "ø"
    ensure -> not? ø < 'ø'
    passed
    
    
    topic « less? - :logical
    ; always returns `false`
    
    ensure -> not? less? true true
    ensure -> not? less? true (1 > 0)
    ensure -> not? true < true
    ensure -> not? true < (1 > 0)
    passed
    
    ensure -> not? less? true maybe
    ensure -> not? less? true false
    ensure -> not? true < maybe
    ensure -> not? true < false
    passed
    
    
    topic « less? - :complex
    
    ; less
    ensure -> less? to :complex [0 2] to :complex [1 2] 
    ensure -> less? to :complex [1 1] to :complex [1 2]
    ensure -> (to :complex [0 2]) < (to :complex [1 2]) 
    ensure -> (to :complex [1 1]) < (to :complex [1 2])
    passed
    
    ; equal to
    ensure -> not? less? to :complex [1 2] to :complex [1 2] 
    ensure -> not? (to :complex [1 2]) < (to :complex [1 2]) 
    passed
    
    ; less than
    ensure -> not? less? to :complex [2 2] to :complex [1 2]
    ensure -> not? less? to :complex [1 3] to :complex [1 2]
    ensure -> not? (to :complex [2 2]) < (to :complex [1 2])
    ensure -> not? (to :complex [1 3]) < (to :complex [1 2])
    passed
    
    
    topic « less? - :version
    
    ensure -> less? 1.2.2 1.2.3
    ensure -> 1.2.2 < 1.2.3
    passed
    
    ensure -> not? less? 1.2.3 1.2.3
    ensure -> not? 1.2.3 < 1.2.3
    passed
    
    ensure -> not? less? 1.2.3 1.2.3-pre
    ensure -> not? less? 1.2.3 1.2.3-dev
    ensure -> not? less? 1.2.3-release 1.2.3-dev
    ensure -> not? 1.2.3 < 1.2.3-pre
    ensure -> not? 1.2.3 < 1.2.3-dev
    ensure -> not? 1.2.3-release < 1.2.3-dev
    passed
    
    
    topic « less? - :type
    ; always returns `false`
    
    ensure -> not? less? :char :char
    ensure -> not? less? :string type "a"
    ensure -> not? less? :integer type 1
    ensure -> not? less? :floating type 1.5
    passed
    
    ensure -> not? less? :char :string
    ensure -> not? less? :integer :string
    ensure -> not? less? :floating :integer   
    ensure -> not? less? :string :integer
    ensure -> not? less? :string :char
    ensure -> not? less? :integer :floating
    passed
    
    topic « less? - :char
    
    ensure -> not? less? 'a' 'a'
    ensure -> not? 'a' < 'a'
    passed
    
    ensure -> 'a' < 'b'
    ensure -> 'a' < 'z'
    passed
    
    ensure -> not? less? 'a' "a" 
    ensure -> not? less? '1' 1
    ensure -> not? less? "a" 'a' 
    ensure -> not? less? 'b' 'a'
    ensure -> not? less? 1   '1'
    ensure -> not? 'a' < "a" 
    ensure -> not? '1' <  1
    ensure -> not? "a" < 'a' 
    ensure -> not? 'b' < 'a'
    ensure -> not?  1  < '1'
    passed 
    
    
    topic « less? - :string
    
    ensure -> not? less? "Art" "Arturo" -- "uro"
    ensure -> not? "Art" < "Arturo" -- "uro"
    passed
    
    ensure -> less? "A" "B"
    ensure -> less? "Art" "Bob"
    ensure -> less? "Art" "Artu"
    passed
    
    ensure -> not? less? "a" 'b'
    ensure -> not? less? "a" 'b
    ensure -> not? less? "a" to :word "b"
    ensure -> not? less? "a" to :label "b"
    ensure -> not? less? "a" to :attribute "b"
    ensure -> not? less? "a" to :attributelabel "b"
    ensure -> not? less? "a" to :type "b"
    passed
    
    
    topic « less? - :word
    
    ensure -> less? to :word "a" to :word "b"
    ensure -> not? less? to :word "a" to :word "a"
    ensure -> not? less? to :word "b" to :word "a"
    passed
    
    ensure -> not? less? to :word "a" "b"
    ensure -> not? less? to :word "a" 'b'
    ensure -> not? less? to :word "a" 'b
    ensure -> not? less? to :word "a" to :label "b"
    ensure -> not? less? to :word "a" to :attribute "b"
    ensure -> not? less? to :word "a" to :attributelabel "b"
    ensure -> not? less? to :word "word" to :type "z"
    passed
    
    
    topic « less? - :label
    
    ensure -> less? to :label "a" to :label "b"
    ensure -> not? less? to :label "a" to :label "a"
    ensure -> not? less? to :label "b" to :label "b"
    ensure -> not? less? to :label "b" to :label "a"
    passed
    
    ensure -> not? less? to :label "a" "b"
    ensure -> not? less? to :label "a" 'b'
    ensure -> not? less? to :label "a" 'b
    ensure -> not? less? to :label "a" to :word "b"
    ensure -> not? less? to :label "a" to :attribute "b"
    ensure -> not? less? to :label "a" to :attributelabel "b"
    ensure -> not? less? to :label "a" to :type "b"
    passed
    
    
    topic « less? - :literal
    
    ensure -> less? 'a 'b
    ensure -> not? less? 'b 'a
    ensure -> not? less? 'a 'a
    ensure -> not? less? 'b 'b
    passed
    
    ensure -> not? less? 'a "b"
    ensure -> not? less? 'a 'b'
    ensure -> not? less? 'a to :word "b"
    ensure -> not? less? 'a to :label "b"
    ensure -> not? less? 'a to :attribute "b"
    ensure -> not? less? 'a to :attributelabel "b"
    ensure -> not? less? 'a to :type "b"
    passed
    
    
    topic « less? - :path
    
    a: #[name: "John", surname: "Doe"]
    b: @["Joe" "Jane" "Jesse"]
    
    ensure -> not? less? a\name "John" 
    ensure -> not? less? a\surname "Doe" 
    ensure -> not? less? a\name "Jane" 
    ensure -> not? less? a\name 1
    passed
    
    ensure -> less? a\name "Kennedy" 
    ensure -> less? a\surname "Moe" 
    ensure -> less? a\name "Payne" 
    ensure -> less? b\2 "Walter" 
    passed
    
    ensure -> not? less? b\0 "Joe" 
    ensure -> not? less? b\1 "Jane" 
    ensure -> not? less? b\2 "Jesse" 
    passed
    
    ensure -> not? less? [b\0] [b\1]
    ensure -> not? less? [a\name] [a\surname]
    passed
    
    
    topic « less? - :pathLabel
       
    ensure -> not? less? [a\name: "John"]   [a\name: "John"]
    ensure -> not? less? [a\surname: "Doe"] [b\surname: "Doe" ]
    ensure -> not? less? [a\name: "John"]   [b\name: "Jane"]
    ensure -> not? less? [a\name: "John"]   [b\name: "John"]
    passed
    
    topic « less? - :attribute
    
    ensure -> less? to :attribute "a" to :attribute "b"
    ensure -> not? less? to :attribute "a" to :attribute "a"
    ensure -> not? less? to :attribute "b" to :attribute "b"
    ensure -> not? less? to :attribute "b" to :attribute "a"
    passed
    
    ensure -> not? less? to :attribute "a" "b"
    ensure -> not? less? to :attribute "a" 'b'
    ensure -> not? less? to :attribute "a" 'b
    ensure -> not? less? to :attribute "a" to :word "b"
    ensure -> not? less? to :attribute "a" to :label "b"
    ensure -> not? less? to :attribute "a" to :attributelabel "b"
    ensure -> not? less? to :attribute "a" to :type "b"
    passed
    
    
    topic « less? - :attributelabel
    
    ensure -> less? to :attributelabel "a" to :attributelabel "b"
    ensure -> not? less? to :attributelabel "a" to :attributelabel "a"
    ensure -> not? less? to :attributelabel "b" to :attributelabel "b"
    ensure -> not? less? to :attributelabel "b" to :attributelabel "a"
    passed
    
    ensure -> not? less? to :attributelabel "a" "b"
    ensure -> not? less? to :attributelabel "a" 'b'
    ensure -> not? less? to :attributelabel "a" 'b
    ensure -> not? less? to :attributelabel "a" to :word "b"
    ensure -> not? less? to :attributelabel "a" to :label "b"
    ensure -> not? less? to :attributelabel "a" to :attribute "b"
    ensure -> not? less? to :attributelabel "a" to :type "b"
    passed
    
    
    topic « less? - :symbol
    
    ensure -> not? less? to :symbol "+" to :symbol "+"
    ensure -> not? less? to :symbol "+" to :symbol "-"
    ensure -> not? less? to :symbol "+" to :symbol "++"
    ensure -> not? less? to :symbol "+" '+'
    ensure -> not? less? to :symbol "+" {+}
    ensure -> not? less? to :symbol "+" "+"
    ensure -> not? less? to :symbol "+" to :word "plus"
    ensure -> not? less? to :symbol "+" '+
    passed
    
    
    topic « less? - :regex
    
    ensure -> regex? {/[A-Z]/}
    ensure -> not? less? {/[A-Z]/} {/[A-Z]/} 
    ensure -> not? less? {/[A-Z]/} {/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/}
    ensure -> not? less? {/[A-Z]/} {[A-Z]}
    ensure -> not? less? {/[A-Z]/} "/[A-Z]/"
    passed
    
    
    topic « less? - :binary
    
    ensure -> not? less? 
        to :binary "Arturo"
        to :binary "Hello world"
    ensure -> not? less? to :binary 1 to :binary 0
    ensure -> not? less? to :binary 1 to :binary 1
    ensure -> not? less? to :binary 1 to :binary 10
    ensure -> not? less? to :binary 1 to :binary 5
    passed
    
    
    topic « less? - :bytecode
    
    x: to :bytecode [["print"][1 112 155]]
    
    ensure -> not? less? x to :bytecode [["print"][1 112 155]]
    ensure -> not? less? x to :bytecode [["print"][2 112 155]]
    ensure -> not? less? x [["print"][2 112 155]]
    passed
    
    
    topic « less? - :inline
    
    ensure -> not? less? [(2 + 2)] [(2 + 2)]
    ensure -> not? less? [(2 3 4 5)] [(2 3 4 5)]
    passed
    
    ensure -> not? less? [(2 + 2)] [(2 + 1)]
    ensure -> not? less? [(2 3 4 5)] [(2 1 4 5)]
    passed

    ; note: should compare the lenght
    ; ensure -> less? [(2)] [(2 + 1)]
    ; ensure -> less? [(2 3 4)] [(2 1 4 5)]
    ; passed
    

    topic « less? - :block
    
    a: [1 + 1]
    ensure -> not? less? a [1 + 1]
    ensure -> less? [1] [1 1]
    ensure -> not? less? a [2]
    ensure -> not? less? a 2
    ensure -> not? less? a [1 ++ 1]
    ensure -> not? less? [2] [1]
    ensure -> not? less? [1] [2]
    passed
    
    
    topic « less? - :range
    
    ensure -> not? less? [0 1 2 3 4 5] @0..5
    ensure -> not? less? [0 2 4] @0.. .step: 2 5
    ensure -> not? less? @range.step: 2 0 5 @range.step: 2 0 4
    ensure -> not? less? range.step: 2 0 5 range.step: 2 0 4
    passed
    
    
    topic « less? - :dictionary
    
    a: #[name: "Walter" surname: "Pinkman"]
    
    ensure -> not? less? a #[name: "Walter" surname: "Pinkman"]
    ensure -> not? less? a #[name: "Jesse" surname: "Pinkman"]
    ensure -> not? less? a #[name "Jesse" surname "Pinkman"]
    ensure -> not? less? a [name "Jesse" surname "Pinkman"]
    passed

    
    topic « less? - :object
    
    define :person [  
        init: method [name, age][
            this\name: capitalize name
            this\age: age
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|"
        ]
    ]
    
    define :student is :person [  
        init: method [name, age, id][
            this\name: capitalize name
            this\age: age
            this\id: id
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
        ]
    ]
    
    a: to :person ["Joe" 32]
    ensure -> not? less? a to :person ["Joe" 32]
    ensure -> not? less? to :person ["Joe" 32] #[name: "Joe" age: 32]
    ensure -> not? less? to :person ["Joe" 32] to :student ["Joe" 32 15]
    passed
    
    a\name: "Jane"
    ensure -> not? less? a to :person ["Jane" 32]
    passed
    
   define :person [  
        init: method [name, age][
            this\name: capitalize name
            this\age: age
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|"
        ]
        compare: method [that][
            if this\age > that\age -> return 1
            if this\age = that\age -> return 0
            if this\age < that\age -> return neg 1
        ]   
    ]
    
    define :student is :person [  
        init: method [name, age, id][
            this\name: capitalize name
            this\age: age
            this\id: id
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
        ]
    ]
    
    a: to :person ["John" 16]
    b: to :student ["Jane" 16 100]
    c: to :person ["John" 15]
    d: to :student ["Jane" 16 100]
    ensure -> not? less? a b
    ensure -> not? less? b a
    ensure -> less? c d
    ensure -> not? less? d c
    passed
    
    
    topic « less? - :store
    
    a: store "test.db"
    a\name: "John" a\surname: "Doe"
    b: store "test.db"
    b\name: "John" b\surname: "Doe"
    c: store "test2.db"
    c\name: "John" c\surname: "Doe"
    d: store "test3.db"
    d\name: "Jane" d\surname: "Doe"
    
    ensure -> not? less? a a
    ensure -> not? less? a b
    ensure -> not? less? b a
    passed
    
    ensure -> not? less? a c 
    ensure -> not? less? c a 
    ensure -> not? less? a d 
    ensure -> not? less? d a 
    ensure -> not? less? c d 
    ensure -> not? less? d c 
    passed
    
    
    topic « less? - :color
    
    ensure -> not? less? #000 #black
    ensure -> not? less? #fff #white
    ensure -> not? less? #white #white
    ensure -> not? less? #black #white
    ensure -> not? less? #white #black
    passed
    
    
    topic « less? - :function
    
    ensure -> not? less? var 'print var 'print
    ensure -> not? less? var 'inspect var 'print
    passed
    
    a: $[name surname][]
    A: $[name][]
    b: $[name][]
    c: $[name surname][]
    
    ensure -> not? less? (var 'a) ($[name surname][])
    ensure -> not? less? (var 'a) (var 'c)
    ensure -> not? less? (var 'a) (var 'A)
    ensure -> not? less? (var 'a) (var 'b)
    passed
    

    topic « less? - :database
    ; note: implement this test


    topic « less? - :date
    
    a: to :date .format: "MMM dd" "Jan 15"
    b: to :date .format: "MMM dd" "Jan 15"
    c: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    d: to :date .format: "MMM dd" "Jan 14"
    e: now
    
    ensure -> less? d a
    ensure -> less? a e
    ensure -> less? a c 
    passed
    
    ensure -> not? less? a b
    ensure -> not? less? a d
    passed 
    
    topic « less? - :unit
    
    ensure -> not? less? `USD `USD
    ensure -> not? less? `EUR `EUR
    ensure -> not? less? `USD `EUR
    ensure -> not? less? `EUR `USD
    ensure -> not? `USD < `USD
    ensure -> not? `EUR < `EUR
    ensure -> not? `EUR < `USD
    passed
    
    
    topic « less? - incompatible types
    
    ; NOTES: 
    ; - to avoid repetition some tests may be not explicitly included
    ; - this test part tries to cover the most of possible behaviors,
    ;     including the possility of the Comparison module be rewritten, 
    ;     avoiding future broken changes
    ; - some combinations were not made, because it's considered very
    ;     improbable to happen, even with a future rewrite of 
    ;     the Comparison module
    
    ; for :integer
    
    ensure -> not? every? @[
        -> less? 1 2
        -> less? [a] [a a]
    ] => not?
    
    ensure -> every? @[
        -> less? 1 null          -> less? 1 true
        -> less? 1 false         -> less? 1 to :complex [1 1]
        -> less? 1 1.0.0         -> less? 1 :integer
        -> less? 1 '1'           -> less? 1 "1"
        -> less? [1] [one]       -> less? [1] [one:]
        -> less? 1 '1            -> less? [1] [.1]         
        -> less? [1] [.1:]       -> less? [1] [one\1]
        -> less? [1] [one\1:]    -> less? [1] [+]          
        -> less? 1 {/1/}         -> less? 1 to :binary 1   
        -> less? 1 to :binary 1  -> less? [1] [(1)]        
        -> less? 1 [1]           -> less? 1 1..1           
        -> less? 1 #[one: 1]     -> less? 0 #black         
        -> less? 1 var 'one?
    ] => not? passed
    
    ; for :floating
    ensure -> every? @[
        -> less? 1.0 null            -> less? 1.0 true
        -> less? 1.0 false           -> less? 1.0 to :complex [1.0 1.0]
        -> less? 1.0 1.0.0           -> less? 1.0 :floating
        -> less? 1.0 '1'             -> less? 1.0 "1.0"
        -> less? [1.0] [one]         -> less? [1.0] [one:]
        -> less? 1.0 '1.0i           -> less? [1.0] [.1]            
        -> less? [1.0] [.1:]         -> less? [1.0] [one\1]
        -> less? [1.0] [one\1:]      -> less? [1.0] [+]           
        -> less? 1.0 {/1.0/}         -> less? 1.0 to :binary 1.0  
        -> less? 1.0 to :binary 1.0  -> less? [1.0] [(1.0)]       
        -> less? 1.0 [1]             -> less? 1.0 1..1            
        -> less? 1.0 #[one: 1.0]     -> less? 0.0 #black          
        -> less? 1.0 var 'one?
    ] => not? passed
    
    ; for :rational
    a: to :rational [1 1]
    ensure -> every? @[
        -> less? a null          -> less? a true
        -> less? a false         -> less? a to :complex [1 1]
        -> less? a 1.0.0         -> less? a :rational
        -> less? a '1'           -> less? a "1/1"
        -> less? @[a] [one]      -> less? @[a] [one:]
        -> less? 1 '1            -> less? @[a] [.1]                 
        -> less? @[a] [.1:]      -> less? @[a] [one\1]
        -> less? @[a] [one\1:]   -> less? @[a] [+]                  
        -> less? a {/1/1/}       -> less? a to :binary 1            
        -> less? a to :binary 1  -> less? @[a] [(1)]                
        -> less? a [1]           -> less? a 1..1                    
        -> less? a #[one: 1]     -> less? to :rational [1 1] #black    
        -> less? a var 'one?
    ] => not? passed
    
    ; for :quantity
    ensure -> every? @[
        -> less? 1`usd null          -> less? 1`usd true
        -> less? 1`usd false         -> less? 1`usd to :complex [1 1]
        -> less? 1`usd 1.0.0         -> less? 1`usd :quantity
        -> less? 1`usd '1'           -> less? 1`usd "1USD"
        -> less? [1`usd] [one]       -> less? [1`usd] [one:]
        -> less? 1`usd '1.0i         -> less? [1`usd] [.1]                  
        -> less? [1`usd] [.1:]       -> less? [1`usd] [one\1]
        -> less? [1`usd] [one\1:]    -> less? [1`usd] [+]         
        -> less? 1`usd {/1USD/}      -> less? 1`usd to :binary 1  
        -> less? 1`usd to :binary 1  -> less? [1`usd] [(1)]       
        -> less? 1`usd [1`usd]       -> less? 1`usd 1..1          
        -> less? 1`usd #[one: 1`usd] -> less? 0`usd #black        
        -> less? 1`usd var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> less? 1`m null            -> less? 1`m true
        -> less? 1`m false           -> less? 1`m to :complex [1 1]
        -> less? 1`m 1.0.0           -> less? 1`m :quantity
        -> less? 1`m '1'             -> less? 1`m "1m"
        -> less? [1`m] [one]         -> less? [1`m] [one:]
        -> less? 1`m '1              -> less? [1`m] [.1]            
        -> less? [1`m] [.1:]         -> less? [1`m] [one\1]
        -> less? [1`m] [one\1:]      -> less? [1`m] [+]             
        -> less? 1`m {/1m/}          -> less? 1`m to :binary 1      
        -> less? 1`m to :binary 1    -> less? [1`m] [(1)]           
        -> less? 1`m [1`m]           -> less? 1`m 1..1              
        -> less? 1`m #[one: 1`m]     -> less? 0`m #black            
        -> less? 1`m var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> less? 1`m3 null           -> less? 1`m3 true
        -> less? 1`m3 false          -> less? 1`m3 to :complex [1 1]
        -> less? 1`m3 1.0.0          -> less? 1`m3 :quantity
        -> less? 1`m3 '1'            -> less? 1`m3 "1m³"
        -> less? [1`m3] [one]        -> less? [1`m3] [one:]
        -> less? 1`m3 '1             -> less? [1`m3] [.1]              
        -> less? [1`m3] [.1:]        -> less? [1`m3] [one\1]
        -> less? [1`m3] [one\1:]     -> less? [1`m3] [+]                
        -> less? 1`m3 {/1m³/}        -> less? 1`m3 to :binary 1         
        -> less? 1`m3 to :binary 1   -> less? [1`m3] [(1)]              
        -> less? 1`m3 [1`m3]         -> less? 1`m3 1..1                 
        -> less? 1`m3 #[one: 1`m3]   -> less? 0`m3 #black               
        -> less? 1`m3 var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> less? 1`c null            -> less? 1`c true
        -> less? 1`c false           -> less? 1`c to :complex [1 1]
        -> less? 1`c 1.0.0           -> less? 1`c :quantity
        -> less? 1`c '1'             -> less? 1`c "1°C"
        -> less? [1`c] [one]         -> less? [1`c] [one:]
        -> less? 1`c '1.0i           -> less? [1`c] [.1]            
        -> less? [1`c] [.1:]         -> less? [1`c] [one\1]       
        -> less? [1`c] [one\1:]      -> less? [1`c] [+]           
        -> less? 1`c {/1°C/}         -> less? 1`c to :binary 1    
        -> less? 1`c to :binary 1    -> less? [1`c] [(1)]         
        -> less? 1`c [1`c]           -> less? 1`c 1..1            
        -> less? 1`c #[one: 1`c]     -> less? 0`c #black          
        -> less? 1`c var 'one?
    ] => not? passed
    
    ; for :null
    ensure -> every? @[
        -> less? null 0                  -> less? null 0.0            
        -> less? null to :rational [1 1] -> less? null true
        -> less? null false              -> less? null to :complex [0 0]
        -> less? null 0.0.0              -> less? null :null
        -> less? null 'ø'                -> less? null "null"
        -> less? @[null] [null]          -> less? @[null] [null:]
        -> less? null 'null              -> less? @[null] [.null]               
        -> less? @[null] [.null:]        -> less? @[null] [null\null]
        -> less? @[null] [null\null:]    -> less? @[null] [ø]                   
        -> less? null {/null/}           -> less? null {/ø/}                    
        -> less? null to :binary 0       -> less? null to :binary 0             
        -> less? @[null] [(null)]        -> less? null [null]                   
        -> less? null 0..0               -> less? null #[null: null]            
        -> less? null #black          
        -> less? null var 'null?
    ] => not? passed
    
    ; for :logical
    ensure -> every? @[
        -> less? true 0                  -> less? true 0.0            
        -> less? true to :rational [1 1] -> less? true to :complex [0 0]
        -> less? true 0.0.0              -> less? true :true
        -> less? true '0'                -> less? true "true"
        -> less? @[true] [true]          -> less? @[true] [true:]
        -> less? true 'true              -> less? @[true] [.true]               
        -> less? @[true] [.true:]        -> less? @[true] [true\true]
        -> less? @[true] [true\true:]    -> less? @[true] [ø]                   
        -> less? true {/true/}           -> less? true to :binary 0             
        -> less? true to :binary 0       -> less? @[true] [(true)]              
        -> less? true [true]             -> less? true 0..0                     
        -> less? true #[true: true]      -> less? true #black                   
        -> less? true var 'true?
    ] => not? passed
    
    ensure -> every? @[
        -> less? false 0                     -> less? false 0.0            
        -> less? false to :rational [1 1]    -> less? false to :complex [0 0]
        -> less? false 0.0.0                 -> less? false :false
        -> less? false '0'                   -> less? false "false"
        -> less? @[false] [false]            -> less? @[false] [false:]
        -> less? false 'false                -> less? @[false] [.false]                 
        -> less? @[false] [.false:]          -> less? @[false] [false\false]
        -> less? @[false] [false\false:]     -> less? @[false] [ø]                      
        -> less? false {/false/}             -> less? false to :binary 0                
        -> less? false to :binary 0          -> less? @[false] [(false)]                
        -> less? false [false]               -> less? false 0..0                        
        -> less? false #[false: false]       -> less? false #black                      
        -> less? false var 'false?
    ] => not? passed
    
    ensure -> every? @[
        -> less? maybe 0                     -> less? maybe 0.0            
        -> less? maybe to :rational [1 1]    -> less? maybe to :complex [0 0]
        -> less? maybe 0.0.0                 -> less? maybe :maybe
        -> less? maybe '0'                   -> less? maybe "maybe"
        -> less? @[maybe] [maybe]            -> less? @[maybe] [maybe:]
        -> less? maybe 'maybe                -> less? @[maybe] [.maybe]                 
        -> less? @[maybe] [.maybe:]          -> less? @[maybe] [maybe\maybe]
        -> less? @[maybe] [maybe\maybe:]     -> less? @[maybe] [ø]                      
        -> less? maybe {/maybe/}             -> less? maybe to :binary 0                
        -> less? maybe to :binary 0A         -> less? @[maybe] [(maybe)]                
        -> less? maybe [maybe]               -> less? maybe 0..0                        
        -> less? maybe #[maybe: maybe]       -> less? maybe #black                      
    ] => not? passed
    
    ; for :complex
    a: to :complex [1 1]
    ensure -> every? @[
        -> less? a 1                     -> less? a 1.0            
        -> less? a to :rational [1 1]    -> less? a null                    
        -> less? a true                  -> less? a false
        -> less? a 1.0.0                 -> less? a :rational
        -> less? a '1'                   -> less? a "1.0+1.0i"
        -> less? @[a] [one]              -> less? @[a] [one:]
        -> less? 1 '1                    -> less? @[a] [.1]                 
        -> less? @[a] [.1:]              -> less? @[a] [one\1]
        -> less? @[a] [one\1:]           -> less? @[a] [+]                  
        -> less? a {/1.0+1.0i/}          -> less? a to :binary 1            
        -> less? a to :binary 1          -> less? @[a] [(1)]                
        -> less? a [1]                   -> less? a 1..1                    
        -> less? a #[one: 1]             -> less? to :complex [0 0] #black  
        -> less? a var 'one?
    ] => not? passed
    
    ; for :version
    ensure -> every? @[
        -> less? 1.0.0 1                     -> less? 1.0.0 1.0          
        -> less? 1.0.0 to :rational [1 1]    -> less? 1.0.0 null                    
        -> less? 1.0.0 true                  -> less? 1.0.0 false                   
        -> less? 1.0.0 to :complex [1.0 1.0] -> less? 1.0.0 :floating
        -> less? 1.0.0 '1'                   -> less? 1.0.0 "1.0.0"
        -> less? [1.0.0] [one]               -> less? [1.0.0] [one:]
        -> less? 1.0.0 '1                    -> less? [1.0.0] [.1]                  
        -> less? [1.0.0] [.1:]               -> less? [1.0.0] [one\1]
        -> less? [1.0.0] [one\1:]            -> less? [1.0.0] [+]                   
        -> less? 1.0.0 {/1.0.0/}             -> less? 1.0.0 to :binary 1.0          
        -> less? 1.0.0 to :binary 1.0        -> less? [1.0.0] [(1.0.0)]             
        -> less? 1.0.0 [1.0.0]               -> less? 1.0.0 1..1                    
        -> less? 1.0.0 #[one: 1.0.0]         -> less? 0.0.0 #black                  
        -> less? 1.0.0 var 'version?
    ] => not? passed
    
    ; for :type
    ensure -> every? @[
        -> less? :1 1                            -> less? :1 1.0          
        -> less? :integer 1                      -> less? :floating 1.0          
        -> less? :rational to :rational [1 1]    -> less? :null null                    
        -> less? :true true                      -> less? :false false                   
        -> less? :logical false                  -> less? :complex to :complex [1 1]   
        -> less? :version 1.0.0                  -> less? :T 'T'                         
        -> less? :char 'T'                       -> less? :string ":type"
        -> less? [:type] [type]                  -> less? [:word] [word]                     
        -> less? [:type] [type:]                 -> less? [:label] [label:]
        -> less? :1 '1.                          -> less? :literal '1                       
        -> less? [:type] [.type]                 -> less? [:attribute] [.type]              
        -> less? [:type] [.type:]                -> less? [:attributelabel] [.type:]                
        -> less? [:type] [type\type]             -> less? [:path] [type\type]
        -> less? [:type] [type\type:]            -> less? [:pathLabel] [type\type:]            
        -> less? [:type] [+]                     -> less? [:symbol] [+]                     
        -> less? :type {/:type/}                 -> less? :regex {/:type/}                  
        -> less? :type to :binary 1.0            -> less? :binary to :binary 1.0            
        -> less? [:type] [(:type)]               -> less? [:inline] [(:type)]               
        -> less? :type [:type]                   -> less? :block [:type]                    
        -> less? :type 1..1                      -> less? :range 1..1                       
        -> less? :type #[type: :type]            -> less? :dictionary #[type: :type]        
        -> less? :type #black                    -> less? :color #black                     
        -> less? :type var 'type?                -> less? :function var 'one?
    ] => not? passed
    
    ; for :char
    ensure -> every? @[
        -> less? '1' 1.0          
        -> less? '1' to :rational [1 1]      -> less? 'ø' null                    
        -> less? 't' true                    -> less? 'f' false                   
        -> less? '1' to :complex [1.0 1.0]   -> less? 'T' :floating
        -> less? ['a'] [one]                 -> less? 'a' 'A                      
        -> less? ['a'] [.1]                  -> less? ['a'] [.a:]                 
        -> less? ['a'] [a\a]                 -> less? ['a'] [a\a:]                
        -> less? ['+'] [+]                   -> less? 'a' {/a/}                   
        -> less? '1' to :binary 1            -> less? 'a' to :binary 1            
        -> less? ['1'] [('1')]               -> less? 'a' ['a']                   
        -> less? '1' 1..1                    -> less? 'a' #[a: 'a']               
        -> less? '1' #black                  -> less? 'a' var 'char?
    ] => not? passed
    
    ; for :string
    ensure -> every? @[
        -> less? "1" 1                               -> less? "1/1" to :rational [1 1]          
        -> less? "1.0" 1.0                           -> less? "null" null                    
        -> less? "" null                             -> less? "true" true                  
        -> less? "" false                            -> less? "false" false                   
        -> less? "1.0+1.0i" to :complex [1.0 1.0]    -> less? "type" :floating
        -> less? "floating" :floating                -> less? ":floating" :floating
        -> less? "1.0" :floating                     -> less? ["a"] [a\a]
        -> less? ["a"] [a\a:]                        -> less? ["+"] [+]                         
        -> less? "a" {/a/}                           -> less? "01" to :binary 1                 
        -> less? "1" to :binary 1                    -> less? [""] [("")]                       
        -> less? "" [""]                             -> less? "1" 1..1                          
        -> less? "a" #[a: "a"]                       -> less? "#000000" #black                  
        -> less? "000000" #black                     -> less? "" var 'char?
    ] => not? passed
    
    ; for :word
    ensure -> every? @[        
        -> less? [rational] @[to :rational [1 1]]      -> less? [null]  @[null]                    
        -> less? [true]     @[true]                    -> less? [false] @[false]                   
        -> less? [complex]  @[to :complex [1.0 1.0]]   -> less? [type]  @[:floating]  
        -> less? [floating] @[:floating]               -> less? [a]      [a\a]                   
        -> less? [a]         [a\a:]                    -> less? [a]     @[{/a/}]                      
        -> less? [binary]   @[to :binary 1]            -> less? [one]   @[to :binary 1]              
        -> less? [word]      [(word)]                  -> less? [word]  @[[word]]                      
        -> less? [range]    @[range 1 1]               -> less? [a]     @[#[a: 'a']]               
        -> less? [black]    @[#black ]                 -> less? [word]  @[var 'word?]              
        -> less? [var]      @[var 'word?]
    ] => not? passed
    
    ; for :label
    ensure -> every? @[
        -> less? [rational:] @[to :rational [1 1]]     -> less? [null:]     @[null]                                                        
        -> less? [true:]     @[true]                   -> less? [false:]    @[false]                   
        -> less? [complex:]  @[to :complex [1.0 1.0]]  -> less? [floating:] @[:floating]
        -> less? [type:]     @[:floating]              -> less? [a:]         [a\a]                     
        -> less? [a:]         [a\a:]                   -> less? [a:]        @[{/a:/}]                 
        -> less? [binary:]   @[to :binary 1]           -> less? [word:]      [(word:)]                
        -> less? [label:]    @[[label:]]               -> less? [a:]        @[#[a: 'a']]               
        -> less? [black:]    @[#black ]                -> less? [var:]      @[var 'word?]
        -> less? [word:]     @[var 'word?]
    ] => not? passed
    
    ; for :literal
    ; NOTE: technically, '+ is not a :literal, but a :symbolLiteral type ;)
    ensure -> every? @[
        -> less? 'integer  1                   -> less? 'floating 1.0
        -> less? 'rational to :rational [1 1]  -> less? 'one      to :rational [1 1]
        -> less? 'null     null                -> less? 'true     true    
        -> less? 'false    false               -> less? 'complex  to :complex [1.0 1.0]    
        -> less? 'type     :floating           -> less? 'floating :floating               
        -> less? ['a]        [a\a]             -> less? ['+]      [+]                       
        -> less? 'a        {/a/}               -> less? 'binary   to :binary 1            
        -> less? ['word]   [('word)]           -> less? 'word     ['word]                                     
        -> less? 'range    1..1                -> less? 'a        #[a: 'a]                
        -> less? 'black    #black              -> less? 'word?    var 'word?              
        -> less? 'var      var 'var
    ] => not? passed
    
    ; for :attribute
    ensure -> every? @[           
        -> less? [.rational] @[to :rational [1 1]]    -> less? [.null]     @[null]                  
        -> less? [.true]     @[true]                  -> less? [.false]    @[false]                 
        -> less? [.complex]  @[to :complex [1.0 1.0]] -> less? [.floating] @[:floating]                          
        -> less? [.a]        @[{/a:/}]                -> less? [.binary]   @[to :binary 1]          
        -> less? [.word]      [(.word:)]              -> less? [.label]    @[[.label]]                               
        -> less? [.a]        @[#[a: 'a']]             -> less? [.black]    @[#black]                
        -> less? [.var]      @[var 'word?]            -> less? [.word]     @[var 'word?]
    ] => not? passed
    
    ; for :attributelabel
    ensure -> every? @[           
        -> less? [.rational:] @[to :rational [1 1]]    -> less? [.null:]     @[null]                  
        -> less? [.true:]     @[true]                  -> less? [.false:]    @[false]                 
        -> less? [.complex:]  @[to :complex [1.0 1.0]] -> less? [.floating:] @[:floating]             
        -> less? [.a:]         [a\a]                   -> less? [.a: 'a']     [a\a: 'a']              
        -> less? [.plus:]      [+]                     -> less? [.a:]        @[{/a:/}]                
        -> less? [.binary:]   @[to :binary 1]          -> less? [.word:]      [(.word:)]               
        -> less? [.label:]    @[[label:]]              -> less? [.a:]        @[#[a: 'a']]             
        -> less? [.black:]    @[#black]                -> less? [.var:]      @[var 'word?]            
        -> less? [.word:]     @[var 'word?]
    ] => not? passed
    
    ; for :path & :pathLabel
    ensure -> every? @[
        -> less? [a\b:] [a\b]
        -> less? [a\b] [a\b:]
    ] => not? passed

    ; for :regex
    ensure -> every? @[
        -> less? {/1/} 1                            -> less? {/1/1/} to :rational [1 1]          
        -> less? {/1.0/} 1.0                        -> less? {/null/} null                    
        -> less? {//} null                          -> less? {/true/} true                  
        -> less? {//} false                         -> less? {/false/} false                   
        -> less? {/1.0+1.0i/} to :complex [1.0 1.0] -> less? {/type/} :floating
        -> less? {/floating/} :floating             -> less? {/:floating/} :floating
        -> less? {/1.0/} :floating                  -> less? [{/a/}] [a\a]
        -> less? [{/a/}] [a\a:]                     -> less? [{/\+/}] [+]                          
        -> less? {/01/} to :binary 1                -> less? {/1/} to :binary 1                    
        -> less? [{//}] [({//})]                    -> less? {//} [""]                             
        -> less? {/1/} 1..1                         -> less? {/a/} #[a: "a"]                       
        -> less? {/#000000/} #black                 -> less? {/000000/} #black                     
        -> less? {/var/} var 'regex?                -> less? {/regex?/} var 'regex?
    ] => not? passed
    
    ; for :binary
    ensure -> every? @[
        -> less? to :binary 1 1                    -> less? to :binary 1 1.0                
        -> less? to :binary 1 to :rational [1 1]   -> less? to :binary 1 1`usd                
        -> less? to :binary 1 1`m                  -> less? to :binary 1 1`m3                 
        -> less? to :binary 1 1`c                  -> less? to :binary 0 null                 
        -> less? to :binary 0 true                 -> less? to :binary 0 false                
        -> less? to :binary 0 maybe                -> less? to :binary 1 to :complex [1 1]                  
        -> less? to :binary 1 1.0.0                -> less? to :binary 1 :type              
        -> less? to :binary 1 :binary              -> less? to :binary 1 '1'                  
        -> less? to :binary "a" 'a'                -> less? to :binary 1 "01"                 
        -> less? to :binary 1 "1"                  -> less? @[to :binary 1] [binary]          
        -> less? @[to :binary 1] [one]             -> less? @[to :binary 1] [binary:]         
        -> less? @[to :binary 1][.binary]          -> less? @[to :binary 1] [.binary:]        
        -> less? to :binary 1 {/01/}               -> less? to :binary 1    {/1/}
    ] => not? passed
    
    ; for :range
    ensure -> every? @[
        -> less? 1..1 1                        -> less? 1..1 1.0
        -> less? 1..1 a: to :rational [1 1]    -> less? 1..1 1`usd
        -> less? 1..1 1`m                      -> less? 1..1 1`m3  
        -> less? 1..1 1`c                      -> less? 0..0 null 
        -> less? 0..0 true                     -> less? 0..0 false
        -> less? 0..0 maybe                    -> less? 1..1 to :complex [1 1]
        -> less? 1..1 1.0.0                    -> less? 1..1 :type                        
        -> less? 1..1 :range                   -> less? 1..1 '1' 
        -> less? 1..1 "1"                      -> less? 1..1 'range  
        -> less? 1..1 {/1/}
    ] => not? passed
    
    ; for :dictionary, :object & :date
    define :person [name surname]
    
    a: to :person ["Walter" "Pinkman"]
    b: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    
    ensure -> every? @[
        -> less? #[name: "Walter" surname: "Pinkman"] a
        -> less? a #[name: "Walter" surname: "Pinkman"]
        -> less? #[year: 2023 day: 15 Month: "January"] b
        -> less? b #[year: 2023 day: 15 Month: "January"]
    ] => not? passed
    
    ; for :color
    ensure -> every? @[
        -> less? #black 0                  -> less? #black 0.0
        -> less? #black to :rational [1 1] -> less? #black 0`usd 
        -> less? #black 0`m                -> less? #black 0`m3
        -> less? #black 0`c                -> less? #black null 
        -> less? #black true               -> less? #black false 
        -> less? #black maybe              -> less? #black to :complex [0 0]
        -> less? #black 0.0.0              -> less? #black :color
        -> less? #black '1'                -> less? #black "#000000"
        -> less? #black "000000"           -> less? [#black] [black] 
        -> less? #black 'black             -> less? [#black] [.black]
        -> less? [#black] [.black:]        -> less? #black  {/#000000/}                 
        -> less? #black{/000000/} 
    ] => not? passed
    
    ; for :function
    ensure -> every? @[
        -> less? var 'null?     null       -> less? var 'true?    true  
        -> less? var 'false?    false 
        -> less? var 'version?  1.0.0      -> less? var 'type?    :type 
        -> less? var 'function? :function  -> less? var 'char?    'a' 
        -> less? @[var 'word?]  [word]     -> less? @[var 'word?] [var]      
        -> less? @[var 'word?]  [var:]     -> less? @[var 'word?] [word:]    
        -> less? var 'word?     'word?     -> less? var 'var      'var       
        -> less? @[var 'word?]  [.var]     -> less? @[var 'word?] [.word]    
        -> less? @[var 'word?]  [.var:]    -> less? @[var 'word?] [.word:]   
        -> less? var 'regex?    {/var/}    -> less? var 'regex?   {/regex?/} 
    ] => not? passed

    
    
]


topic « lessOrEqual?
do [
    
    
    topic « lessOrEqual? - :integer :floating :rational
    
    ensure -> lessOrEqual? 1 2
    ensure -> lessOrEqual? 1 2.0
    ensure -> lessOrEqual? 1 to :rational @[2 1]
    ensure -> 1 =< 2
    ensure -> 1 =< 2.0
    ensure -> 1 =< to :rational @[2 1]
    passed
    
    ensure -> lessOrEqual? 1 1
    ensure -> lessOrEqual? 1 1.0
    ensure -> lessOrEqual? 1 to :rational @[1 1]
    ensure -> 1 =< 1
    ensure -> 1 =< 1.0
    ensure -> 1 =< to :rational @[1 1]
    passed
    
    ensure -> not? lessOrEqual? 2 1
    ensure -> not? lessOrEqual? 2 1.0
    ensure -> not? lessOrEqual? 2 to :rational @[1 1]
    ensure -> not? 2 =< 1
    ensure -> not? 2 =< 1.0
    ensure -> not? 2 =< :rational @[1 1]
    passed
    
    
    ensure -> lessOrEqual? 1.0 2
    ensure -> lessOrEqual? 1.0 2.0
    ensure -> lessOrEqual? 1.0 to :rational @[2 1]
    ensure -> 1.0 =< 2
    ensure -> 1.0 =< 2.0
    ensure -> 1.0 =< to :rational @[2 1]
    passed
    
    ensure -> lessOrEqual? 1.0 1
    ensure -> lessOrEqual? 1.0 1.0
    ensure -> lessOrEqual? 1.0 to :rational @[1 1]
    ensure -> 1.0 =< 1
    ensure -> 1.0 =< 1.0
    ensure -> 1.0 =< to :rational @[1 1]
    passed
    
    ensure -> not? lessOrEqual? 2.0 1
    ensure -> not? lessOrEqual? 2.0 1.0
    ensure -> not? lessOrEqual? 2.0 to :rational @[1 1]
    ensure -> not? 2.0 =< 1
    ensure -> not? 2.0 =< 1.0
    ensure -> not? 2.0 =< :rational @[1 1]
    passed
    
    
    ensure -> lessOrEqual? to :rational @[1 1] 2
    ensure -> lessOrEqual? to :rational @[1 1] 2.0
    ensure -> lessOrEqual? to :rational @[1 1] to :rational @[2 1]
    ensure -> (to :rational @[1 1]) =< 2
    ensure -> (to :rational @[1 1]) =< 2.0
    ensure -> (to :rational @[1 1]) =< to :rational @[2 1]
    passed
    
    ensure -> lessOrEqual? to :rational @[1 1] 1
    ensure -> lessOrEqual? to :rational @[1 1] 1.0
    ensure -> lessOrEqual? to :rational @[1 1] to :rational @[1 1]
    ensure -> (to :rational @[1 1]) =< 1
    ensure -> (to :rational @[1 1]) =< 1.0
    ensure -> (to :rational @[1 1]) =< to :rational @[1 1]
    passed
    
    ensure -> not? lessOrEqual? to :rational @[2 1] 1
    ensure -> not? lessOrEqual? to :rational @[2 1] 1.0
    ensure -> not? lessOrEqual? to :rational @[2 1] to :rational @[1 1]
    ensure -> not? (to :rational @[2 1]) =< 1
    ensure -> not? (to :rational @[2 1]) =< 1.0
    ensure -> not? (to :rational @[2 1]) =< :rational @[1 1]
    passed
    
    
    topic « lessOrEqual? - :quantity
    
    ; equal to
    
    ensure -> lessOrEqual? 1`usd 1
    ensure -> lessOrEqual? 1`m   1
    ensure -> lessOrEqual? 1`m2  1
    ensure -> lessOrEqual? 1`m3  1
    ensure -> lessOrEqual? 1`c   1
    ensure -> lessOrEqual? 1`f   1
    ensure -> lessOrEqual? 1 1`usd
    ensure -> lessOrEqual? 1 1`m
    ensure -> lessOrEqual? 1 1`m2
    ensure -> lessOrEqual? 1 1`m3
    ensure -> lessOrEqual? 1 1`c
    ensure -> lessOrEqual? 1 1`f
    passed
    
    ensure -> lessOrEqual? 1`usd 1.0
    ensure -> lessOrEqual? 1`m   1.0
    ensure -> lessOrEqual? 1`m2  1.0
    ensure -> lessOrEqual? 1`m3  1.0
    ensure -> lessOrEqual? 1`c   1.0
    ensure -> lessOrEqual? 1`f   1.0
    ensure -> lessOrEqual? 1.0 1`usd
    ensure -> lessOrEqual? 1.0 1`m
    ensure -> lessOrEqual? 1.0 1`m2
    ensure -> lessOrEqual? 1.0 1`m3
    ensure -> lessOrEqual? 1.0 1`c
    ensure -> lessOrEqual? 1.0 1`f
    passed
    
    ensure -> lessOrEqual? 1`usd to :rational @[5 5]
    ensure -> lessOrEqual? 1`m   to :rational @[5 5]
    ensure -> lessOrEqual? 1`m2  to :rational @[5 5]
    ensure -> lessOrEqual? 1`m3  to :rational @[5 5]
    ensure -> lessOrEqual? 1`c   to :rational @[5 5]
    ensure -> lessOrEqual? 1`f   to :rational @[5 5] 
    ensure -> lessOrEqual? to :rational @[5 5] 1`usd
    ensure -> lessOrEqual? to :rational @[5 5] 1`m
    ensure -> lessOrEqual? to :rational @[5 5] 1`m2
    ensure -> lessOrEqual? to :rational @[5 5] 1`m3
    ensure -> lessOrEqual? to :rational @[5 5] 1`c
    ensure -> lessOrEqual? to :rational @[5 5] 1`f
    passed
    
    
    ; less than
    
    ensure -> lessOrEqual? 1`usd 2
    ensure -> lessOrEqual? 1`m   2
    ensure -> lessOrEqual? 1`m2  2
    ensure -> lessOrEqual? 1`m3  2
    ensure -> lessOrEqual? 1`c   2
    ensure -> lessOrEqual? 1`f   2
    ensure -> lessOrEqual? 1 2`usd
    ensure -> lessOrEqual? 1 2`m
    ensure -> lessOrEqual? 1 2`m2
    ensure -> lessOrEqual? 1 2`m3
    ensure -> lessOrEqual? 1 2`c
    ensure -> lessOrEqual? 1 2`f
    passed
    
    ensure -> lessOrEqual? 1`usd 2.0
    ensure -> lessOrEqual? 1`m   2.0
    ensure -> lessOrEqual? 1`m2  2.0
    ensure -> lessOrEqual? 1`m3  2.0
    ensure -> lessOrEqual? 1`c   2.0
    ensure -> lessOrEqual? 1`f   2.0
    ensure -> lessOrEqual? 1.0 2`usd
    ensure -> lessOrEqual? 1.0 2`m
    ensure -> lessOrEqual? 1.0 2`m2
    ensure -> lessOrEqual? 1.0 2`m3
    ensure -> lessOrEqual? 1.0 2`c
    ensure -> lessOrEqual? 1.0 2`f
    passed
    
    ensure -> lessOrEqual? 1`usd to :rational @[2 1]
    ensure -> lessOrEqual? 1`m   to :rational @[2 1]
    ensure -> lessOrEqual? 1`m2  to :rational @[2 1]
    ensure -> lessOrEqual? 1`m3  to :rational @[2 1]
    ensure -> lessOrEqual? 1`c   to :rational @[2 1]
    ensure -> lessOrEqual? 1`f   to :rational @[2 1] 
    ensure -> lessOrEqual? to :rational @[1 1] 2`usd
    ensure -> lessOrEqual? to :rational @[1 1] 2`m
    ensure -> lessOrEqual? to :rational @[1 1] 2`m2
    ensure -> lessOrEqual? to :rational @[1 1] 2`m3
    ensure -> lessOrEqual? to :rational @[1 1] 2`c
    ensure -> lessOrEqual? to :rational @[1 1] 2`f
    passed
    
    
    ; greater than
    
    ensure -> not? lessOrEqual? 2`usd 1
    ensure -> not? lessOrEqual? 2`m   1
    ensure -> not? lessOrEqual? 2`m2  1
    ensure -> not? lessOrEqual? 2`m3  1
    ensure -> not? lessOrEqual? 2`c   1
    ensure -> not? lessOrEqual? 2`f   1
    ensure -> not? lessOrEqual? 2 1`usd
    ensure -> not? lessOrEqual? 2 1`m
    ensure -> not? lessOrEqual? 2 1`m2
    ensure -> not? lessOrEqual? 2 1`m3
    ensure -> not? lessOrEqual? 2 1`c
    ensure -> not? lessOrEqual? 2 1`f
    passed
    
    ensure -> not? lessOrEqual? 2`usd 1.0
    ensure -> not? lessOrEqual? 2`m   1.0
    ensure -> not? lessOrEqual? 2`m2  1.0
    ensure -> not? lessOrEqual? 2`m3  1.0
    ensure -> not? lessOrEqual? 2`c   1.0
    ensure -> not? lessOrEqual? 2`f   1.0
    ensure -> not? lessOrEqual? 2.0 1`usd
    ensure -> not? lessOrEqual? 2.0 1`m
    ensure -> not? lessOrEqual? 2.0 1`m2
    ensure -> not? lessOrEqual? 2.0 1`m3
    ensure -> not? lessOrEqual? 2.0 1`c
    ensure -> not? lessOrEqual? 2.0 1`f
    passed
    
    ensure -> not? lessOrEqual? 2`usd to :rational @[5 5]
    ensure -> not? lessOrEqual? 2`m   to :rational @[5 5]
    ensure -> not? lessOrEqual? 2`m2  to :rational @[5 5]
    ensure -> not? lessOrEqual? 2`m3  to :rational @[5 5]
    ensure -> not? lessOrEqual? 2`c   to :rational @[5 5]
    ensure -> not? lessOrEqual? 2`f   to :rational @[5 5] 
    ensure -> not? lessOrEqual? to :rational @[2 1] 1`usd
    ensure -> not? lessOrEqual? to :rational @[2 1] 1`m
    ensure -> not? lessOrEqual? to :rational @[2 1] 1`m2
    ensure -> not? lessOrEqual? to :rational @[2 1] 1`m3
    ensure -> not? lessOrEqual? to :rational @[2 1] 1`c
    ensure -> not? lessOrEqual? to :rational @[2 1] 1`f
    passed
    
    
    ensure -> lessOrEqual? 1.5`m 150`cm 
    ensure -> not? lessOrEqual? 2`m 2`cm
    passed 
    
    
    topic « lessOrEqual? - :null
    
    ensure -> lessOrEqual? null null
    ensure -> lessOrEqual? null ø
    ensure -> lessOrEqual? ø ø
    ensure -> lessOrEqual? ø null
    ensure -> null =< null
    ensure -> null =< ø
    ensure -> ø =< ø
    ensure -> ø =< null
    passed
    
    ensure -> not? lessOrEqual? ø 1
    ensure -> not? lessOrEqual? ø 1.0
    ensure -> not? lessOrEqual? ø "ø"
    ensure -> not? lessOrEqual? ø 'ø'
    ensure -> not? ø =< 1
    ensure -> not? ø =< 1.0
    ensure -> not? ø =< "ø"
    ensure -> not? ø =< 'ø'
    passed
    
    
    topic « lessOrEqual? - :logical
    
    ensure -> lessOrEqual? true true
    ensure -> lessOrEqual? true (1 > 0)
    ensure -> true =< true
    ensure -> true =< (1 > 0)
    passed
    
    ensure -> not? lessOrEqual? true maybe
    ensure -> not? lessOrEqual? true false
    ensure -> not? true =< maybe
    ensure -> not? true =< false
    passed
    
    
    topic « lessOrEqual? - :complex
    
    ; greater than
    ensure -> lessOrEqual? to :complex [0 2] to :complex [1 2] 
    ensure -> lessOrEqual? to :complex [1 1] to :complex [1 2]
    ensure -> (to :complex [0 2]) =< (to :complex [1 2]) 
    ensure -> (to :complex [1 1]) =< (to :complex [1 2])
    passed
    
    ; equal to
    ensure -> lessOrEqual? to :complex [1 2] to :complex [1 2] 
    ensure -> (to :complex [1 2]) =< (to :complex [1 2]) 
    passed
    
    ; less than
    ensure -> not? lessOrEqual? to :complex [2 2] to :complex [1 2]
    ensure -> not? lessOrEqual? to :complex [1 3] to :complex [1 2]
    ensure -> not? (to :complex [2 2]) =< (to :complex [1 2])
    ensure -> not? (to :complex [1 3]) =< (to :complex [1 2])
    passed
    
    
    topic « lessOrEqual? - :version
    
    ensure -> lessOrEqual? 1.2.2 1.2.3
    ensure -> 1.2.2 =< 1.2.3
    passed
    
    ensure -> lessOrEqual? 1.2.3 1.2.3
    ensure -> 1.2.3 =< 1.2.3
    passed
    
    ensure -> not? lessOrEqual? 1.2.3 1.2.3-pre
    ensure -> not? lessOrEqual? 1.2.3 1.2.3-dev
    ensure -> not? lessOrEqual? 1.2.3-release 1.2.3-dev
    ensure -> not? 1.2.3 =< 1.2.3-pre
    ensure -> not? 1.2.3 =< 1.2.3-dev
    ensure -> not? 1.2.3-release =< 1.2.3-dev
    passed
    
    
    topic « lessOrEqual? - :type
    
    ensure -> lessOrEqual? :char :char
    ensure -> lessOrEqual? :string type "a"
    ensure -> lessOrEqual? :integer type 1
    ensure -> lessOrEqual? :floating type 1.5
    passed
    
    ensure -> not? lessOrEqual? :char :string
    ensure -> not? lessOrEqual? :integer :string
    ensure -> not? lessOrEqual? :floating :integer   
    ensure -> not? lessOrEqual? :string :integer
    ensure -> not? lessOrEqual? :string :char
    ensure -> not? lessOrEqual? :integer :floating
    passed
    
    topic « lessOrEqual? - :char
    
    ensure -> lessOrEqual? 'a' 'a'
    ensure -> 'a' =< 'a'
    passed
    
    ensure -> 'a' =< 'b'
    ensure -> 'a' =< 'z'
    passed
    
    ensure -> not? lessOrEqual? 'a' "a" 
    ensure -> not? lessOrEqual? '1' 1
    ensure -> not? lessOrEqual? "a" 'a' 
    ensure -> not? lessOrEqual? 'b' 'a'
    ensure -> not? lessOrEqual? 1   '1'
    ensure -> not? 'a' =< "a" 
    ensure -> not? '1' =<  1
    ensure -> not? "a" =< 'a' 
    ensure -> not? 'b' =< 'a'
    ensure -> not?  1  =< '1'
    passed 
    
    
    topic « lessOrEqual? - :string
    
    ensure -> lessOrEqual? "Art" "Arturo" -- "uro"
    ensure -> "Art" =< "Arturo" -- "uro"
    passed
    
    ensure -> lessOrEqual? "A" "B"
    ensure -> lessOrEqual? "Art" "Bob"
    ensure -> lessOrEqual? "Art" "Artu"
    passed
    
    ensure -> not? lessOrEqual? "a" 'a'
    ensure -> not? lessOrEqual? "a" 'b'
    ensure -> not? lessOrEqual? "a" 'a
    ensure -> not? lessOrEqual? "a" 'b
    ensure -> not? lessOrEqual? "a" to :word "a"
    ensure -> not? lessOrEqual? "a" to :word "b"
    ensure -> not? lessOrEqual? "a" to :label "a"
    ensure -> not? lessOrEqual? "a" to :label "b"
    ensure -> not? lessOrEqual? "a" to :attribute "a"
    ensure -> not? lessOrEqual? "a" to :attribute "b"
    ensure -> not? lessOrEqual? "a" to :attributelabel "a"
    ensure -> not? lessOrEqual? "a" to :attributelabel "b"
    ensure -> not? lessOrEqual? "a" to :type "a"
    ensure -> not? lessOrEqual? "a" to :type "b"
    passed
    
    
    topic « lessOrEqual? - :word
    
    ensure -> lessOrEqual? to :word "a" to :word "a"
    ensure -> lessOrEqual? to :word "b" to :word "b"
    ensure -> lessOrEqual? to :word "a" to :word "b"
    ensure -> not? lessOrEqual? to :word "b" to :word "a"
    passed
    
    ensure -> not? lessOrEqual? to :word "a" "a"
    ensure -> not? lessOrEqual? to :word "a" "b"
    ensure -> not? lessOrEqual? to :word "a" 'a'
    ensure -> not? lessOrEqual? to :word "a" 'b'
    ensure -> not? lessOrEqual? to :word "a" 'a
    ensure -> not? lessOrEqual? to :word "a" 'b
    ensure -> not? lessOrEqual? to :word "a" to :label "a"
    ensure -> not? lessOrEqual? to :word "a" to :label "b"
    ensure -> not? lessOrEqual? to :word "a" to :attribute "a"
    ensure -> not? lessOrEqual? to :word "a" to :attribute "b"
    ensure -> not? lessOrEqual? to :word "a" to :attributelabel "a"
    ensure -> not? lessOrEqual? to :word "a" to :attributelabel "b"
    ensure -> not? lessOrEqual? to :word "a" to :type "a"
    ensure -> not? lessOrEqual? to :word "a" to :type "b"
    passed
    
    
    topic « lessOrEqual? - :label
    
    ensure -> lessOrEqual? to :label "a" to :label "a"
    ensure -> lessOrEqual? to :label "b" to :label "b"
    ensure -> lessOrEqual? to :label "a" to :label "b"
    ensure -> not? lessOrEqual? to :label "b" to :label "a"
    passed
    
    ensure -> not? lessOrEqual? to :label "a" "a"
    ensure -> not? lessOrEqual? to :label "a" "b"
    ensure -> not? lessOrEqual? to :label "a" 'a'
    ensure -> not? lessOrEqual? to :label "a" 'b'
    ensure -> not? lessOrEqual? to :label "a" 'a
    ensure -> not? lessOrEqual? to :label "a" 'b
    ensure -> not? lessOrEqual? to :label "a" to :word "a"
    ensure -> not? lessOrEqual? to :label "a" to :word "b"
    ensure -> not? lessOrEqual? to :label "a" to :attribute "a"
    ensure -> not? lessOrEqual? to :label "a" to :attribute "b"
    ensure -> not? lessOrEqual? to :label "a" to :attributelabel "a"
    ensure -> not? lessOrEqual? to :label "a" to :attributelabel "b"
    ensure -> not? lessOrEqual? to :label "a" to :type "a"
    ensure -> not? lessOrEqual? to :label "a" to :type "b"
    passed
    
    
    topic « lessOrEqual? - :literal
    
    ensure -> lessOrEqual? 'a 'a
    ensure -> lessOrEqual? 'b 'b
    ensure -> lessOrEqual? 'a 'b
    ensure -> not? lessOrEqual? 'b 'a
    passed
    
    ensure -> not? lessOrEqual? 'a "a"
    ensure -> not? lessOrEqual? 'a "b"
    ensure -> not? lessOrEqual? 'a 'a'
    ensure -> not? lessOrEqual? 'a 'b'
    ensure -> not? lessOrEqual? 'a to :word "a"
    ensure -> not? lessOrEqual? 'a to :word "b"
    ensure -> not? lessOrEqual? 'a to :label "a"
    ensure -> not? lessOrEqual? 'a to :label "b"
    ensure -> not? lessOrEqual? 'a to :attribute "a"
    ensure -> not? lessOrEqual? 'a to :attribute "b"
    ensure -> not? lessOrEqual? 'a to :attributelabel "a"
    ensure -> not? lessOrEqual? 'a to :attributelabel "b"
    ensure -> not? lessOrEqual? 'a to :type "a"
    ensure -> not? lessOrEqual? 'a to :type "b"
    passed
    
    
    topic « lessOrEqual? - :path
    
    a: #[name: "John", surname: "Doe"]
    b: @["Joe" "Jane" "Jesse"]
    
    ensure -> lessOrEqual? a\name "John" 
    ensure -> lessOrEqual? a\surname "Doe" 
    ensure -> not? lessOrEqual? a\name "Jane" 
    ensure -> not? lessOrEqual? a\name 1
    passed
    
    ensure -> lessOrEqual? a\name "Kennedy" 
    ensure -> lessOrEqual? a\surname "Moe" 
    ensure -> lessOrEqual? a\name "Payne" 
    ensure -> lessOrEqual? b\2 "Walter" 
    passed
    
    ensure -> lessOrEqual? b\0 "Joe" 
    ensure -> lessOrEqual? b\1 "Jane" 
    ensure -> lessOrEqual? b\2 "Jesse" 
    passed
    
    ensure -> lessOrEqual? [b\0] [b\0]
    ensure -> lessOrEqual? [a\name] [a\name]
    ensure -> not? lessOrEqual? [b\0] [b\1]
    ensure -> not? lessOrEqual? [a\name] [a\surname]
    passed
    
    
    topic « lessOrEqual? - :pathLabel
       
    ensure -> lessOrEqual? [a\name: "John"]   [a\name: "John"]
    ensure -> not? lessOrEqual? [a\surname: "Doe"] [b\surname: "Doe" ]
    ensure -> not? lessOrEqual? [a\name: "John"]   [b\name: "Jane"]
    ensure -> not? lessOrEqual? [a\name: "John"]   [b\name: "John"]
    passed
    
    
    topic « lessOrEqual? - :attribute
    
    ensure -> lessOrEqual? to :attribute "a" to :attribute "b"
    ensure -> lessOrEqual? to :attribute "a" to :attribute "a"
    ensure -> lessOrEqual? to :attribute "b" to :attribute "b"
    ensure -> not? lessOrEqual? to :attribute "b" to :attribute "a"
    passed
    
    ensure -> not? lessOrEqual? to :attribute "a" "a"
    ensure -> not? lessOrEqual? to :attribute "a" "b"
    ensure -> not? lessOrEqual? to :attribute "a" 'a'
    ensure -> not? lessOrEqual? to :attribute "a" 'b'
    ensure -> not? lessOrEqual? to :attribute "a" 'a
    ensure -> not? lessOrEqual? to :attribute "a" 'b
    ensure -> not? lessOrEqual? to :attribute "a" to :word "a"
    ensure -> not? lessOrEqual? to :attribute "a" to :word "b"
    ensure -> not? lessOrEqual? to :attribute "a" to :label "a"
    ensure -> not? lessOrEqual? to :attribute "a" to :label "b"
    ensure -> not? lessOrEqual? to :attribute "a" to :attributelabel "a"
    ensure -> not? lessOrEqual? to :attribute "a" to :attributelabel "b"
    ensure -> not? lessOrEqual? to :attribute "a" to :type "a"
    ensure -> not? lessOrEqual? to :attribute "a" to :type "b"
    passed
    
    
    topic « lessOrEqual? - :attributelabel
    
    ensure -> lessOrEqual? to :attributelabel "a" to :attributelabel "b"
    ensure -> lessOrEqual? to :attributelabel "a" to :attributelabel "a"
    ensure -> lessOrEqual? to :attributelabel "b" to :attributelabel "b"
    ensure -> not? lessOrEqual? to :attributelabel "b" to :attributelabel "a"
    passed
    
    ensure -> not? lessOrEqual? to :attributelabel "a" "a"
    ensure -> not? lessOrEqual? to :attributelabel "a" "b"
    ensure -> not? lessOrEqual? to :attributelabel "a" 'a'
    ensure -> not? lessOrEqual? to :attributelabel "a" 'b'
    ensure -> not? lessOrEqual? to :attributelabel "a" 'a
    ensure -> not? lessOrEqual? to :attributelabel "a" 'b
    ensure -> not? lessOrEqual? to :attributelabel "a" to :word "a"
    ensure -> not? lessOrEqual? to :attributelabel "a" to :word "b"
    ensure -> not? lessOrEqual? to :attributelabel "a" to :label "a"
    ensure -> not? lessOrEqual? to :attributelabel "a" to :label "b"
    ensure -> not? lessOrEqual? to :attributelabel "a" to :attribute "a"
    ensure -> not? lessOrEqual? to :attributelabel "a" to :attribute "b"
    ensure -> not? lessOrEqual? to :attributelabel "a" to :type "a"
    ensure -> not? lessOrEqual? to :attributelabel "a" to :type "b"
    passed
    
    
    topic « lessOrEqual? - :symbol
    
    ensure -> lessOrEqual? to :symbol "+" to :symbol "+"
    ensure -> not? lessOrEqual? to :symbol "+" to :symbol "-"
    ensure -> not? lessOrEqual? to :symbol "+" to :symbol "++"
    ensure -> not? lessOrEqual? to :symbol "+" '+'
    ensure -> not? lessOrEqual? to :symbol "+" {+}
    ensure -> not? lessOrEqual? to :symbol "+" "+"
    ensure -> not? lessOrEqual? to :symbol "+" to :word "plus"
    ensure -> not? lessOrEqual? to :symbol "+" '+
    passed
    
    
    topic « lessOrEqual? - :regex
    
    ensure -> regex? {/[A-Z]/}
    ensure -> lessOrEqual? {/[A-Z]/} {/[A-Z]/} 
    ensure -> not? lessOrEqual? {/[A-Z]/} {/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/}
    ensure -> not? lessOrEqual? {/[A-Z]/} {[A-Z]}
    ensure -> not? lessOrEqual? {/[A-Z]/} "/[A-Z]/"
    passed
    
    
    topic « lessOrEqual? - :binary
    
    ensure -> not? lessOrEqual? 
        to :binary "Arturo"
        to :binary "Hello world"
    ensure -> not? lessOrEqual? to :binary 1 to :binary 0
    ensure -> lessOrEqual? to :binary 1 to :binary 1
    ensure -> not? lessOrEqual? to :binary 1 to :binary 10
    ensure -> not? lessOrEqual? to :binary 1 to :binary 5
    passed
    
    
    topic « lessOrEqual? - :bytecode
    
    x: to :bytecode [["print"][1 112 155]]
    
    ensure -> lessOrEqual? x to :bytecode [["print"][1 112 155]]
    ensure -> not? lessOrEqual? x to :bytecode [["print"][2 112 155]]
    ensure -> not? lessOrEqual? x [["print"][2 112 155]]
    passed
    
    
    topic « lessOrEqual? - :inline
    
    ensure -> lessOrEqual? [(2 + 2)] [(2 + 2)]
    ensure -> lessOrEqual? [(2 3 4 5)] [(2 3 4 5)]
    passed
    
    ensure -> not? lessOrEqual? [(2 + 2)] [(2 + 1)]
    ensure -> not? lessOrEqual? [(2 3 4 5)] [(2 1 4 5)]
    passed

    ; note: should compare the lenght
    ; ensure -> lessOrEqual? [(2)] [(2 + 1)]
    ; ensure -> lessOrEqual? [(2 3 4)] [(2 1 4 5)]
    ; passed
    
    
    topic « lessOrEqual? - :block
    
    a: [1 + 1]
    ensure -> lessOrEqual? a [1 + 1]
    ensure -> lessOrEqual? [1] [1 1]
    ensure -> not? lessOrEqual? a [2]
    ensure -> not? lessOrEqual? a 2
    ensure -> not? lessOrEqual? a [1 ++ 1]
    ensure -> not? lessOrEqual? [2] [1]
    ensure -> not? lessOrEqual? [1] [2]
    passed
    
    
    topic « lessOrEqual? - :range
    
    ensure -> lessOrEqual? 0..5 0..5
    ensure -> lessOrEqual? [0 1 2 3 4 5] @0..5
    ensure -> lessOrEqual? [0 2 4] @0.. .step: 2 5
    ensure -> lessOrEqual? @range.step: 2 0 5 @range.step: 2 0 4
    ensure -> not? lessOrEqual? range.step: 2 0 5 range.step: 2 0 4
    passed
    
    
    topic « lessOrEqual? - :dictionary
    
    a: #[name: "Walter" surname: "Pinkman"]
    
    ensure -> lessOrEqual? a #[name: "Walter" surname: "Pinkman"]
    ensure -> not? lessOrEqual? a #[name: "Jesse" surname: "Pinkman"]
    ensure -> not? lessOrEqual? a #[name "Jesse" surname "Pinkman"]
    ensure -> not? lessOrEqual? a [name "Jesse" surname "Pinkman"]
    passed
    
    
    topic « lessOrEqual? - :object
    
    define :person [  
        init: method [name, age][
            this\name: capitalize name
            this\age: age
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|"
        ] 
    ]
    
    define :student is :person [  
        init: method [name, age, id][
            this\name: capitalize name
            this\age: age
            this\id: id
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
        ]
    ]
    
    a: to :person ["Joe" 32]
    ensure -> lessOrEqual? a to :person ["Joe" 32]
    ensure -> not? lessOrEqual? to :person ["Joe" 32] #[name: "Joe" age: 32]
    ensure -> not? lessOrEqual? to :person ["Joe" 32] to :student ["Joe" 32 15]
    passed
    
    a\name: "Jane"
    ensure -> lessOrEqual? a to :person ["Jane" 32]
    passed
    
    define :person [  
        init: method [name, age][
            this\name: capitalize name
            this\age: age
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|"
        ]
        compare: method [that][
            if this\age > that\age -> return 1
            if this\age = that\age -> return 0
            if this\age < that\age -> return neg 1
        ]   
    ]
    
    define :student is :person [  
        init: method [name, age, id][
            this\name: capitalize name
            this\age: age
            this\id: id
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
        ]
    ]
    
    a: to :person ["John" 16]
    b: to :student ["Jane" 16 100]
    c: to :person ["John" 15]
    d: to :student ["Jane" 16 100]
    ensure -> lessOrEqual? a b
    ensure -> lessOrEqual? b a
    ensure -> lessOrEqual? c d
    ensure -> not? lessOrEqual? d c
    
    
    topic « lessOrEqual? - :store
    
    a: store "test.db"
    a\name: "John" a\surname: "Doe"
    b: store "test.db"
    b\name: "John" b\surname: "Doe"
    c: store "test2.db"
    c\name: "John" c\surname: "Doe"
    d: store "test3.db"
    d\name: "Jane" d\surname: "Doe"
    
    ensure -> lessOrEqual? a a
    ensure -> lessOrEqual? a b
    ensure -> lessOrEqual? b a
    passed
    
    ensure -> not? lessOrEqual? a c 
    ensure -> not? lessOrEqual? c a 
    ensure -> not? lessOrEqual? a d 
    ensure -> not? lessOrEqual? d a 
    ensure -> not? lessOrEqual? c d 
    ensure -> not? lessOrEqual? d c 
    passed
    
    
    topic « lessOrEqual? - :color
    
    ensure -> lessOrEqual? #000 #black
    ensure -> lessOrEqual? #fff #white
    ensure -> lessOrEqual? #white #white
    ensure -> not? lessOrEqual? #black #white
    ensure -> not? lessOrEqual? #white #black
    passed
    
    
    topic « lessOrEqual? - :function
    
    ensure -> lessOrEqual? var 'print var 'print
    ensure -> not? lessOrEqual? var 'inspect var 'print
    passed
    
    a: $[name surname][]
    A: $[name][]
    b: $[name][]
    c: $[name surname][]
    
    ; note: I commented these, because they return SigSegv
    ; ensure -> lessOrEqual? (var 'a) ($[name surname][])
    ; ensure -> lessOrEqual? (var 'a) (var 'c)
    ensure -> not? lessOrEqual? (var 'a) (var 'A)
    ensure -> not? lessOrEqual? (var 'a) (var 'b)
    passed
    
    
    topic « lessOrEqual? - :database
    ; note: implement this test
    
    
    topic « lessOrEqual? - :date
    
    a: to :date .format: "MMM dd" "Jan 15"
    b: to :date .format: "MMM dd" "Jan 15"
    c: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    d: to :date .format: "MMM dd" "Jan 14"
    e: now
    
    ensure -> lessOrEqual? d a
    ensure -> lessOrEqual? a e
    ensure -> lessOrEqual? a c 
    passed
    
    ensure -> lessOrEqual? a b 
    ensure -> not? lessOrEqual? a d
    passed 
    
    topic « lessOrEqual? - :unit
    
    ensure -> lessOrEqual? `USD `USD
    ensure -> lessOrEqual? `EUR `EUR
    ensure -> `USD =< `USD
    ensure -> `EUR =< `EUR
    passed
    
    ensure -> not? lessOrEqual? `USD `EUR
    ensure -> not? equal? `EUR `USD
    ensure -> not? `EUR =< `USD
    passed
    
    
    topic « lessOrEqual? - incompatible types
    
    ; NOTES: 
    ; - to avoid repetition some tests may be not explicitly included
    ; - this test part tries to cover the most of possible behaviors,
    ;     including the possility of the Comparison module be rewritten, 
    ;     avoiding future broken changes
    ; - some combinations were not made, because it's considered very
    ;     improbable to happen, even with a future rewrite of 
    ;     the Comparison module
    
    ; for :integer
    
    ensure -> not? every? @[
        -> lessOrEqual? 1 1
    ] => not?
    
    ensure -> every? @[
        -> lessOrEqual? 1 null          -> lessOrEqual? 1 true
        -> lessOrEqual? 1 false         -> lessOrEqual? 1 to :complex [1 1]
        -> lessOrEqual? 1 1.0.0         -> lessOrEqual? 1 :integer
        -> lessOrEqual? 1 '1'           -> lessOrEqual? 1 "1"
        -> lessOrEqual? [1] [one]       -> lessOrEqual? [1] [one:]
        -> lessOrEqual? 1 '1            -> lessOrEqual? [1] [.1]         
        -> lessOrEqual? [1] [.1:]       -> lessOrEqual? [1] [one\1]
        -> lessOrEqual? [1] [one\1:]    -> lessOrEqual? [1] [+]          
        -> lessOrEqual? 1 {/1/}         -> lessOrEqual? 1 to :binary 1   
        -> lessOrEqual? 1 to :binary 1  -> lessOrEqual? [1] [(1)]        
        -> lessOrEqual? 1 [1]           -> lessOrEqual? 1 1..1           
        -> lessOrEqual? 1 #[one: 1]     -> lessOrEqual? 0 #black         
        -> lessOrEqual? 1 var 'one?
    ] => not? passed
    
    ; for :floating
    ensure -> every? @[
        -> lessOrEqual? 1.0 null            -> lessOrEqual? 1.0 true
        -> lessOrEqual? 1.0 false           -> lessOrEqual? 1.0 to :complex [1.0 1.0]
        -> lessOrEqual? 1.0 1.0.0           -> lessOrEqual? 1.0 :floating
        -> lessOrEqual? 1.0 '1'             -> lessOrEqual? 1.0 "1.0"
        -> lessOrEqual? [1.0] [one]         -> lessOrEqual? [1.0] [one:]
        -> lessOrEqual? 1.0 '1.0i           -> lessOrEqual? [1.0] [.1]            
        -> lessOrEqual? [1.0] [.1:]         -> lessOrEqual? [1.0] [one\1]
        -> lessOrEqual? [1.0] [one\1:]      -> lessOrEqual? [1.0] [+]           
        -> lessOrEqual? 1.0 {/1.0/}         -> lessOrEqual? 1.0 to :binary 1.0  
        -> lessOrEqual? 1.0 to :binary 1.0  -> lessOrEqual? [1.0] [(1.0)]       
        -> lessOrEqual? 1.0 [1]             -> lessOrEqual? 1.0 1..1            
        -> lessOrEqual? 1.0 #[one: 1.0]     -> lessOrEqual? 0.0 #black          
        -> lessOrEqual? 1.0 var 'one?
    ] => not? passed
    
    ; for :rational
    a: to :rational [1 1]
    ensure -> every? @[
        -> lessOrEqual? a null          -> lessOrEqual? a true
        -> lessOrEqual? a false         -> lessOrEqual? a to :complex [1 1]
        -> lessOrEqual? a 1.0.0         -> lessOrEqual? a :rational
        -> lessOrEqual? a '1'           -> lessOrEqual? a "1/1"
        -> lessOrEqual? @[a] [one]      -> lessOrEqual? @[a] [one:]
        -> lessOrEqual? 1 '1            -> lessOrEqual? @[a] [.1]                 
        -> lessOrEqual? @[a] [.1:]      -> lessOrEqual? @[a] [one\1]
        -> lessOrEqual? @[a] [one\1:]   -> lessOrEqual? @[a] [+]                  
        -> lessOrEqual? a {/1/1/}       -> lessOrEqual? a to :binary 1            
        -> lessOrEqual? a to :binary 1  -> lessOrEqual? @[a] [(1)]                
        -> lessOrEqual? a [1]           -> lessOrEqual? a 1..1                    
        -> lessOrEqual? a #[one: 1]     -> lessOrEqual? to :rational [1 1] #black    
        -> lessOrEqual? a var 'one?
    ] => not? passed
    
    ; for :quantity
    ensure -> every? @[
        -> lessOrEqual? 1`usd null          -> lessOrEqual? 1`usd true
        -> lessOrEqual? 1`usd false         -> lessOrEqual? 1`usd to :complex [1 1]
        -> lessOrEqual? 1`usd 1.0.0         -> lessOrEqual? 1`usd :quantity
        -> lessOrEqual? 1`usd '1'           -> lessOrEqual? 1`usd "1USD"
        -> lessOrEqual? [1`usd] [one]       -> lessOrEqual? [1`usd] [one:]
        -> lessOrEqual? 1`usd '1.0i         -> lessOrEqual? [1`usd] [.1]                  
        -> lessOrEqual? [1`usd] [.1:]       -> lessOrEqual? [1`usd] [one\1]
        -> lessOrEqual? [1`usd] [one\1:]    -> lessOrEqual? [1`usd] [+]         
        -> lessOrEqual? 1`usd {/1USD/}      -> lessOrEqual? 1`usd to :binary 1  
        -> lessOrEqual? 1`usd to :binary 1  -> lessOrEqual? [1`usd] [(1)]       
        -> lessOrEqual? 1`usd [1`usd]       -> lessOrEqual? 1`usd 1..1          
        -> lessOrEqual? 1`usd #[one: 1`usd] -> lessOrEqual? 0`usd #black        
        -> lessOrEqual? 1`usd var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> lessOrEqual? 1`m null            -> lessOrEqual? 1`m true
        -> lessOrEqual? 1`m false           -> lessOrEqual? 1`m to :complex [1 1]
        -> lessOrEqual? 1`m 1.0.0           -> lessOrEqual? 1`m :quantity
        -> lessOrEqual? 1`m '1'             -> lessOrEqual? 1`m "1m"
        -> lessOrEqual? [1`m] [one]         -> lessOrEqual? [1`m] [one:]
        -> lessOrEqual? 1`m '1              -> lessOrEqual? [1`m] [.1]            
        -> lessOrEqual? [1`m] [.1:]         -> lessOrEqual? [1`m] [one\1]
        -> lessOrEqual? [1`m] [one\1:]      -> lessOrEqual? [1`m] [+]             
        -> lessOrEqual? 1`m {/1m/}          -> lessOrEqual? 1`m to :binary 1      
        -> lessOrEqual? 1`m to :binary 1    -> lessOrEqual? [1`m] [(1)]           
        -> lessOrEqual? 1`m [1`m]           -> lessOrEqual? 1`m 1..1              
        -> lessOrEqual? 1`m #[one: 1`m]     -> lessOrEqual? 0`m #black            
        -> lessOrEqual? 1`m var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> lessOrEqual? 1`m3 null           -> lessOrEqual? 1`m3 true
        -> lessOrEqual? 1`m3 false          -> lessOrEqual? 1`m3 to :complex [1 1]
        -> lessOrEqual? 1`m3 1.0.0          -> lessOrEqual? 1`m3 :quantity
        -> lessOrEqual? 1`m3 '1'            -> lessOrEqual? 1`m3 "1m³"
        -> lessOrEqual? [1`m3] [one]        -> lessOrEqual? [1`m3] [one:]
        -> lessOrEqual? 1`m3 '1             -> lessOrEqual? [1`m3] [.1]              
        -> lessOrEqual? [1`m3] [.1:]        -> lessOrEqual? [1`m3] [one\1]
        -> lessOrEqual? [1`m3] [one\1:]     -> lessOrEqual? [1`m3] [+]                
        -> lessOrEqual? 1`m3 {/1m³/}        -> lessOrEqual? 1`m3 to :binary 1         
        -> lessOrEqual? 1`m3 to :binary 1   -> lessOrEqual? [1`m3] [(1)]              
        -> lessOrEqual? 1`m3 [1`m3]         -> lessOrEqual? 1`m3 1..1                 
        -> lessOrEqual? 1`m3 #[one: 1`m3]   -> lessOrEqual? 0`m3 #black               
        -> lessOrEqual? 1`m3 var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> lessOrEqual? 1`c null            -> lessOrEqual? 1`c true
        -> lessOrEqual? 1`c false           -> lessOrEqual? 1`c to :complex [1 1]
        -> lessOrEqual? 1`c 1.0.0           -> lessOrEqual? 1`c :quantity
        -> lessOrEqual? 1`c '1'             -> lessOrEqual? 1`c "1°C"
        -> lessOrEqual? [1`c] [one]         -> lessOrEqual? [1`c] [one:]
        -> lessOrEqual? 1`c '1.0i           -> lessOrEqual? [1`c] [.1]            
        -> lessOrEqual? [1`c] [.1:]         -> lessOrEqual? [1`c] [one\1]       
        -> lessOrEqual? [1`c] [one\1:]      -> lessOrEqual? [1`c] [+]           
        -> lessOrEqual? 1`c {/1°C/}         -> lessOrEqual? 1`c to :binary 1    
        -> lessOrEqual? 1`c to :binary 1    -> lessOrEqual? [1`c] [(1)]         
        -> lessOrEqual? 1`c [1`c]           -> lessOrEqual? 1`c 1..1            
        -> lessOrEqual? 1`c #[one: 1`c]     -> lessOrEqual? 0`c #black          
        -> lessOrEqual? 1`c var 'one?
    ] => not? passed
    
    ; for :null
    ensure -> every? @[
        -> lessOrEqual? null 0                  -> lessOrEqual? null 0.0            
        -> lessOrEqual? null to :rational [1 1] -> lessOrEqual? null true
        -> lessOrEqual? null false              -> lessOrEqual? null to :complex [0 0]
        -> lessOrEqual? null 0.0.0              -> lessOrEqual? null :null
        -> lessOrEqual? null 'ø'                -> lessOrEqual? null "null"
        -> lessOrEqual? @[null] [null]          -> lessOrEqual? @[null] [null:]
        -> lessOrEqual? null 'null              -> lessOrEqual? @[null] [.null]               
        -> lessOrEqual? @[null] [.null:]        -> lessOrEqual? @[null] [null\null]
        -> lessOrEqual? @[null] [null\null:]    -> lessOrEqual? @[null] [ø]                   
        -> lessOrEqual? null {/null/}           -> lessOrEqual? null {/ø/}                    
        -> lessOrEqual? null to :binary 0       -> lessOrEqual? null to :binary 0             
        -> lessOrEqual? @[null] [(null)]        -> lessOrEqual? null [null]                   
        -> lessOrEqual? null 0..0               -> lessOrEqual? null #[null: null]            
        -> lessOrEqual? null #black          
        -> lessOrEqual? null var 'null?
    ] => not? passed
    
    ; for :logical
    ensure -> every? @[
        -> lessOrEqual? true 0                  -> lessOrEqual? true 0.0            
        -> lessOrEqual? true to :rational [1 1] -> lessOrEqual? true to :complex [0 0]
        -> lessOrEqual? true 0.0.0              -> lessOrEqual? true :true
        -> lessOrEqual? true '0'                -> lessOrEqual? true "true"
        -> lessOrEqual? @[true] [true]          -> lessOrEqual? @[true] [true:]
        -> lessOrEqual? true 'true              -> lessOrEqual? @[true] [.true]               
        -> lessOrEqual? @[true] [.true:]        -> lessOrEqual? @[true] [true\true]
        -> lessOrEqual? @[true] [true\true:]    -> lessOrEqual? @[true] [ø]                   
        -> lessOrEqual? true {/true/}           -> lessOrEqual? true to :binary 0             
        -> lessOrEqual? true to :binary 0       -> lessOrEqual? @[true] [(true)]              
        -> lessOrEqual? true [true]             -> lessOrEqual? true 0..0                     
        -> lessOrEqual? true #[true: true]      -> lessOrEqual? true #black                   
        -> lessOrEqual? true var 'true?
    ] => not? passed
    
    ensure -> every? @[
        -> lessOrEqual? false 0                     -> lessOrEqual? false 0.0            
        -> lessOrEqual? false to :rational [1 1]    -> lessOrEqual? false to :complex [0 0]
        -> lessOrEqual? false 0.0.0                 -> lessOrEqual? false :false
        -> lessOrEqual? false '0'                   -> lessOrEqual? false "false"
        -> lessOrEqual? @[false] [false]            -> lessOrEqual? @[false] [false:]
        -> lessOrEqual? false 'false                -> lessOrEqual? @[false] [.false]                 
        -> lessOrEqual? @[false] [.false:]          -> lessOrEqual? @[false] [false\false]
        -> lessOrEqual? @[false] [false\false:]     -> lessOrEqual? @[false] [ø]                      
        -> lessOrEqual? false {/false/}             -> lessOrEqual? false to :binary 0                
        -> lessOrEqual? false to :binary 0          -> lessOrEqual? @[false] [(false)]                
        -> lessOrEqual? false [false]               -> lessOrEqual? false 0..0                        
        -> lessOrEqual? false #[false: false]       -> lessOrEqual? false #black                      
        -> lessOrEqual? false var 'false?
    ] => not? passed
    
    ensure -> every? @[
        -> lessOrEqual? maybe 0                     -> lessOrEqual? maybe 0.0            
        -> lessOrEqual? maybe to :rational [1 1]    -> lessOrEqual? maybe to :complex [0 0]
        -> lessOrEqual? maybe 0.0.0                 -> lessOrEqual? maybe :maybe
        -> lessOrEqual? maybe '0'                   -> lessOrEqual? maybe "maybe"
        -> lessOrEqual? @[maybe] [maybe]            -> lessOrEqual? @[maybe] [maybe:]
        -> lessOrEqual? maybe 'maybe                -> lessOrEqual? @[maybe] [.maybe]                 
        -> lessOrEqual? @[maybe] [.maybe:]          -> lessOrEqual? @[maybe] [maybe\maybe]
        -> lessOrEqual? @[maybe] [maybe\maybe:]     -> lessOrEqual? @[maybe] [ø]                      
        -> lessOrEqual? maybe {/maybe/}             -> lessOrEqual? maybe to :binary 0                
        -> lessOrEqual? maybe to :binary 0A         -> lessOrEqual? @[maybe] [(maybe)]                
        -> lessOrEqual? maybe [maybe]               -> lessOrEqual? maybe 0..0                        
        -> lessOrEqual? maybe #[maybe: maybe]       -> lessOrEqual? maybe #black                      
    ] => not? passed
    
    ; for :complex
    a: to :complex [1 1]
    ensure -> every? @[
        -> lessOrEqual? a 1                     -> lessOrEqual? a 1.0            
        -> lessOrEqual? a to :rational [1 1]    -> lessOrEqual? a null                    
        -> lessOrEqual? a true                  -> lessOrEqual? a false
        -> lessOrEqual? a 1.0.0                 -> lessOrEqual? a :rational
        -> lessOrEqual? a '1'                   -> lessOrEqual? a "1.0+1.0i"
        -> lessOrEqual? @[a] [one]              -> lessOrEqual? @[a] [one:]
        -> lessOrEqual? 1 '1                    -> lessOrEqual? @[a] [.1]                 
        -> lessOrEqual? @[a] [.1:]              -> lessOrEqual? @[a] [one\1]
        -> lessOrEqual? @[a] [one\1:]           -> lessOrEqual? @[a] [+]                  
        -> lessOrEqual? a {/1.0+1.0i/}          -> lessOrEqual? a to :binary 1            
        -> lessOrEqual? a to :binary 1          -> lessOrEqual? @[a] [(1)]                
        -> lessOrEqual? a [1]                   -> lessOrEqual? a 1..1                    
        -> lessOrEqual? a #[one: 1]             -> lessOrEqual? to :complex [0 0] #black  
        -> lessOrEqual? a var 'one?
    ] => not? passed
    
    ; for :version
    ensure -> every? @[
        -> lessOrEqual? 1.0.0 1                     -> lessOrEqual? 1.0.0 1.0          
        -> lessOrEqual? 1.0.0 to :rational [1 1]    -> lessOrEqual? 1.0.0 null                    
        -> lessOrEqual? 1.0.0 true                  -> lessOrEqual? 1.0.0 false                   
        -> lessOrEqual? 1.0.0 to :complex [1.0 1.0] -> lessOrEqual? 1.0.0 :floating
        -> lessOrEqual? 1.0.0 '1'                   -> lessOrEqual? 1.0.0 "1.0.0"
        -> lessOrEqual? [1.0.0] [one]               -> lessOrEqual? [1.0.0] [one:]
        -> lessOrEqual? 1.0.0 '1                    -> lessOrEqual? [1.0.0] [.1]                  
        -> lessOrEqual? [1.0.0] [.1:]               -> lessOrEqual? [1.0.0] [one\1]
        -> lessOrEqual? [1.0.0] [one\1:]            -> lessOrEqual? [1.0.0] [+]                   
        -> lessOrEqual? 1.0.0 {/1.0.0/}             -> lessOrEqual? 1.0.0 to :binary 1.0          
        -> lessOrEqual? 1.0.0 to :binary 1.0        -> lessOrEqual? [1.0.0] [(1.0.0)]             
        -> lessOrEqual? 1.0.0 [1.0.0]               -> lessOrEqual? 1.0.0 1..1                    
        -> lessOrEqual? 1.0.0 #[one: 1.0.0]         -> lessOrEqual? 0.0.0 #black                  
        -> lessOrEqual? 1.0.0 var 'version?
    ] => not? passed
    
    ; for :type
    ensure -> every? @[
        -> lessOrEqual? :1 1                            -> lessOrEqual? :1 1.0          
        -> lessOrEqual? :integer 1                      -> lessOrEqual? :floating 1.0          
        -> lessOrEqual? :rational to :rational [1 1]    -> lessOrEqual? :null null                    
        -> lessOrEqual? :true true                      -> lessOrEqual? :false false                   
        -> lessOrEqual? :logical false                  -> lessOrEqual? :complex to :complex [1 1]   
        -> lessOrEqual? :version 1.0.0                  -> lessOrEqual? :T 'T'                         
        -> lessOrEqual? :char 'T'                       -> lessOrEqual? :string ":type"
        -> lessOrEqual? [:type] [type]                  -> lessOrEqual? [:word] [word]                     
        -> lessOrEqual? [:type] [type:]                 -> lessOrEqual? [:label] [label:]
        -> lessOrEqual? :1 '1.                          -> lessOrEqual? :literal '1                       
        -> lessOrEqual? [:type] [.type]                 -> lessOrEqual? [:attribute] [.type]              
        -> lessOrEqual? [:type] [.type:]                -> lessOrEqual? [:attributelabel] [.type:]                
        -> lessOrEqual? [:type] [type\type]             -> lessOrEqual? [:path] [type\type]
        -> lessOrEqual? [:type] [type\type:]            -> lessOrEqual? [:pathLabel] [type\type:]            
        -> lessOrEqual? [:type] [+]                     -> lessOrEqual? [:symbol] [+]                     
        -> lessOrEqual? :type {/:type/}                 -> lessOrEqual? :regex {/:type/}                  
        -> lessOrEqual? :type to :binary 1.0            -> lessOrEqual? :binary to :binary 1.0            
        -> lessOrEqual? [:type] [(:type)]               -> lessOrEqual? [:inline] [(:type)]               
        -> lessOrEqual? :type [:type]                   -> lessOrEqual? :block [:type]                    
        -> lessOrEqual? :type 1..1                      -> lessOrEqual? :range 1..1                       
        -> lessOrEqual? :type #[type: :type]            -> lessOrEqual? :dictionary #[type: :type]        
        -> lessOrEqual? :type #black                    -> lessOrEqual? :color #black                     
        -> lessOrEqual? :type var 'type?                -> lessOrEqual? :function var 'one?
    ] => not? passed
    
    ; for :char
    ensure -> every? @[
        -> lessOrEqual? '1' 1.0          
        -> lessOrEqual? '1' to :rational [1 1]      -> lessOrEqual? 'ø' null                    
        -> lessOrEqual? 't' true                    -> lessOrEqual? 'f' false                   
        -> lessOrEqual? '1' to :complex [1.0 1.0]   -> lessOrEqual? 'T' :floating
        -> lessOrEqual? ['a'] [one]                 -> lessOrEqual? 'a' 'A                      
        -> lessOrEqual? ['a'] [.1]                  -> lessOrEqual? ['a'] [.a:]                 
        -> lessOrEqual? ['a'] [a\a]                 -> lessOrEqual? ['a'] [a\a:]                
        -> lessOrEqual? ['+'] [+]                   -> lessOrEqual? 'a' {/a/}                   
        -> lessOrEqual? '1' to :binary 1            -> lessOrEqual? 'a' to :binary 1            
        -> lessOrEqual? ['1'] [('1')]               -> lessOrEqual? 'a' ['a']                   
        -> lessOrEqual? '1' 1..1                    -> lessOrEqual? 'a' #[a: 'a']               
        -> lessOrEqual? '1' #black                  -> lessOrEqual? 'a' var 'char?
    ] => not? passed
    
    ; for :string
    ensure -> every? @[
        -> lessOrEqual? "1" 1                               -> lessOrEqual? "1/1" to :rational [1 1]          
        -> lessOrEqual? "1.0" 1.0                           -> lessOrEqual? "null" null                    
        -> lessOrEqual? "" null                             -> lessOrEqual? "true" true                  
        -> lessOrEqual? "" false                            -> lessOrEqual? "false" false                   
        -> lessOrEqual? "1.0+1.0i" to :complex [1.0 1.0]    -> lessOrEqual? "type" :floating
        -> lessOrEqual? "floating" :floating                -> lessOrEqual? ":floating" :floating
        -> lessOrEqual? "1.0" :floating                     -> lessOrEqual? ["a"] [a\a]
        -> lessOrEqual? ["a"] [a\a:]                        -> lessOrEqual? ["+"] [+]                         
        -> lessOrEqual? "a" {/a/}                           -> lessOrEqual? "01" to :binary 1                 
        -> lessOrEqual? "1" to :binary 1                    -> lessOrEqual? [""] [("")]                       
        -> lessOrEqual? "" [""]                             -> lessOrEqual? "1" 1..1                          
        -> lessOrEqual? "a" #[a: "a"]                       -> lessOrEqual? "#000000" #black                  
        -> lessOrEqual? "000000" #black                     -> lessOrEqual? "" var 'char?
    ] => not? passed
    
    ; for :word
    ensure -> every? @[        
        -> lessOrEqual? [rational] @[to :rational [1 1]]      -> lessOrEqual? [null]  @[null]                    
        -> lessOrEqual? [true]     @[true]                    -> lessOrEqual? [false] @[false]                   
        -> lessOrEqual? [complex]  @[to :complex [1.0 1.0]]   -> lessOrEqual? [type]  @[:floating]  
        -> lessOrEqual? [floating] @[:floating]               -> lessOrEqual? [a]      [a\a]                   
        -> lessOrEqual? [a]         [a\a:]                    -> lessOrEqual? [a]     @[{/a/}]                      
        -> lessOrEqual? [binary]   @[to :binary 1]            -> lessOrEqual? [one]   @[to :binary 1]              
        -> lessOrEqual? [word]      [(word)]                  -> lessOrEqual? [word]  @[[word]]                      
        -> lessOrEqual? [range]    @[range 1 1]               -> lessOrEqual? [a]     @[#[a: 'a']]               
        -> lessOrEqual? [black]    @[#black ]                 -> lessOrEqual? [word]  @[var 'word?]              
        -> lessOrEqual? [var]      @[var 'word?]
    ] => not? passed
    
    ; for :label
    ensure -> every? @[
        -> lessOrEqual? [rational:] @[to :rational [1 1]]     -> lessOrEqual? [null:]     @[null]                                                        
        -> lessOrEqual? [true:]     @[true]                   -> lessOrEqual? [false:]    @[false]                   
        -> lessOrEqual? [complex:]  @[to :complex [1.0 1.0]]  -> lessOrEqual? [floating:] @[:floating]
        -> lessOrEqual? [type:]     @[:floating]              -> lessOrEqual? [a:]         [a\a]                     
        -> lessOrEqual? [a:]         [a\a:]                   -> lessOrEqual? [a:]        @[{/a:/}]                 
        -> lessOrEqual? [binary:]   @[to :binary 1]           -> lessOrEqual? [word:]      [(word:)]                
        -> lessOrEqual? [label:]    @[[label:]]               -> lessOrEqual? [a:]        @[#[a: 'a']]               
        -> lessOrEqual? [black:]    @[#black ]                -> lessOrEqual? [var:]      @[var 'word?]
        -> lessOrEqual? [word:]     @[var 'word?]
    ] => not? passed
    
    ; for :literal
    ; NOTE: technically, '+ is not a :literal, but a :symbolLiteral type ;)
    ensure -> every? @[
        -> lessOrEqual? 'integer  1                   -> lessOrEqual? 'floating 1.0
        -> lessOrEqual? 'rational to :rational [1 1]  -> lessOrEqual? 'one      to :rational [1 1]
        -> lessOrEqual? 'null     null                -> lessOrEqual? 'true     true    
        -> lessOrEqual? 'false    false               -> lessOrEqual? 'complex  to :complex [1.0 1.0]    
        -> lessOrEqual? 'type     :floating           -> lessOrEqual? 'floating :floating               
        -> lessOrEqual? ['a]        [a\a]             -> lessOrEqual? ['+]      [+]                       
        -> lessOrEqual? 'a        {/a/}               -> lessOrEqual? 'binary   to :binary 1            
        -> lessOrEqual? ['word]   [('word)]           -> lessOrEqual? 'word     ['word]                                     
        -> lessOrEqual? 'range    1..1                -> lessOrEqual? 'a        #[a: 'a]                
        -> lessOrEqual? 'black    #black              -> lessOrEqual? 'word?    var 'word?              
        -> lessOrEqual? 'var      var 'var
    ] => not? passed
    
    ; for :attribute
    ensure -> every? @[           
        -> lessOrEqual? [.rational] @[to :rational [1 1]]    -> lessOrEqual? [.null]     @[null]                  
        -> lessOrEqual? [.true]     @[true]                  -> lessOrEqual? [.false]    @[false]                 
        -> lessOrEqual? [.complex]  @[to :complex [1.0 1.0]] -> lessOrEqual? [.floating] @[:floating]                          
        -> lessOrEqual? [.a]        @[{/a:/}]                -> lessOrEqual? [.binary]   @[to :binary 1]          
        -> lessOrEqual? [.word]      [(.word:)]              -> lessOrEqual? [.label]    @[[.label]]                               
        -> lessOrEqual? [.a]        @[#[a: 'a']]             -> lessOrEqual? [.black]    @[#black]                
        -> lessOrEqual? [.var]      @[var 'word?]            -> lessOrEqual? [.word]     @[var 'word?]
    ] => not? passed
    
    ; for :attributelabel
    ensure -> every? @[           
        -> lessOrEqual? [.rational:] @[to :rational [1 1]]    -> lessOrEqual? [.null:]     @[null]                  
        -> lessOrEqual? [.true:]     @[true]                  -> lessOrEqual? [.false:]    @[false]                 
        -> lessOrEqual? [.complex:]  @[to :complex [1.0 1.0]] -> lessOrEqual? [.floating:] @[:floating]             
        -> lessOrEqual? [.a:]         [a\a]                   -> lessOrEqual? [.a: 'a']     [a\a: 'a']              
        -> lessOrEqual? [.plus:]      [+]                     -> lessOrEqual? [.a:]        @[{/a:/}]                
        -> lessOrEqual? [.binary:]   @[to :binary 1]          -> lessOrEqual? [.word:]      [(.word:)]               
        -> lessOrEqual? [.label:]    @[[label:]]              -> lessOrEqual? [.a:]        @[#[a: 'a']]             
        -> lessOrEqual? [.black:]    @[#black]                -> lessOrEqual? [.var:]      @[var 'word?]            
        -> lessOrEqual? [.word:]     @[var 'word?]
    ] => not? passed
    
    ; for :path & :pathLabel
    ensure -> every? @[
        -> lessOrEqual? [a\b:] [a\b]
        -> lessOrEqual? [a\b] [a\b:]
    ] => not? passed

    ; for :regex
    ensure -> every? @[
        -> lessOrEqual? {/1/} 1                               -> lessOrEqual? {/1/1/} to :rational [1 1]          
        -> lessOrEqual? {/1.0/} 1.0                           -> lessOrEqual? {/null/} null                    
        -> lessOrEqual? {//} null                             -> lessOrEqual? {/true/} true                  
        -> lessOrEqual? {//} false                            -> lessOrEqual? {/false/} false                   
        -> lessOrEqual? {/1.0+1.0i/} to :complex [1.0 1.0]    -> lessOrEqual? {/type/} :floating
        -> lessOrEqual? {/floating/} :floating                -> lessOrEqual? {/:floating/} :floating
        -> lessOrEqual? {/1.0/} :floating                     -> lessOrEqual? [{/a/}] [a\a]
        -> lessOrEqual? [{/a/}] [a\a:]
        -> lessOrEqual? [{/\+/}] [+]                          -> lessOrEqual? {/01/} to :binary 1                 
        -> lessOrEqual? {/1/} to :binary 1                    -> lessOrEqual? [{//}] [({//})]                     
        -> lessOrEqual? {//} [""]                             -> lessOrEqual? {/1/} 1..1                          
        -> lessOrEqual? {/a/} #[a: "a"]                       -> lessOrEqual? {/#000000/} #black                  
        -> lessOrEqual? {/000000/} #black                     -> lessOrEqual? {/var/} var 'regex?
        -> lessOrEqual? {/regex?/} var 'regex?
    ] => not? passed
    
    ; for :binary
    ensure -> every? @[
        -> lessOrEqual? to :binary 1 1                    -> lessOrEqual? to :binary 1 1.0                
        -> lessOrEqual? to :binary 1 to :rational [1 1]   -> lessOrEqual? to :binary 1 1`usd                
        -> lessOrEqual? to :binary 1 1`m                  -> lessOrEqual? to :binary 1 1`m3                 
        -> lessOrEqual? to :binary 1 1`c                  -> lessOrEqual? to :binary 0 null                 
        -> lessOrEqual? to :binary 0 true                 -> lessOrEqual? to :binary 0 false                
        -> lessOrEqual? to :binary 0 maybe                -> lessOrEqual? to :binary 1 to :complex [1 1]                  
        -> lessOrEqual? to :binary 1 1.0.0                -> lessOrEqual? to :binary 1 :type              
        -> lessOrEqual? to :binary 1 :binary              -> lessOrEqual? to :binary 1 '1'                  
        -> lessOrEqual? to :binary "a" 'a'                -> lessOrEqual? to :binary 1 "01"                 
        -> lessOrEqual? to :binary 1 "1"                  -> lessOrEqual? @[to :binary 1] [binary]          
        -> lessOrEqual? @[to :binary 1] [one]             -> lessOrEqual? @[to :binary 1] [binary:]         
        -> lessOrEqual? @[to :binary 1][.binary]          -> lessOrEqual? @[to :binary 1] [.binary:]        
        -> lessOrEqual? to :binary 1 {/01/}               -> lessOrEqual? to :binary 1    {/1/}
    ] => not? passed
    
    ; for :range
    ensure -> every? @[
        -> lessOrEqual? 1..1 1                        -> lessOrEqual? 1..1 1.0
        -> lessOrEqual? 1..1 a: to :rational [1 1]    -> lessOrEqual? 1..1 1`usd
        -> lessOrEqual? 1..1 1`m                      -> lessOrEqual? 1..1 1`m3  
        -> lessOrEqual? 1..1 1`c                      -> lessOrEqual? 0..0 null 
        -> lessOrEqual? 0..0 true                     -> lessOrEqual? 0..0 false
        -> lessOrEqual? 0..0 maybe                    -> lessOrEqual? 1..1 to :complex [1 1]
        -> lessOrEqual? 1..1 1.0.0                    -> lessOrEqual? 1..1 :type                        
        -> lessOrEqual? 1..1 :range                   -> lessOrEqual? 1..1 '1' 
        -> lessOrEqual? 1..1 "1"                      -> lessOrEqual? 1..1 'range  
        -> lessOrEqual? 1..1 {/1/}
    ] => not? passed
    
    ; for :dictionary, :object & :date
    define :person [name surname]
    
    a: to :person ["Walter" "Pinkman"]
    b: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    
    ensure -> every? @[
        -> lessOrEqual? #[name: "Walter" surname: "Pinkman"] a
        -> lessOrEqual? a #[name: "Walter" surname: "Pinkman"]
        -> lessOrEqual? #[year: 2023 day: 15 Month: "January"] b
        -> lessOrEqual? b #[year: 2023 day: 15 Month: "January"]
    ] => not? passed
    
    ; for :color
    ensure -> every? @[
        -> lessOrEqual? #black 0                  -> lessOrEqual? #black 0.0
        -> lessOrEqual? #black to :rational [1 1] -> lessOrEqual? #black 0`usd 
        -> lessOrEqual? #black 0`m                -> lessOrEqual? #black 0`m3
        -> lessOrEqual? #black 0`c                -> lessOrEqual? #black null 
        -> lessOrEqual? #black true               -> lessOrEqual? #black false 
        -> lessOrEqual? #black maybe              -> lessOrEqual? #black to :complex [0 0]
        -> lessOrEqual? #black 0.0.0              -> lessOrEqual? #black :color
        -> lessOrEqual? #black '1'                -> lessOrEqual? #black "#000000"
        -> lessOrEqual? #black "000000"           -> lessOrEqual? [#black] [black] 
        -> lessOrEqual? #black 'black             -> lessOrEqual? [#black] [.black]
        -> lessOrEqual? [#black] [.black:]        -> lessOrEqual? #black  {/#000000/}                 
        -> lessOrEqual? #black{/000000/} 
    ] => not? passed
    
    ; for :function
    ensure -> every? @[
        -> lessOrEqual? var 'null?     null       -> lessOrEqual? var 'true?    true  
        -> lessOrEqual? var 'false?    false 
        -> lessOrEqual? var 'version?  1.0.0      -> lessOrEqual? var 'type?    :type 
        -> lessOrEqual? var 'function? :function  -> lessOrEqual? var 'char?    'a' 
        -> lessOrEqual? @[var 'word?]  [word]     -> lessOrEqual? @[var 'word?] [var]      
        -> lessOrEqual? @[var 'word?]  [var:]     -> lessOrEqual? @[var 'word?] [word:]    
        -> lessOrEqual? var 'word?     'word?     -> lessOrEqual? var 'var      'var       
        -> lessOrEqual? @[var 'word?]  [.var]     -> lessOrEqual? @[var 'word?] [.word]    
        -> lessOrEqual? @[var 'word?]  [.var:]    -> lessOrEqual? @[var 'word?] [.word:]   
        -> lessOrEqual? var 'regex?    {/var/}    -> lessOrEqual? var 'regex?   {/regex?/} 
    ] => not? passed
    
    
]


topic « notEqual?
do [
    
    
    topic « notEqual? - :integer :floating :rational
    
    ensure -> not? notEqual? 1 1
    ensure -> not? notEqual? 1 1.0
    ensure -> not? notEqual? 1 to :rational @[1 1]
    ensure -> not? notEqual? 1 to :rational @[5 5]
    ensure -> notEqual? 1 2
    ensure -> notEqual? 1 2.0
    ensure -> notEqual? 1 :rational @[1 2]
    ensure -> not? 1 <> 1
    ensure -> not? 1 <> 1.0
    ensure -> not? 1 <> to :rational @[1 1]
    ensure -> not? 1 <> to :rational @[5 5]
    ensure -> 1 <> 2
    ensure -> 1 <> 2.0
    ensure -> 1 <> :rational @[1 2]
    passed
    
    ensure -> not? notEqual? 1.0 1
    ensure -> not? notEqual? 1.0 1.0
    ensure -> not? notEqual? 1.0 to :rational @[1 1]
    ensure -> not? notEqual? 1.0 to :rational @[5 5]
    ensure -> notEqual? 1.0 2
    ensure -> notEqual? 1.0 2.0
    ensure -> notEqual? 1.0 to :rational @[1 2]
    ensure -> not? 1.0 <> 1
    ensure -> not? 1.0 <> 1.0
    ensure -> not? 1.0 <> to :rational @[1 1]
    ensure -> not? 1.0 <> to :rational @[5 5]
    ensure -> 1.0 <> 2
    ensure -> 1.0 <> 2.0
    ensure -> 1.0 <> to :rational @[1 2]
    passed
    
    ensure -> not? notEqual? to :rational @[5 5] 1
    ensure -> not? notEqual? to :rational @[5 5] 1.0
    ensure -> not? notEqual? to :rational @[5 5] to :rational @[1 1]
    ensure -> notEqual? to :rational @[5 5] 2
    ensure -> notEqual? to :rational @[5 5] 2.0
    ensure -> notEqual? to :rational @[5 5] to :rational @[1 2]
    ensure -> not? (to :rational @[5 5]) <> 1
    ensure -> not? (to :rational @[5 5]) <> 1.0
    ensure -> not? (to :rational @[5 5]) <> to :rational @[1 1]
    ensure -> (to :rational @[5 5]) <> 2
    ensure -> (to :rational @[5 5]) <> 2.0
    ensure -> (to :rational @[5 5]) <> to :rational @[1 2]
    passed
    
    
    topic « notEqual? - :quantity
    
    ensure -> not? notEqual? 1`usd 1
    ensure -> not? notEqual? 1`m   1
    ensure -> not? notEqual? 1`m2  1
    ensure -> not? notEqual? 1`m3  1
    ensure -> not? notEqual? 1`c   1
    ensure -> not? notEqual? 1`f   1
    ensure -> not? 1`usd <> 1
    ensure -> not? 1`m   <> 1
    ensure -> not? 1`m2  <> 1
    ensure -> not? 1`m3  <> 1
    ensure -> not? 1`c   <> 1
    ensure -> not? 1`f   <> 1
    passed
    
    ensure -> not? notEqual? 1 1`usd
    ensure -> not? notEqual? 1 1`m
    ensure -> not? notEqual? 1 1`m2
    ensure -> not? notEqual? 1 1`m3
    ensure -> not? notEqual? 1 1`c
    ensure -> not? notEqual? 1 1`f
    ensure -> not? 1 <> 1`usd
    ensure -> not? 1 <> 1`m
    ensure -> not? 1 <> 1`m2
    ensure -> not? 1 <> 1`m3
    ensure -> not? 1 <> 1`c
    ensure -> not? 1 <> 1`f
    passed
    
    ensure -> not? notEqual? 1`usd 1.0
    ensure -> not? notEqual? 1`m   1.0
    ensure -> not? notEqual? 1`m2  1.0
    ensure -> not? notEqual? 1`m3  1.0
    ensure -> not? notEqual? 1`c   1.0
    ensure -> not? notEqual? 1`f   1.0
    ensure -> not? 1`usd <> 1.0
    ensure -> not? 1`m   <> 1.0
    ensure -> not? 1`m2  <> 1.0
    ensure -> not? 1`m3  <> 1.0
    ensure -> not? 1`c   <> 1.0
    ensure -> not? 1`f   <> 1.0
    passed
    
    ensure -> not? notEqual? 1.0 1`usd
    ensure -> not? notEqual? 1.0 1`m
    ensure -> not? notEqual? 1.0 1`m2
    ensure -> not? notEqual? 1.0 1`m3
    ensure -> not? notEqual? 1.0 1`c
    ensure -> not? notEqual? 1.0 1`f
    ensure -> not? 1.0 <> 1`usd
    ensure -> not? 1.0 <> 1`m
    ensure -> not? 1.0 <> 1`m2
    ensure -> not? 1.0 <> 1`m3
    ensure -> not? 1.0 <> 1`c
    ensure -> not? 1.0 <> 1`f
    passed
    
    ensure -> not? notEqual? 1`usd to :rational @[5 5]
    ensure -> not? notEqual? 1`m   to :rational @[5 5]
    ensure -> not? notEqual? 1`m2  to :rational @[5 5]
    ensure -> not? notEqual? 1`m3  to :rational @[5 5]
    ensure -> not? notEqual? 1`c   to :rational @[5 5]
    ensure -> not? notEqual? 1`f   to :rational @[5 5]
    ensure -> not? 1`usd <> to :rational @[5 5]
    ensure -> not? 1`m   <> to :rational @[5 5]
    ensure -> not? 1`m2  <> to :rational @[5 5]
    ensure -> not? 1`m3  <> to :rational @[5 5]
    ensure -> not? 1`c   <> to :rational @[5 5]
    ensure -> not? 1`f   <> to :rational @[5 5]
    passed
    
    ensure -> not? notEqual? to :rational @[5 5] 1`usd
    ensure -> not? notEqual? to :rational @[5 5] 1`m
    ensure -> not? notEqual? to :rational @[5 5] 1`m2
    ensure -> not? notEqual? to :rational @[5 5] 1`m3
    ensure -> not? notEqual? to :rational @[5 5] 1`c
    ensure -> not? notEqual? to :rational @[5 5] 1`f
    ensure -> not? (to :rational @[5 5]) <> 1`usd
    ensure -> not? (to :rational @[5 5]) <> 1`m
    ensure -> not? (to :rational @[5 5]) <> 1`m2
    ensure -> not? (to :rational @[5 5]) <> 1`m3
    ensure -> not? (to :rational @[5 5]) <> 1`c
    ensure -> not? (to :rational @[5 5]) <> 1`f
    passed
    
    ensure -> notEqual? 2`usd 1
    ensure -> notEqual? 2 1`usd
    ensure -> notEqual? 2`usd 1.0
    ensure -> notEqual? 2.0 1`usd
    ensure -> notEqual? 2`usd to :rational @[5 5]
    ensure -> notEqual? to :rational @[2 5] 1`usd
    passed
    
    ensure -> not? notEqual? 1.5`m 150`cm 
    ensure -> notEqual? 2`m 2`cm
    passed 
    
    
    topic « notEqual? - :null
    
    ensure -> not? notEqual? null null
    ensure -> not? notEqual? null ø
    ensure -> not? notEqual? ø ø
    ensure -> not? notEqual? ø null
    ensure -> not? null <> null
    ensure -> not? null <> ø
    ensure -> not? ø <> ø
    ensure -> not? ø <> null
    passed
    
    ensure -> notEqual? ø 1
    ensure -> notEqual? ø 1.0
    ensure -> notEqual? ø "ø"
    ensure -> notEqual? ø 'ø'
    ensure -> ø <> 1
    ensure -> ø <> 1.0
    ensure -> ø <> "ø"
    ensure -> ø <> 'ø'
    passed
    
    
    topic « notEqual? - :logical
    
    ensure -> not? notEqual? true true
    ensure -> not? notEqual? true (1 > 0)
    ensure -> not? true <> true
    ensure -> not? true <> (1 > 0)
    passed
    
    ensure -> notEqual? true maybe
    ensure -> notEqual? true false
    ensure -> true <> maybe
    ensure -> true <> false
    passed
    
    
    topic « notEqual? - :complex
    
    ensure -> not? notEqual? to :complex [0 2] to :complex [0 2]
    ensure -> not? (to :complex [0 2]) <> (to :complex [0 2])
    passed
    
    ; greater than
    ensure -> notEqual? to :complex [2 2] to :complex [1 2] 
    ensure -> notEqual? to :complex [2 3] to :complex [1 2]
    ensure -> (to :complex [2 2]) <> (to :complex [1 2]) 
    ensure -> (to :complex [2 3]) <> (to :complex [1 2]) 
    passed
    
    ; less than
    ensure -> notEqual? to :complex [0 2] to :complex [1 2] 
    ensure -> notEqual? to :complex [0 1] to :complex [1 2]
    ensure -> (to :complex [0 2]) <> (to :complex [1 2]) 
    ensure -> (to :complex [0 1]) <> (to :complex [1 2])
    passed
    
    
    topic « notEqual? - :version
    
    ensure -> not? notEqual? 1.2.3 1.2.3
    ensure -> not? 1.2.3 <> 1.2.3
    passed
    
    ensure -> notEqual? 1.2.3 1.2.3-pre
    ensure -> notEqual? 1.2.3 1.2.3-dev
    ensure -> 1.2.3 <> 1.2.3-pre
    ensure -> 1.2.3 <> 1.2.3-dev
    passed
    
    
    topic « notEqual? - :type
    
    ensure -> not? notEqual? :string type "a"
    ensure -> not? notEqual? :integer type 1
    ensure -> not? notEqual? :floating type 1.5
    passed
    
    ensure -> notEqual? :string :integer
    ensure -> notEqual? :string :char
    ensure -> notEqual? :integer :floating
    passed
    
    
    topic « notEqual? - :char
    
    ensure -> not? notEqual? 'a' 'a'
    ensure -> not? 'a' <> 'a'
    passed
    
    ensure -> notEqual? 'a' "a" 
    ensure -> notEqual? 'a' 'b'
    ensure -> notEqual? '1' 1
    ensure -> notEqual? "a" 'a' 
    ensure -> notEqual? 'b' 'a'
    ensure -> notEqual? 1   '1'
    ensure -> 'a' <> "a" 
    ensure -> 'a' <> 'b'
    ensure -> '1' <>  1
    ensure -> "a" <> 'a' 
    ensure -> 'b' <> 'a'
    ensure ->  1  <> '1'
    passed 
    
    
    topic « notEqual? - :string
    
    ensure -> not? notEqual? "Art" "Arturo" -- "uro"
    ensure -> not? "Art" <> "Arturo" -- "uro"
    passed
    
    ensure -> notEqual? "A" "B"
    ensure -> notEqual? "Art" "Bob"
    passed
    
    ensure -> notEqual? "b" 'a'
    ensure -> notEqual? "b" 'a
    ensure -> notEqual? "b" to :label "a"
    ensure -> notEqual? "b" to :attribute "a"
    ensure -> notEqual? "b" to :attributelabel "a"
    ensure -> notEqual? "text" to :type "string"
    passed
    
    
    topic « notEqual? - :word
    
    ensure -> notEqual? to :word "a" to :word "b"
    ensure -> not? notEqual? to :word "a" to :word "a"
    passed
    
    ensure -> notEqual? to :word "b" "a"
    ensure -> notEqual? to :word "b" 'a'
    ensure -> notEqual? to :word "b" 'a
    ensure -> notEqual? to :word "b" to :label "a"
    ensure -> notEqual? to :word "b" to :attribute "a"
    ensure -> notEqual? to :word "b" to :attributelabel "a"
    ensure -> notEqual? to :word "text" to :type "word"
    passed
    
    
    topic « notEqual? - :label
    
    ensure -> notEqual? to :label "a" to :label "b"
    ensure -> not? notEqual? to :label "a" to :label "a"
    passed
    
    ensure -> notEqual? to :label "b" "a"
    ensure -> notEqual? to :label "b" 'a'
    ensure -> notEqual? to :label "b" 'a
    ensure -> notEqual? to :label "b" to :word "a"
    ensure -> notEqual? to :label "b" to :attribute "a"
    ensure -> notEqual? to :label "b" to :attributelabel "a"
    ensure -> notEqual? to :label "text" to :type "label"
    passed
    
    
    topic « notEqual? - :literal
    
    ensure -> notEqual? 'b "a"
    ensure -> notEqual? 'b 'a'
    ensure -> notEqual? 'b to :label "a"
    ensure -> notEqual? 'b to :word "a"
    ensure -> notEqual? 'b to :attribute "a"
    ensure -> notEqual? 'b to :attributelabel "a"
    ensure -> notEqual? to :literal "text" to :type "literal"
    passed
    
    
    topic « notEqual? - :attribute
    
    ensure -> notEqual? to :attribute "a" to :attribute "b"
    ensure -> not? notEqual? to :attribute "a" to :attribute "a"
    passed
    
    ensure -> notEqual? to :attribute "b" "a"
    ensure -> notEqual? to :attribute "b" 'a'
    ensure -> notEqual? to :attribute "b" 'a
    ensure -> notEqual? to :attribute "b" to :word "a"
    ensure -> notEqual? to :attribute "b" to :label "a"
    ensure -> notEqual? to :attribute "b" to :attributelabel "a"
    ensure -> notEqual? to :attribute "text" to :type "label"
    passed
    

    topic « notEqual? - :attributelabel
    
    ensure -> notEqual? to :attributelabel "a" to :attributelabel "b"
    ensure -> not? notEqual? to :attributelabel "a" to :attributelabel "a"
    passed
    
    ensure -> notEqual? to :attributelabel "b" "a"
    ensure -> notEqual? to :attributelabel "b" 'a'
    ensure -> notEqual? to :attributelabel "b" 'a
    ensure -> notEqual? to :attributelabel "b" to :word "a"
    ensure -> notEqual? to :attributelabel "b" to :label "a"
    ensure -> notEqual? to :attributelabel "b" to :attribute "a"
    ensure -> notEqual? to :attributelabel "text" to :type "label"
    passed
    
    
    topic « notEqual? - :path
    
    a: #[name: "John", surname: "Doe"]
    b: @["Joe" "Jane" "Jesse"]
    
    ensure -> not? notEqual? a\name "John" 
    ensure -> not? notEqual? a\surname "Doe" 
    ensure -> notEqual? a\name "Jane" 
    ensure -> notEqual? a\name 1
    passed
    
    ensure -> not? notEqual? b\0 "Joe" 
    ensure -> not? notEqual? b\1 "Jane" 
    ensure -> not? notEqual? b\2 "Jesse" 
    ensure -> notEqual? b\2 "Walter" 
    passed
    
    ensure -> not? notEqual? [b\0] [b\0]
    ensure -> not? notEqual? [a\name] [a\name]
    ensure -> notEqual? [b\0] [b\1]
    ensure -> notEqual? [a\name] [a\surname]
    passed
    
    
    topic « notEqual? - :pathLabel
       
    ensure -> not? notEqual? [a\name: "John"] [a\name: "John"]
    ensure -> notEqual? [a\surname: "Doe"] [b\surname: "Doe" ]
    ensure -> notEqual? [a\name: "John"] [b\name: "Jane"]
    ensure -> notEqual? [a\name: "John"] [b\name: "John"]
    passed
    
    
    topic « notEqual? - :symbol
    
    ensure -> not? notEqual? to :symbol "+" to :symbol "+"
    ensure -> notEqual? to :symbol "+" to :symbol "-"
    ensure -> notEqual? to :symbol "+" "++"
    ensure -> notEqual? to :symbol "+" '+'
    ensure -> notEqual? to :symbol "+" {+}
    ensure -> notEqual? to :symbol "+" "+"
    ensure -> notEqual? to :symbol "+" to :word "plus"
    ensure -> notEqual? to :symbol "+" '+
    passed
    
    
    topic « notEqual? - :regex
    
    ensure -> regex? {/[A-Z]/}
    ensure -> not? notEqual? {/[A-Z]/} {/[A-Z]/} 
    ensure -> notEqual? {/[A-Z]/} {/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/}
    ensure -> notEqual? {/[A-Z]/} {[A-Z]}
    ensure -> notEqual? {/[A-Z]/} "/[A-Z]/"
    passed
    
    
    topic « notEqual? - :binary
    
    ensure -> not? notEqual? "48 65 6C 6C 6F 20 77 6F 72 6C 64"
        ~{|to :binary "Hello world"|}
    ensure -> not? notEqual? "00" ~{|to :binary 0|}
    ensure -> not? notEqual? "01" ~{|to :binary 1|}
    ensure -> not? notEqual? "0A" ~{|to :binary 10|}
    ensure -> not? notEqual? "05" ~{|to :binary 5|}
    passed
    
    a: to :binary 0
    
    ensure -> notEqual? a 0
    ensure -> notEqual? "49 65 6C 6C 6F 20 77 6F 72 6C 64"
        ~{|to :binary "Hello world"|}
    passed
    
    
    topic « notEqual? - :bytecode
    
    x: to :bytecode [["print"][1 112 155]]
    
    ensure -> not? notEqual? x to :bytecode [["print"][1 112 155]]
    ensure -> notEqual? x to :bytecode [["print"][2 112 155]]
    ensure -> notEqual? x [["print"][2 112 155]]
    passed
    
    
    topic « notEqual? - :inline
    
    a: [(1 + 1)], b: [(1 + 1)] 
    ensure -> not? notEqual? a\0 b\0
    passed
    
    c: [(2 + 1)] 
    ensure -> notEqual? a\0 c\0
    passed
    
    d: [(3 - 1)] 
    ensure -> notEqual? a\0 d\0 ; even the calc (3-1) and (1+1) being 2, 
    passed                      ; they are different inlines 
                                ; with the same result when evaluated
    
    e: [(1 + 2 - 1)]
    ensure -> notEqual? a\0 e\0
    ensure -> notEqual? a\0 2
    passed
    
    
    topic « notEqual? - :block
    
    a: [1 + 1]
    ensure -> not? notEqual? a [1 + 1]
    ensure -> notEqual? a [2]
    ensure -> notEqual? a 2
    ensure -> notEqual? a [1 ++ 1]
    passed
    
    
    topic « notEqual? - :range
    
    ensure -> not? notEqual? [0 1 2 3 4 5] @0..5
    ensure -> not? notEqual? [0 2 4] @0.. .step: 2 5
    ensure -> not? notEqual? @range.step: 2 0 5 @range.step: 2 0 4
    ensure -> notEqual? range.step: 2 0 5 range.step: 2 0 4
    passed
    
    
    topic « notEqual? - :dictionary
    
    a: #[name: "Walter" surname: "Pinkman"]
    
    ensure -> not? notEqual? a #[name: "Walter" surname: "Pinkman"]
    ensure -> notEqual? a #[name: "Jesse" surname: "Pinkman"]
    ensure -> notEqual? a #[name "Jesse" surname "Pinkman"]
    ensure -> notEqual? a [name "Jesse" surname "Pinkman"]
    passed
    
    ensure -> not? notEqual? a\name "Walter"
    ensure -> not? notEqual? a\surname "Pinkman"
    ensure -> notEqual? a\surname "White"
    passed
    
    
    topic « notEqual? - :object
    
    define :person [  
        init: method [name, age][
            this\name: capitalize name
            this\age: age
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|"
        ]  
    ]
    
    define :student is :person [  
        init: method [name, age, id][
            this\name: capitalize name
            this\age: age
            this\id: id
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
        ]
    ]
    
    a: to :person ["Joe" 32]
    ensure -> not? notEqual? a to :person ["Joe" 32]
    ensure -> notEqual? to :person ["Joe" 32] #[name: "Joe" age: 32]
    ensure -> notEqual? to :person ["Joe" 32] to :student ["Joe" 32 15]
    passed
    
    a\name: "Jane"
    ensure -> not? notEqual? a to :person ["Jane" 32]
    passed
    
    define :person [  
        init: method [name, age][
            this\name: capitalize name
            this\age: age
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|"
        ]
        compare: method [that][
            if this\age > that\age -> return 1
            if this\age = that\age -> return 0
            if this\age < that\age -> return neg 1
        ]   
    ]
    
    define :student is :person [  
        init: method [name, age, id][
            this\name: capitalize name
            this\age: age
            this\id: id
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
        ]
    ]
    
    a: to :person ["John" 16]
    b: to :student ["Jane" 16 100]
    c: to :person ["John" 15]
    d: to :student ["Jane" 16 100]
    ensure -> not? notEqual? a b
    ensure -> not? notEqual? b a
    ensure -> notEqual? c d
    ensure -> notEqual? d c
    passed
    
    
    topic « notEqual? - :store
    
    a: store "test.db"
    a\name: "John" a\surname: "Doe"
    b: store "test.db"
    b\name: "John" b\surname: "Doe"
    c: store "test2.db"
    c\name: "John" c\surname: "Doe"
    d: store "test3.db"
    d\name: "Jane" d\surname: "Doe"
    
    ensure -> not? notEqual? a a
    ensure -> not? notEqual? a b
    ensure -> not? notEqual? b a
    passed
    
    ensure -> notEqual? a c 
    ensure -> notEqual? c a 
    ensure -> notEqual? a d 
    ensure -> notEqual? d a 
    ensure -> notEqual? c d 
    ensure -> notEqual? d c 
    passed
    
    
    topic « notEqual? - :color
    
    ensure -> not? notEqual? #000 #black
    ensure -> not? notEqual? #fff #white
    ensure -> not? notEqual? #white #white
    ensure -> notEqual? #black #white
    ensure -> notEqual? #white #black
    passed
    
    
    topic « notEqual? - :function
    
    ensure -> not? notEqual? var 'print var 'print
    ensure -> notEqual? var 'inspect var 'print
    passed
    
    a: $[name surname][]
    A: $[name][]
    b: $[name][]
    c: $[name surname][]
    
    ensure -> not? notEqual? ~"|var 'a|" ~"|$[name surname][]|"
    ensure -> not? notEqual? ~"|var 'a|" ~"|var 'c|"
    ensure -> notEqual? ~"|var 'a|" ~"|var 'A|"
    ensure -> notEqual? ~"|var 'a|" ~"|var 'b|"
    passed
    
    
    topic « notEqual? - :database
    ; todo: test this
    
    
    topic « notEqual? - :date
    
    a: to :date .format: "MMM dd" "Jan 15"
    b: to :date .format: "MMM dd" "Jan 15"
    c: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    d: now
    
    ensure -> not? notEqual? a b 
    ensure -> notEqual? a c 
    ensure -> notEqual? a d
    passed 
    
    ensure -> not? notEqual? a\day c\day
    ensure -> not? notEqual? a\month c\month
    ensure -> notEqual? a\year c\year
    passed
    
    topic « notEqual? - :unit
    
    ensure -> not? notEqual? `USD `USD
    ensure -> not? notEqual? `EUR `EUR
    ensure -> not? `USD <> `USD
    ensure -> not? `EUR <> `EUR
    passed
    
    ensure -> notEqual? `USD `EUR
    ensure -> notEqual? `EUR `USD
    ensure -> `EUR <> `USD
    passed
    
    
    topic « notEqual? - incompatible types
    
    ; NOTES: 
    ; - to avoid repetition some tests may be not explicitly included
    ; - this test part tries to cover the most of possible behaviors,
    ;     including the possility of the Comparison module be rewritten, 
    ;     avoiding future broken changes
    ; - some combinations were not made, because it's considered very
    ;     improbable to happen, even with a future rewrite of 
    ;     the Comparison module
    
    ; for :integer
    
    ensure -> every? @[
        -> notEqual? 1 1
    ] => not?
    
    ensure -> not? every? @[
        -> notEqual? 1 null         -> notEqual? 1 true
        -> notEqual? 1 false        -> notEqual? 1 to :complex [1 1]
        -> notEqual? 1 1.0.0        -> notEqual? 1 :integer
        -> notEqual? 1 '1'          -> notEqual? 1 "1"
        -> notEqual? [1] [one]      -> notEqual? [1] [one:]
        -> notEqual? [1 1] [one: 1] -> notEqual? 1 '1
        -> notEqual? [1] [.1]       -> notEqual? [1] [.1:]
        -> notEqual? [1 1] [.1` 1]  -> notEqual? [1] [one\1]
        -> notEqual? [1] [one\1:]   -> notEqual? [1 1] [one\1` 1]
        -> notEqual? [1] [+]        -> notEqual? 1 {/1/}
        -> notEqual? 1 to :binary 1 -> notEqual? 1 to :binary 1
        -> notEqual? [1] [(1)]      -> notEqual? 1 [1]
        -> notEqual? 1 1..1         -> notEqual? 1 #[one: 1]
        -> notEqual? 0 #black       -> notEqual? 1 var 'one?
    ] => not? passed
    
    ; for :floating
    ensure -> not? every? @[
        -> notEqual? 1.0 null               -> notEqual? 1.0 true
        -> notEqual? 1.0 false              -> notEqual? 1.0 to :complex [1.0 1.0]
        -> notEqual? 1.0 1.0.0              -> notEqual? 1.0 :floating
        -> notEqual? 1.0 '1'                -> notEqual? 1.0 "1.0"
        -> notEqual? [1.0] [one]            -> notEqual? 1.0 '1
        -> notEqual? [1.0] [.1]             -> notEqual? [1.0] [.1:]
        -> notEqual? [1.0] [one\1]          -> notEqual? [1.0] [one\1:]         
        -> notEqual? [1.0] [+]              -> notEqual? 1.0 {/1.0/}
        -> notEqual? 1.0 to :binary 1.0     -> notEqual? 1.0 to :binary 1.0
        -> notEqual? [1.0] [(1.0)]          -> notEqual? 1.0 [1]
        -> notEqual? 1.0 1..1               -> notEqual? 1.0 #[one: 1.0]
        -> notEqual? 0.0 #black             -> notEqual? 1.0 var 'one?
    ] => not? passed
    
    ; for :rational
    a: to :rational [1 1]
    ensure -> not? every? @[
        -> notEqual? a null                     -> notEqual? a true
        -> notEqual? a false                    -> notEqual? a to :complex [1 1]
        -> notEqual? a 1.0.0                    -> notEqual? a :rational
        -> notEqual? a '1'                      -> notEqual? a "1/1"
        -> notEqual? @[a] [one]                 -> notEqual? @[a] [one:]
        -> notEqual? 1 '1                       -> notEqual? @[a] [.1]                  
        -> notEqual? @[a] [.1:]                 -> notEqual? @[a] [one\1]
        -> notEqual? @[a] [+]                   -> notEqual? a {/1/1/}
        -> notEqual? a to :binary 1             -> notEqual? a to :binary 1
        -> notEqual? @[a] [(1)]                 -> notEqual? a [1]
        -> notEqual? a 1..1                     -> notEqual? a #[one: 1]
        -> notEqual? to :rational [1 1] #black  -> notEqual? a var 'one?
    ] => not? passed
    
    ; for :quantity
    ensure -> not? every? @[
        -> notEqual? 1`usd null             -> notEqual? 1`usd true
        -> notEqual? 1`usd false            -> notEqual? 1`usd to :complex [1 1]
        -> notEqual? 1`usd 1.0.0            -> notEqual? 1`usd :quantity
        -> notEqual? 1`usd '1'              -> notEqual? 1`usd "1USD"
        -> notEqual? [1`usd] [one]          -> notEqual? [1`usd] [one:]
        -> notEqual? 1`usd '1               -> notEqual? [1`usd] [.1]                  
        -> notEqual? [1`usd] [.1:]          -> notEqual? [1`usd] [one\1]
        -> notEqual? [1`usd] [one\1:]       -> notEqual? [1`usd] [+]                   
        -> notEqual? 1`usd {/1USD/}         -> notEqual? 1`usd to :binary 1            
        -> notEqual? 1`usd to :binary 1     -> notEqual? [1`usd] [(1)]                 
        -> notEqual? 1`usd [1`usd]          -> notEqual? 1`usd 1..1                    
        -> notEqual? 1`usd #[one: 1`usd]    -> notEqual? 0`usd #black                  
        -> notEqual? 1`usd var 'one?
    ] => not? passed
    
    ensure -> not? every? @[ 
        -> notEqual? 1`m null           -> notEqual? 1`m true
        -> notEqual? 1`m false          -> notEqual? 1`m to :complex [1 1]
        -> notEqual? 1`m 1.0.0          -> notEqual? 1`m :quantity
        -> notEqual? 1`m '1'            -> notEqual? 1`m "1m"
        -> notEqual? [1`m] [one]        -> notEqual? [1`m] [one:]
        -> notEqual? 1`m '1             -> notEqual? [1`m] [.1]            
        -> notEqual? [1`m] [.1` 1`m]    -> notEqual? [1`m] [one\1]
        -> notEqual? [1`m] [one\1:]     -> notEqual? [1`m] [+]              
        -> notEqual? 1`m {/1m/}         -> notEqual? 1`m to :binary 1       
        -> notEqual? 1`m to :binary 1   -> notEqual? [1`m] [(1)]            
        -> notEqual? 1`m [1`m]          -> notEqual? 1`m 1..1               
        -> notEqual? 1`m #[one: 1`m]    -> notEqual? 0`m #black             
        -> notEqual? 1`m var 'one?
    ] => not? passed
    
    ensure -> not? every? @[ 
        -> notEqual? 1`m3 null                  -> notEqual? 1`m3 true
        -> notEqual? 1`m3 false                 -> notEqual? 1`m3 to :complex [1 1]
        -> notEqual? 1`m3 1.0.0                 -> notEqual? 1`m3 :quantity
        -> notEqual? 1`m3 '1'                   -> notEqual? 1`m3 "1m³"
        -> notEqual? [1`m3] [one]               -> notEqual? [1`m3] [one:]
        -> notEqual? 1`m3 '1                    -> notEqual? [1`m3] [.1]               
        -> notEqual? [1`m3] [.1:]               -> notEqual? [1`m3] [one\1]
        -> notEqual? [1`m3] [one\1:]            -> notEqual? [1`m3] [+]                
        -> notEqual? 1`m3 {/1m³/}               -> notEqual? 1`m3 to :binary 1         
        -> notEqual? 1`m3 to :binary 1          -> notEqual? [1`m3] [(1)]              
        -> notEqual? 1`m3 [1`m3]                -> notEqual? 1`m3 1..1                 
        -> notEqual? 1`m3 #[one: 1`m3]          -> notEqual? 0`m3 #black               
        -> notEqual? 1`m3 var 'one?
    ] => not? passed
    
    ensure -> not? every? @[ 
        -> notEqual? 1`c null              -> notEqual? 1`c true
        -> notEqual? 1`c false             -> notEqual? 1`c to :complex [1 1]
        -> notEqual? 1`c 1.0.0             -> notEqual? 1`c :quantity
        -> notEqual? 1`c '1'               -> notEqual? 1`c "1°C"
        -> notEqual? [1`c] [one]           -> notEqual? [1`c] [one:]
        -> notEqual? 1`c '1.0i             -> notEqual? [1`c] [.1]            
        -> notEqual? [1`c] [.1:]           -> notEqual? [1`c] [one\1]         
        -> notEqual? [1`c] [one\1:]        -> notEqual? [1`c] [+]             
        -> notEqual? 1`c {/1°C/}           -> notEqual? 1`c to :binary 1      
        -> notEqual? 1`c to :binary 1      -> notEqual? [1`c] [(1)]           
        -> notEqual? 1`c [1`c]             -> notEqual? 1`c 1..1              
        -> notEqual? 1`c #[one: 1`c]       -> notEqual? 0`c #black            
        -> notEqual? 1`c var 'one?
    ] => not? passed
    
    ; for :null
    ensure -> not? every? @[
        -> notEqual? null 0                         -> notEqual? null 0.0            
        -> notEqual? null to :rational [1 1]        -> notEqual? null true
        -> notEqual? null false                     -> notEqual? null to :complex [0 0]
        -> notEqual? null 0.0.0                     -> notEqual? null :null
        -> notEqual? null 'ø'                       -> notEqual? null "null"
        -> notEqual? @[null] [null]                 -> notEqual? @[null] [null:]
        -> notEqual? null 'null                     -> notEqual? @[null] [.null]               
        -> notEqual? @[null] [.null:]               -> notEqual? @[null] [null\null]
        -> notEqual? @[null] [null\null:]           -> notEqual? @[null] [ø]                   
        -> notEqual? null {/null/}                  -> notEqual? null {/ø/}                    
        -> notEqual? null to :binary 0              -> notEqual? null to :binary 0             
        -> notEqual? @[null] [(null)]               -> notEqual? null [null]                   
        -> notEqual? null 0..0                      -> notEqual? null #[null: null]            
        -> notEqual? null #black                    -> notEqual? null var 'null?
    ] => not? passed
    
    ; for :logical
    ensure -> not? every? @[
        -> notEqual? true 0                     -> notEqual? true 0.0            
        -> notEqual? true to :rational [1 1]    -> notEqual? true to :complex [1 1]
        -> notEqual? true 0.0.0                 -> notEqual? true :true
        -> notEqual? true '0'                   -> notEqual? true "true"
        -> notEqual? @[true] [true]             -> notEqual? true 'true
        -> notEqual? @[true] [.true]            -> notEqual? @[true] [.true:]
        -> notEqual? @[true] [true\true]        -> notEqual? @[true] [true\true:]       
        -> notEqual? @[true] [ø]                -> notEqual? true {/true/}
        -> notEqual? true to :binary 0          -> notEqual? true to :binary 0             
        -> notEqual? @[true] [(true)]           -> notEqual? true [true]                   
        -> notEqual? true 0..0                  -> notEqual? true #[true: true]            
        -> notEqual? true #black                -> notEqual? true var 'true?
    ] => not? passed
    
    ensure -> not? every? @[
        -> notEqual? false 0                        -> notEqual? false 0.0            
        -> notEqual? false to :rational [1 1]       -> notEqual? false to :complex [1 1]
        -> notEqual? false 0.0.0                    -> notEqual? false :false
        -> notEqual? false '0'                      -> notEqual? false "false"
        -> notEqual? @[false] [false]               -> notEqual? @[false] [false:]
        -> notEqual? false 'false                   -> notEqual? @[false] [.false]              
        -> notEqual? @[false] [.false:]             -> notEqual? @[false] [false\false]
        -> notEqual? @[false] [false\false:]        -> notEqual? @[false] [ø]                   
        -> notEqual? false {/false/}                -> notEqual? false to :binary 0             
        -> notEqual? false to :binary 0             -> notEqual? @[false] [(false)]             
        -> notEqual? false [false]                  -> notEqual? false 0..0                     
        -> notEqual? false #[false: false]          -> notEqual? false #black                   
        -> notEqual? false var 'false?
    ] => not? passed
    
    ensure -> not? every? @[
        -> notEqual? maybe 0                        -> notEqual? maybe 0.0            
        -> notEqual? maybe to :rational [1 1]       -> notEqual? maybe to :complex [1 1]
        -> notEqual? maybe 0.0.0                    -> notEqual? maybe :maybe
        -> notEqual? maybe '0'                      -> notEqual? maybe "maybe"
        -> notEqual? @[maybe] [maybe]               -> notEqual? @[maybe] [maybe:]
        -> notEqual? maybe 'maybe                   -> notEqual? @[maybe] [.maybe]              
        -> notEqual? @[maybe] [.maybe:]             -> notEqual? @[maybe] [maybe\maybe]
        -> notEqual? @[maybe] [maybe\maybe:]        -> notEqual? @[maybe] [ø]                   
        -> notEqual? maybe {/maybe/}                -> notEqual? maybe to :binary 0             
        -> notEqual? maybe to :binary 0             -> notEqual? @[maybe] [(maybe)]             
        -> notEqual? maybe [maybe]                  -> notEqual? maybe 0..0                     
        -> notEqual? maybe #[maybe: maybe]          -> notEqual? maybe #black                   
    ] => not? passed
    
    ; for :complex
    a: to :complex [1 1]
    ensure -> not? every? @[
        -> notEqual? a 1                        -> notEqual? a 1.0            
        -> notEqual? a to :rational [1 1]       -> notEqual? a null                    
        -> notEqual? a true                     -> notEqual? a false
        -> notEqual? a 1.0.0                    -> notEqual? a :rational
        -> notEqual? a '1'                      -> notEqual? a "1.0+1.0i"
        -> notEqual? @[a] [one]                 -> notEqual? @[a] [one:]
        -> notEqual? 1 '1                       -> notEqual? @[a] [.1]                  
        -> notEqual? @[a] [.1:]                 -> notEqual? @[a] [one\1]
        -> notEqual? @[a] [one\1:]              -> notEqual? @[a] [+]                   
        -> notEqual? a {/1.0+1.0i/}             -> notEqual? a to :binary 1             
        -> notEqual? a to :binary 1             -> notEqual? @[a] [(1)]                 
        -> notEqual? a [1]                      -> notEqual? a 1..1                     
        -> notEqual? a #[one: 1]                -> notEqual? to :complex [0 0] #black   
        -> notEqual? a var 'one?
    ] => not? passed
    
    ; for :version
    ensure -> not? every? @[
        -> notEqual? 1.0.0 1                        -> notEqual? 1.0.0 1.0          
        -> notEqual? 1.0.0 to :rational [1 1]       -> notEqual? 1.0.0 null                    
        -> notEqual? 1.0.0 true                     -> notEqual? 1.0.0 false                   
        -> notEqual? 1.0.0 to :complex [1.0 1.0]    -> notEqual? 1.0.0 :floating
        -> notEqual? 1.0.0 '1'                      -> notEqual? 1.0.0 "1.0.0"
        -> notEqual? [1.0.0] [one]                  -> notEqual? [1.0.0] [one:]
        -> notEqual? 1.0.0 '1                       -> notEqual? [1.0.0] [.1]                   
        -> notEqual? [1.0.0] [.1:]                  -> notEqual? [1.0.0] [one\1]                
        -> notEqual? [1.0.0] [one\1:]               -> notEqual? [1.0.0] [+]                    
        -> notEqual? 1.0.0 {/1.0.0/}                -> notEqual? 1.0.0 to :binary 1.0           
        -> notEqual? 1.0.0 to :binary 1.0           -> notEqual? [1.0.0] [(1.0.0)]              
        -> notEqual? 1.0.0 [1.0.0]                  -> notEqual? 1.0.0 1..1                     
        -> notEqual? 1.0.0 #[one: 1.0.0]            -> notEqual? 0.0.0 #black                   
        -> notEqual? 1.0.0 var 'version?
    ] => not? passed
    
    ; for :type
    ensure -> not? every? @[
        -> notEqual? :1 1                              -> notEqual? :1 1.0          
        -> notEqual? :integer 1                        -> notEqual? :floating 1.0          
        -> notEqual? :rational to :rational [1 1]      -> notEqual? :null null                    
        -> notEqual? :true true                        -> notEqual? :false false                   
        -> notEqual? :logical false                    -> notEqual? :complex to :complex [1 1]   
        -> notEqual? :version 1.0.0                    -> notEqual? :T 'T'                         
        -> notEqual? :char 'T'                         -> notEqual? :string ":type"
        -> notEqual? [:type] [type]                    -> notEqual? [:word] [word]                     
        -> notEqual? [:type] [type:]                   -> notEqual? [:label] [label:]
        -> notEqual? :1 '1                             -> notEqual? :literal '1                       
        -> notEqual? [:type] [.type]                   -> notEqual? [:attribute] [.type]              
        -> notEqual? [:type] [.type:]                  -> notEqual? [:attributelabel] [.type:]             
        -> notEqual? [:type] [type\type]               -> notEqual? [:path] [type\type]
        -> notEqual? [:type] [type\type:]              -> notEqual? [:pathLabel] [type\type:]            
        -> notEqual? [:type] [+]                       -> notEqual? [:symbol] [+]                     
        -> notEqual? :type {/:type/}                   -> notEqual? :regex {/:type/}                  
        -> notEqual? :type to :binary 1.0              -> notEqual? :binary to :binary 1.0            
        -> notEqual? [:type] [(:type)]                 -> notEqual? [:inline] [(:type)]               
        -> notEqual? :type [:type]                     -> notEqual? :block [:type]                    
        -> notEqual? :type 1..1                        -> notEqual? :range 1..1                       
        -> notEqual? :type #[type: :type]              -> notEqual? :dictionary #[type: :type]        
        -> notEqual? :type #black                      -> notEqual? :color #black                     
        -> notEqual? :type var 'type?                  -> notEqual? :function var 'one?
    ] => not? passed
    
    ; for :char
    ensure -> not? every? @[
        -> notEqual? '1' 1.0          
        -> notEqual? '1' to :rational [1 1]    -> notEqual? 'ø' null                    
        -> notEqual? 't' true                  -> notEqual? 'f' false                   
        -> notEqual? '1' to :complex [1.0 1.0] -> notEqual? 'T' :floating
        -> notEqual? ['a'] [one]               -> notEqual? ['a'] [a: 'a']
        -> notEqual? 'a' 'a                    -> notEqual? ['a'] [.1]                
        -> notEqual? ['a'] [.a:]               -> notEqual? ['a'] [a\a]
        -> notEqual? ['a'] [a\a:]              -> notEqual? ['+'] [+]                 
        -> notEqual? 'a' {/a/}                 -> notEqual? '1' to :binary 1          
        -> notEqual? 'a' to :binary 1          -> notEqual? ['1'] [('1')]             
        -> notEqual? 'a' ['a']                 -> notEqual? '1' 1..1                  
        -> notEqual? 'a' #[a: 'a']             -> notEqual? '1' #black                
        -> notEqual? 'a' var 'char?
    ] => not? passed
    
    ; for :string
    ensure -> not? every? @[
        -> notEqual? "1" 1                             -> notEqual? "1/1" to :rational [1 1]          
        -> notEqual? "1.0" 1.0                         -> notEqual? "null" null                    
        -> notEqual? "" null                           -> notEqual? "true" true                  
        -> notEqual? "" false                          -> notEqual? "false" false                   
        -> notEqual? "1.0+1.0i" to :complex [1.0 1.0]  -> notEqual? "type" :floating
        -> notEqual? "floating" :floating              -> notEqual? ":floating" :floating
        -> notEqual? "1.0" :floating                   -> notEqual? ["a"] [a\a]
        -> notEqual? ["a"] [a\a:]                      -> notEqual? ["+"] [+]                         
        -> notEqual? "a" {/a/}                         -> notEqual? "01" to :binary 1                 
        -> notEqual? "1" to :binary 1                  -> notEqual? [""] [("")]                       
        -> notEqual? "" [""]                           -> notEqual? "1" 1..1                          
        -> notEqual? "a" #[a: "a"]                     -> notEqual? "#000000" #black                  
        -> notEqual? "000000" #black              
        -> notEqual? "" var 'char?
    ] => not? passed
    
    ; for :word
    ensure -> not? every? @[        
        -> notEqual? [rational] @[to :rational [1 1]]      -> notEqual? [null]  @[null]                    
        -> notEqual? [true]     @[true]                    -> notEqual? [false] @[false]                   
        -> notEqual? [complex]  @[to :complex [1.0 1.0]]   -> notEqual? [type]  @[:floating]  
        -> notEqual? [floating] @[:floating]               -> notEqual? [a]     [a\a]                   
        -> notEqual? [a]         [a\a:]                    -> notEqual? [a]     [{/a/}]                      
        -> notEqual? [binary]   @[to :binary 1]            -> notEqual? [one]   @[to :binary 1]              
        -> notEqual? [word]     [(word)]                   -> notEqual? [word]  [[word]]                      
        -> notEqual? [range]    @[range 1 1]               -> notEqual? [a]     @[#[a: 'a']]               
        -> notEqual? [black]    @[#black ]                 -> notEqual? [word]  @[var 'word?]              
        -> notEqual? [var]      @[var 'word?]
    ] => not? passed
    
    ; for :label
    ensure -> not? every? @[
        -> notEqual? [rational:] @[to :rational [1 1]]      -> notEqual? [null:]     @[null]                                                        
        -> notEqual? [true:]     @[true]                    -> notEqual? [false:]    @[false]                   
        -> notEqual? [complex:]  @[to :complex [1.0 1.0]]   -> notEqual? [floating:]  [:floating]
        -> notEqual? [type:]      [:floating]               -> notEqual? [a:]         [a\a]                     
        -> notEqual? [a:]         [a\a:]                    -> notEqual? [a:]         [{/a:/}]                 
        -> notEqual? [binary:]   @[to :binary 1]            -> notEqual? [word:]      [(word:)]                
        -> notEqual? [label:]     [[label:]]                -> notEqual? [a:]        @[#[a: 'a']]               
        -> notEqual? [black:]     [#black ]                 -> notEqual? [var:]      @[var 'word?]
        -> notEqual? [word:]     @[var 'word?]
    ] => not? passed
    
    ; for :literal
    ; NOTE: technically, '+ is not a :literal, but a :symbolLiteral type ;)
    ensure -> not? every? @[
        -> notEqual? 'integer  1                   -> notEqual? 'floating 1.0
        -> notEqual? 'rational to :rational [1 1]  -> notEqual? 'one      to :rational [1 1]
        -> notEqual? 'null     null                -> notEqual? 'true     true    
        -> notEqual? 'false    false               -> notEqual? 'complex  to :complex [1.0 1.0]    
        -> notEqual? 'type     :floating           -> notEqual? 'floating :floating               
        -> notEqual? ['a]      [a\a]               -> notEqual? ['+]      [+]                       
        -> notEqual? 'a        {/a/}               -> notEqual? 'binary   to :binary 1            
        -> notEqual? ['word]   [('word)]           -> notEqual? 'word     ['word]                                     
        -> notEqual? 'range    1..1                -> notEqual? 'a        #[a: 'a]                
        -> notEqual? 'black    #black              -> notEqual? 'word?    var 'word?              
        -> notEqual? 'var      var 'var
    ] => not? passed
    
    ; for :attribute
    ensure -> not? every? @[           
        -> notEqual? [.rational] @[to :rational [1 1]]      -> notEqual? [.null]     @[null]                  
        -> notEqual? [.true]     @[true]                    -> notEqual? [.false]    @[false]                 
        -> notEqual? [.complex]  @[to :complex [1.0 1.0]]   -> notEqual? [.floating] @[:floating]                          
        -> notEqual? [.a]        @[{/a:/}]                  -> notEqual? [.binary]   @[to :binary 1]          
        -> notEqual? [.word]      [(.word)]                 -> notEqual? [.label]    @[[.label]]                               
        -> notEqual? [.a]        @[#[a: 'a']]               -> notEqual? [.black]    @[#black]                
        -> notEqual? [.var]      @[var 'word?]              -> notEqual? [.word]     @[var 'word?]
    ] => not? passed
    
    ; for :attributelabel
    ensure -> not? every? @[           
        -> notEqual? [.rational:] @[to :rational [1 1]]    -> notEqual? [.null:]     @[null]                  
        -> notEqual? [.true:]     @[true]                  -> notEqual? [.false:]    @[false]                 
        -> notEqual? [.complex:]  @[to :complex [1.0 1.0]] -> notEqual? [.floating:]  [:floating]             
        -> notEqual? [.a:]         [a\a]                   -> notEqual? [.a: 'a']     [a\a: 'a']              
        -> notEqual? [.plus:]      [+]                     -> notEqual? [.a:]        @[{/a:/}]                
        -> notEqual? [.binary:]   @[to :binary 1]          -> notEqual? [.word:]      [(.word:)]               
        -> notEqual? [.label:]    @[[label:]]              -> notEqual? [.a:]        @[#[a: 'a']]             
        -> notEqual? [.black:]     [#black]                -> notEqual? [.var:]      @[var 'word?]            
        -> notEqual? [.word:]     @[var 'word?]
    ] => not? passed
    
    ; for :path & :pathLabel
    ensure -> not? every? @[
        -> notEqual? [a\b:] [a\b]
        -> notEqual? [a\b] [a\b:]
    ] => not? passed
    
    ; for :regex
    ensure -> not? every? @[
        -> notEqual? {/1/} 1                               -> notEqual? {/1/1/} to :rational [1 1]          
        -> notEqual? {/1.0/} 1.0                           -> notEqual? {/null/} null                    
        -> notEqual? {//} null                             -> notEqual? {/true/} true                  
        -> notEqual? {//} false                            -> notEqual? {/false/} false                   
        -> notEqual? {/1.0+1.0i/} to :complex [1.0 1.0]    -> notEqual? {/type/} :floating
        -> notEqual? {/floating/} :floating                -> notEqual? {/:floating/} :floating
        -> notEqual? {/1.0/} :floating                     -> notEqual? [{/a/}] [a\a]
        -> notEqual? [{/a/}] [a\a:]                        
        -> notEqual? [{/\+/}] [+]                          -> notEqual? {/01/} to :binary 1                 
        -> notEqual? {/1/} to :binary 1                    -> notEqual? [{//}] [({//})]                     
        -> notEqual? {//} [""]                             -> notEqual? {/1/} 1..1                          
        -> notEqual? {/a/} #[a: "a"]                       -> notEqual? {/#000000/} #black                  
        -> notEqual? {/000000/} #black                     -> notEqual? {/var/} var 'regex?
        -> notEqual? {/regex?/} var 'regex?
    ] => not? passed
    
    ; for :binary
    ensure -> not? every? @[
        -> notEqual? to :binary 1 1                    -> notEqual? to :binary 1 1.0                
        -> notEqual? to :binary 1 to :rational [1 1]   -> notEqual? to :binary 1 1`usd                
        -> notEqual? to :binary 1 1`m                  -> notEqual? to :binary 1 1`m3                 
        -> notEqual? to :binary 1 1`c                  -> notEqual? to :binary 0 null                 
        -> notEqual? to :binary 0 true                 -> notEqual? to :binary 0 false                
        -> notEqual? to :binary 0 maybe                -> notEqual? to :binary 1 to :complex [1 1]                  
        -> notEqual? to :binary 1 1.0.0                -> notEqual? to :binary 1 :type              
        -> notEqual? to :binary 1 :binary              -> notEqual? to :binary 1 '1'                  
        -> notEqual? to :binary "a" 'a'                -> notEqual? to :binary 1 "01"                 
        -> notEqual? to :binary 1 "1"                  -> notEqual? @[to :binary 1] [binary]          
        -> notEqual? @[to :binary 1] [one]             -> notEqual? @[to :binary 1] [binary:]         
        -> notEqual? @[to :binary 1][.binary]          -> notEqual? @[to :binary 1] [.binary:]        
        -> notEqual? to :binary 1 {/01/}               -> notEqual? to :binary 1    {/1/}
    ] => not? passed
    
    ; for :range
    ensure -> not? every? @[
        -> notEqual? 1..1 1                        -> notEqual? 1..1 1.0
        -> notEqual? 1..1 a: to :rational [1 1]    -> notEqual? 1..1 1`usd
        -> notEqual? 1..1 1`m                      -> notEqual? 1..1 1`m3  
        -> notEqual? 1..1 1`c                      -> notEqual? 0..0 null 
        -> notEqual? 0..0 true                     -> notEqual? 0..0 false
        -> notEqual? 0..0 maybe                    -> notEqual? 1..1 to :complex [1 1]
        -> notEqual? 1..1 1.0.0                    -> notEqual? 1..1 :type                        
        -> notEqual? 1..1 :range                   -> notEqual? 1..1 '1' 
        -> notEqual? 1..1 "1"                      -> notEqual? 1..1 'range  
        -> notEqual? 1..1 {/1/}
    ] => not? passed
    
    ; for :dictionary, :object & :date
    define :person [name surname]
    
    a: to :person ["Walter" "Pinkman"]
    b: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    
    ensure -> not? every? @[
        -> notEqual? #[name: "Walter" surname: "Pinkman"] a
        -> notEqual? a #[name: "Walter" surname: "Pinkman"]
        -> notEqual? #[year: 2023 day: 15 Month: "January"] b
        -> notEqual? b #[year: 2023 day: 15 Month: "January"]
    ] => not? passed
    
    ; for :color
    ensure -> not? every? @[
        -> notEqual? #black 0                  -> notEqual? #black 0.0
        -> notEqual? #black to :rational [1 1] -> notEqual? #black 0`usd 
        -> notEqual? #black 0`m                -> notEqual? #black 0`m3
        -> notEqual? #black 0`c                -> notEqual? #black null 
        -> notEqual? #black true               -> notEqual? #black false 
        -> notEqual? #black maybe              -> notEqual? #black to :complex [0 0]
        -> notEqual? #black 0.0.0              -> notEqual? #black :color
        -> notEqual? #black '1'                -> notEqual? #black "#000000"
        -> notEqual? #black "000000"           -> notEqual? [#black] [black] 
        -> notEqual? #black 'black             -> notEqual? [#black] [.black]
        -> notEqual? [#black] [.black:]        -> notEqual? #black  {/#000000/}                 
        -> notEqual? #black{/000000/} 
    ] => not? passed
    
    ; for :function
    ensure -> not? every? @[
        -> notEqual? var 'null?     null       -> notEqual? var 'true?    true  
        -> notEqual? var 'false?    false
        -> notEqual? var 'version?  1.0.0      -> notEqual? var 'type?    :type 
        -> notEqual? var 'function? :function  -> notEqual? var 'char?    'a' 
        -> notEqual? @[var 'word?]  [word]     -> notEqual? @[var 'word?] [var]      
        -> notEqual? @[var 'word?]  [var:]     -> notEqual? @[var 'word?] [word:]    
        -> notEqual? var 'word?     'word?     -> notEqual? var 'var      'var       
        -> notEqual? @[var 'word?]  [.var]     -> notEqual? @[var 'word?] [.word]    
        -> notEqual? @[var 'word?]  [.var:]    -> notEqual? @[var 'word?] [.word:]   
        -> notEqual? var 'regex?    {/var/}    -> notEqual? var 'regex?   {/regex?/} 
    ] => not? passed  
    
]

topic « same?
do [
    
    
    topic « same? - :integer :floating :rational
    
    ensure -> same? 1 1
    passed
    
    ensure -> not? same? 1 2
    ensure -> not? same? 1 1.0
    ensure -> not? same? 1 to :rational @[1 1]
    ensure -> not? same? 1 to :rational @[5 5]
    passed
    
    ensure -> same? 1.0 1.0
    passed
    
    ensure -> not? same? 1.0 2.0
    ensure -> not? same? 1.0 2
    ensure -> not? same? 1.0 to :rational @[1 1]
    ensure -> not? same? 1.0 to :rational @[5 5]
    passed
    
    ensure -> same? to :rational @[5 5] to :rational @[1 1]
    passed
    
    ensure -> not? same? to :rational @[5 5] to :rational @[1 2]
    ensure -> not? same? to :rational @[5 5] 1
    ensure -> not? same? to :rational @[5 5] 1.0
    passed
    
    
    topic « same? - :quantity
    
    ensure -> same? 1`usd 1`usd
    ensure -> same? 1`m   1`m
    ensure -> same? 1`m2  1`m2
    ensure -> same? 1`m3  1`m3
    ; ensure -> same? 1`c   1`c
    ; ensure -> same? 1`f   1`f
    passed
    
    ensure -> not? same? 1`usd 1
    ensure -> not? same? 1`m   1
    ensure -> not? same? 1`m2  1
    ensure -> not? same? 1`m3  1
    ensure -> not? same? 1`c   1
    ensure -> not? same? 1`f   1
    passed
    
    ensure -> not? same? 1 1`usd
    ensure -> not? same? 1 1`m
    ensure -> not? same? 1 1`m2
    ensure -> not? same? 1 1`m3
    ensure -> not? same? 1 1`c
    ensure -> not? same? 1 1`f
    passed
    
    ensure -> not? same? 1`usd 1.0
    ensure -> not? same? 1`m   1.0
    ensure -> not? same? 1`m2  1.0
    ensure -> not? same? 1`m3  1.0
    ensure -> not? same? 1`c   1.0
    ensure -> not? same? 1`f   1.0
    passed
    
    ensure -> not? same? 1.0 1`usd
    ensure -> not? same? 1.0 1`m
    ensure -> not? same? 1.0 1`m2
    ensure -> not? same? 1.0 1`m3
    ensure -> not? same? 1.0 1`c
    ensure -> not? same? 1.0 1`f
    passed
    
    ensure -> not? same? 1`usd to :rational @[5 5]
    ensure -> not? same? 1`m   to :rational @[5 5]
    ensure -> not? same? 1`m2  to :rational @[5 5]
    ensure -> not? same? 1`m3  to :rational @[5 5]
    ensure -> not? same? 1`c   to :rational @[5 5]
    ensure -> not? same? 1`f   to :rational @[5 5]
    passed
    
    ensure -> not? same? to :rational @[5 5] 1`usd
    ensure -> not? same? to :rational @[5 5] 1`m
    ensure -> not? same? to :rational @[5 5] 1`m2
    ensure -> not? same? to :rational @[5 5] 1`m3
    ensure -> not? same? to :rational @[5 5] 1`c
    ensure -> not? same? to :rational @[5 5] 1`f
    passed
    
    ensure -> not? same? 2`usd 1
    ensure -> not? same? 2 1`usd
    ensure -> not? same? 2`usd 1.0
    ensure -> not? same? 2.0 1`usd
    ensure -> not? same? 2`usd to :rational @[5 5]
    ensure -> not? same? to :rational @[2 5] 1`usd
    passed
    
    ensure -> not? same? 1.5`m 150`cm 
    ensure -> not? same? 2`m 2`cm
    ensure -> not? same? 1`m 1`usd
    ensure -> not? same? 1`m 1`m2
    ensure -> not? same? 1`m 1`m3
    ensure -> not? same? 1`m 1`c
    ensure -> not? same? 1`m 1`f
    ensure -> not? same? 1`usd 1`m
    ensure -> not? same? 1`usd 1`m2
    ensure -> not? same? 1`usd 1`m3
    ensure -> not? same? 1`usd 1`c
    ensure -> not? same? 1`usd 1`f
    ensure -> not? same? 2`m2 2`cm
    ensure -> not? same? 1`m2 1`usd
    ensure -> not? same? 1`m2 1`m
    ensure -> not? same? 1`m2 1`m3
    ensure -> not? same? 1`m2 1`c
    ensure -> not? same? 1`m2 1`f
    ensure -> not? same? 1`c 1`usd
    ensure -> not? same? 1`c 1`m2
    ensure -> not? same? 1`c 1`m3
    ensure -> not? same? 1`c 1`m
    ensure -> not? same? 1`c 1`f
    ensure -> not? same? 1`f 1`usd
    ensure -> not? same? 1`f 1`m
    ensure -> not? same? 1`f 1`m3
    ensure -> not? same? 1`f 1`c
    ensure -> not? same? 1`f 1`m2
    passed
    
    
    topic « same? - :null
    
    ensure -> same? null null
    ensure -> same? null ø
    ensure -> same? ø ø
    ensure -> same? ø null
    passed
    
    ensure -> not? same? ø 1
    ensure -> not? same? ø 1.0
    ensure -> not? same? ø "ø"
    ensure -> not? same? ø 'ø'
    passed
    
    
    topic « same? - :logical
    
    ensure -> same? true true
    ensure -> same? true (1 > 0)
    ensure -> same? false false
    ensure -> same? false (1 < 0)
    ensure -> same? maybe maybe
    passed
    
    ensure -> not? same? true maybe
    ensure -> not? same? true false
    ensure -> not? same? false true
    ensure -> not? same? false maybe
    ensure -> not? same? maybe true
    ensure -> not? same? maybe false
    passed
    
    
    topic « same? - :complex
    
    ensure -> same? to :complex [0 2] to :complex [0 2]
    passed
    
    ; greater than
    ensure -> not? same? to :complex [2 2] to :complex [1 2] 
    ensure -> not? same? to :complex [2 3] to :complex [1 2]
    passed
    
    ; less than
    ensure -> not? same? to :complex [0 2] to :complex [1 2] 
    ensure -> not? same? to :complex [0 1] to :complex [1 2]
    passed
    
    
    topic « same? - :version
    
    ensure -> same? 1.2.3 1.2.3
    passed
    
    ensure -> not? same? 1.2.3 1.2.3-pre
    ensure -> not? same? 1.2.3 1.2.3-dev
    passed
    
    
    topic « same? - :type
    
    ensure -> same? :string type "a"
    ensure -> same? :integer type 1
    ensure -> same? :floating type 1.5
    passed
    
    ensure -> not? same? :string :integer
    ensure -> not? same? :string :char
    ensure -> not? same? :integer :floating
    passed
    
    
    topic « same? - :char
    
    ensure -> same? 'a' 'a'
    passed
    
    ensure -> not? same? 'a' "a" 
    ensure -> not? same? 'a' 'b'
    ensure -> not? same? '1' 1
    ensure -> not? same? "a" 'a' 
    ensure -> not? same? 'b' 'a'
    ensure -> not? same? 1   '1'
    passed 
    
    
    topic « same? - :string
    
    ensure -> same? "Art" "Arturo" -- "uro"
    passed
    
    ensure -> not? same? "A" "B"
    ensure -> not? same? "Art" "Bob"
    passed
    
    ensure -> not? same? "a" 'a'
    ensure -> not? same? "a" 'a
    ensure -> not? same? "a" to :label "a"
    ensure -> not? same? "a" to :attribute "a"
    ensure -> not? same? "a" to :attributelabel "a"
    ensure -> not? same? "string" to :type "string"
    passed
    
    
    topic « same? - :word
    
    ensure -> same? to :word "a" to :word "a"
    ensure -> not? same? to :word "a" to :word "b"
    passed
    
    ensure -> not? same? to :word "a" "a"
    ensure -> not? same? to :word "a" 'a'
    ensure -> not? same? to :word "a" 'a
    ensure -> not? same? to :word "a" to :label "a"
    ensure -> not? same? to :word "a" to :attribute "a"
    ensure -> not? same? to :word "a" to :attributelabel "a"
    ensure -> not? same? to :word "word" to :type "word"
    passed
    
    
    topic « same? - :label
    
    ensure -> same? to :label "a" to :label "a"
    ensure -> not? same? to :label "a" to :label "b"
    passed
    
    ensure -> not? same? to :label "a" "a"
    ensure -> not? same? to :label "a" 'a'
    ensure -> not? same? to :label "a" 'a
    ensure -> not? same? to :label "a" to :word "a"
    ensure -> not? same? to :label "a" to :attribute "a"
    ensure -> not? same? to :label "a" to :attributelabel "a"
    ensure -> not? same? to :label "label" to :type "label"
    passed
    
    
    topic « same? - :literal
    
    ensure -> same? 'a 'a
    ensure -> not? same? 'a 'b
    passed
    
    ensure -> not? same? 'a "a"
    ensure -> not? same? 'a 'a'
    ensure -> not? same? 'a to :label "a"
    ensure -> not? same? 'a to :word "a"
    ensure -> not? same? 'a to :attribute "a"
    ensure -> not? same? 'a to :attributelabel "a"
    ensure -> not? same? to :literal "literal" to :type "literal"
    passed
    
    
    topic « same? - :attribute
    
    ensure -> same? to :attribute "a" to :attribute "a"
    ensure -> not? same? to :attribute "a" to :attribute "b"
    passed
    
    ensure -> not? same? to :attribute "a" "a"
    ensure -> not? same? to :attribute "a" 'a'
    ensure -> not? same? to :attribute "a" 'a
    ensure -> not? same? to :attribute "a" to :word "a"
    ensure -> not? same? to :attribute "a" to :label "a"
    ensure -> not? same? to :attribute "a" to :attributelabel "a"
    ensure -> not? same? to :attribute "label" to :type "label"
    passed
    
    
    topic « same? - :attributelabel
    
    ensure -> same? to :attributelabel "a" to :attributelabel "a"
    ensure -> not? same? to :attributelabel "a" to :attributelabel "b"
    passed
    
    ensure -> not? same? to :attributelabel "a" "a"
    ensure -> not? same? to :attributelabel "a" 'a'
    ensure -> not? same? to :attributelabel "a" 'a
    ensure -> not? same? to :attributelabel "a" to :word "a"
    ensure -> not? same? to :attributelabel "a" to :label "a"
    ensure -> not? same? to :attributelabel "a" to :attribute "a"
    ensure -> not? same? to :attributelabel "label" to :type "label"
    passed
    
    
    topic « same? - :path
    
    a: #[name: "John", surname: "Doe"]
    b: @["Joe" "Jane" "Jesse"]
    
    ensure -> same? a\name "John" 
    ensure -> same? a\surname "Doe" 
    ensure -> not? same? a\name "Jane" 
    ensure -> not? same? a\name 1
    passed
    
    ensure -> same? b\0 "Joe" 
    ensure -> same? b\1 "Jane" 
    ensure -> same? b\2 "Jesse" 
    ensure -> not? same? b\2 "Walter" 
    passed
    
    ensure -> same? [b\0] [b\0]
    ensure -> same? [a\name] [a\name]
    ensure -> not? same? [b\0] [b\1]
    ensure -> not? same? [a\name] [a\surname]
    passed
    
    
    topic « same? - :pathLabel
       
    ensure -> same? [a\name: "John"] [a\name: "John"]
    ensure -> not? same? [a\surname: "Doe"] [b\surname: "Doe" ]
    ensure -> not? same? [a\name: "John"] [b\name: "Jane"]
    ensure -> not? same? [a\name: "John"] [b\name: "John"]
    passed
    
    
    topic « same? - :symbol
    
    ensure -> same? to :symbol "+" to :symbol "+"
    ensure -> not? same? to :symbol "+" to :symbol "-"
    ensure -> not? same? to :symbol "+" "++"
    ensure -> not? same? to :symbol "+" '+'
    ensure -> not? same? to :symbol "+" {+}
    ensure -> not? same? to :symbol "+" "+"
    ensure -> not? same? to :symbol "+" to :word "plus"
    ensure -> not? same? to :symbol "+" '+
    passed
    
    
    topic « same? - :regex
    
    ensure -> regex? {/[A-Z]/}
    ensure -> same? {/[A-Z]/} {/[A-Z]/} 
    ensure -> not? same? {/[A-Z]/} {/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]/}
    ensure -> not? same? {/[A-Z]/} {[A-Z]}
    ensure -> not? same? {/[A-Z]/} "/[A-Z]/"
    passed
    
    
    topic « same? - :binary
    
    ensure -> same? "48 65 6C 6C 6F 20 77 6F 72 6C 64"
        ~{|to :binary "Hello world"|}
    ensure -> same? "00" ~{|to :binary 0|}
    ensure -> same? "01" ~{|to :binary 1|}
    ensure -> same? "0A" ~{|to :binary 10|}
    ensure -> same? "05" ~{|to :binary 5|}
    passed
    
    a: to :binary 0
    
    ensure -> not? same? a 0
    ensure -> not? same? "49 65 6C 6C 6F 20 77 6F 72 6C 64"
        ~{|to :binary "Hello world"|}
    passed
    
    
    topic « same? - :bytecode
    
    x: to :bytecode [["print"][1 112 155]]
    
    ensure -> same? x to :bytecode [["print"][1 112 155]]
    ensure -> not? same? x to :bytecode [["print"][2 112 155]]
    ensure -> not? same? x [["print"][2 112 155]]
    passed
    
    
    topic « same? - :inline
    
    a: [(1 + 1)], b: [(1 + 1)] 
    ensure -> same? a\0 b\0
    passed
    
    c: [(2 + 1)] 
    ensure -> not? same? a\0 c\0
    passed
    
    d: [(3 - 1)] 
    ensure -> not? same? a\0 d\0   ; even the calc (3-1) and (1+1) being 2, 
    passed                          ; they are different inlines 
                                    ; with the same result when evaluated
    
    
    e: [(1 + 2 - 1)]
    ensure -> not? same? a\0 e\0
    ensure -> not? same? a\0 2
    passed
    
    
    topic « same? - :block
    
    a: [1 + 1]
    ensure -> same? a [1 + 1]
    ensure -> not? same? a [2]
    ensure -> not? same? a 2
    ensure -> not? same? a [1 ++ 1]
    passed
    
    
    topic « same? - :range
    
    ensure -> same? [0 1 2 3 4 5] @0..5
    ensure -> same? [0 2 4] @0.. .step: 2 5
    ensure -> same? @range.step: 2 0 5 @range.step: 2 0 4
    ensure -> not? same? range.step: 2 0 5 range.step: 2 0 4
    passed
    
    
    topic « same? - :dictionary
    
    a: #[name: "Walter" surname: "Pinkman"]
    
    ensure -> same? a #[name: "Walter" surname: "Pinkman"]
    ensure -> not? same? a #[name: "Jesse" surname: "Pinkman"]
    ensure -> not? same? a #[name "Jesse" surname "Pinkman"]
    ensure -> not? same? a [name "Jesse" surname "Pinkman"]
    passed
    
    ensure -> same? a\name "Walter"
    ensure -> same? a\surname "Pinkman"
    ensure -> not? same? a\surname "White"
    passed
    
    
    topic « same? - :object
    
    define :person [  
        init: method [name, age][
            this\name: capitalize name
            this\age: age
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|"
        ] 
    ]
    
    define :student is :person [  
        init: method [name, age, id][
            this\name: capitalize name
            this\age: age
            this\id: id
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
        ]
    ]
    
    a: to :person ["Joe" 32]
    ensure -> same? a to :person ["Joe" 32]
    ensure -> not? same? to :person ["Joe" 32] #[name: "Joe" age: 32]
    ensure -> not? same? to :person ["Joe" 32] to :student ["Joe" 32 15]
    passed
    
    a\name: "Jane"
    ensure -> same? a to :person ["Jane" 32]
    passed
    
    define :person [  
        init: method [name, age][
            this\name: capitalize name
            this\age: age
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|"
        ]
        compare: method [that][
            if this\age > that\age -> return 1
            if this\age = that\age -> return 0
            if this\age < that\age -> return neg 1
        ]   
    ]
    
    define :student is :person [  
        init: method [name, age, id][
            this\name: capitalize name
            this\age: age
            this\id: id
        ]
        string: method [][
            render "NAME: |this\name|, AGE: |this\age|, ID: |this\id|"
        ]
    ]
    
    a: to :person ["John" 16]
    b: to :student ["Jane" 16 100]
    c: to :person ["John" 15]
    d: to :student ["Jane" 16 100]
    ensure -> same? a b
    ensure -> same? b a
    ensure -> not? same? c d
    ensure -> not? same? d c
    passed
    
    
    topic « same? - :store
    
    a: store "test.db"
    a\name: "John" a\surname: "Doe"
    b: store "test.db"
    b\name: "John" b\surname: "Doe"
    c: store "test2.db"
    c\name: "John" c\surname: "Doe"
    d: store "test3.db"
    d\name: "Jane" d\surname: "Doe"
    
    ensure -> same? a a
    ensure -> same? a b
    ensure -> same? b a
    passed
    
    ensure -> not? same? a c 
    ensure -> not? same? c a 
    ensure -> not? same? a d 
    ensure -> not? same? d a 
    ensure -> not? same? c d 
    ensure -> not? same? d c 
    passed
    
    
    topic « same? - :color
    
    ensure -> same? #000 #black
    ensure -> same? #fff #white
    ensure -> same? #white #white
    ensure -> not? same? #black #white
    ensure -> not? same? #white #black
    passed
    
    
    topic « same? - :function
    
    ensure -> same? var 'print var 'print
    ensure -> not? same? var 'inspect var 'print
    passed
    
    a: $[name surname][]
    A: $[name][]
    b: $[name][]
    c: $[name surname][]
    
    ensure -> same? ~"|var 'a|" ~"|$[name surname][]|"
    ensure -> same? ~"|var 'a|" ~"|var 'c|"
    ensure -> not? same? ~"|var 'a|" ~"|var 'A|"
    ensure -> not? same? ~"|var 'a|" ~"|var 'b|"
    passed
    
    
    topic « same? - :database
    ; todo: test this
    
    
    topic « same? - :date
    
    a: to :date .format: "MMM dd" "Jan 15"
    b: to :date .format: "MMM dd" "Jan 15"
    c: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    d: now
    
    ensure -> same? a b 
    ensure -> not? same? a c 
    ensure -> not? same? a d
    passed 
    
    ensure -> same? a\day c\day
    ensure -> same? a\month c\month
    ensure -> not? same? a\year c\year
    passed
    
    topic « same? - :unit
    
    ensure -> same? `USD `USD
    ensure -> same? `EUR `EUR
    passed
    
    ensure -> not? same? `USD `EUR
    ensure -> not? same? `EUR `USD
    passed
    
    
    topic « same? - incompatible types
    
    ; NOTES: 
    ; - to avoid repetition some tests may be not explicitly included
    ; - this test part tries to cover the most of possible behaviors,
    ;     including the possility of the Comparison module be rewritten, 
    ;     avoiding future broken changes
    ; - some combinations were not made, because it's considered very
    ;     improbable to happen, even with a future rewrite of 
    ;     the Comparison module
    
    
    ; for :integer
    ensure -> not? every? @[
        -> same? 1 1
    ] => not?
    
    ensure -> every? @[
        -> same? 1 null         -> same? 1 true
        -> same? 1 false        -> same? 1 to :complex [1 1]
        -> same? 1 1.0.0        -> same? 1 :integer
        -> same? 1 '1'          -> same? 1 "1"
        -> same? [1] [one]      -> same? [1] [one:]
        -> same? 1 '1           -> same? [1] [.1]         
        -> same? [1] [.1:]      -> same? [1] [one\1]
        -> same? [1] [one\1:]   -> same? [1] [+]        
        -> same? 1 {/1/}        -> same? 1 to :binary 1 
        -> same? 1 to :binary 1 -> same? [1] [(1)]      
        -> same? 1 [1]          -> same? 1 1..1         
        -> same? 1 #[one: 1]    -> same? 0 #black       
        -> same? 1 var 'one?
    ] => not? passed
    
    ; for :floating
    ensure -> every? @[
        -> same? 1.0 null               -> same? 1.0 true
        -> same? 1.0 false              -> same? 1.0 to :complex [1.0 1.0]
        -> same? 1.0 1.0.0              -> same? 1.0 :floating
        -> same? 1.0 '1'                -> same? 1.0 "1.0"
        -> same? [1.0] [one]            -> same? 1.0 '1                 
        -> same? [1.0] [.1]             -> same? [1.0] [.1:]            
        -> same? [1.0] [one\1]          -> same? [1.0] [one\1:]        
        -> same? [1.0] [+]              -> same? 1.0 {/1.0/}
        -> same? 1.0 to :binary 1.0     -> same? 1.0 to :binary 1.0
        -> same? [1.0] [(1.0)]          -> same? 1.0 [1]
        -> same? 1.0 1..1               -> same? 1.0 #[one: 1.0]
        -> same? 0.0 #black             -> same? 1.0 var 'one?
    ] => not? passed
    
    ; for :rational
    a: to :rational [1 1]
    ensure -> every? @[
        -> same? a null                     -> same? a true
        -> same? a false                    -> same? a to :complex [1 1]
        -> same? a 1.0.0                    -> same? a :rational
        -> same? a '1'                      -> same? a "1/1"
        -> same? @[a] [one]                 -> same? @[a] [one:]
        -> same? 1 '1                       -> same? @[a] [.1]                 
        -> same? @[a] [.1:]                 -> same? @[a] [one\1]
        -> same? @[a] [+]                   -> same? a {/1/1/}
        -> same? a to :binary 1             -> same? a to :binary 1
        -> same? @[a] [(1)]                 -> same? a [1]
        -> same? a 1..1                     -> same? a #[one: 1]
        -> same? to :rational [1 1] #black  -> same? a var 'one?
    ] => not? passed
    
    ; for :quantity
    ensure -> every? @[
        -> same? 1`usd null             -> same? 1`usd true
        -> same? 1`usd false            -> same? 1`usd to :complex [1 1]
        -> same? 1`usd 1.0.0            -> same? 1`usd :quantity
        -> same? 1`usd '1'              -> same? 1`usd "1USD"
        -> same? [1`usd] [one]          -> same? [1`usd] [one:]
        -> same? 1`usd '1               -> same? [1`usd] [.1]                  
        -> same? [1`usd] [.1:]          -> same? [1`usd] [one\1]
        -> same? [1`usd] [one\1:]       -> same? [1`usd] [+]        
        -> same? 1`usd {/1USD/}         -> same? 1`usd to :binary 1 
        -> same? 1`usd to :binary 1     -> same? [1`usd] [(1)]      
        -> same? 1`usd [1`usd]          -> same? 1`usd 1..1         
        -> same? 1`usd #[one: 1`usd]    -> same? 0`usd #black       
        -> same? 1`usd var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> same? 1`m null           -> same? 1`m true
        -> same? 1`m false          -> same? 1`m to :complex [1 1]
        -> same? 1`m 1.0.0          -> same? 1`m :quantity
        -> same? 1`m '1'            -> same? 1`m "1m"
        -> same? [1`m] [one]        -> same? [1`m] [one:]
        -> same? 1`m '1             -> same? [1`m] [.1]            
        -> same? [1`m] [one\1]      -> same? [1`m] [one\1:]        
        -> same? [1`m] [+]          -> same? 1`m {/1m/}
        -> same? 1`m to :binary 1   -> same? 1`m to :binary 1
        -> same? [1`m] [(1)]        -> same? 1`m [1`m]
        -> same? 1`m 1..1           -> same? 1`m #[one: 1`m]
        -> same? 0`m #black         -> same? 1`m var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> same? 1`m3 null              -> same? 1`m3 true
        -> same? 1`m3 false             -> same? 1`m3 to :complex [1 1]
        -> same? 1`m3 1.0.0             -> same? 1`m3 :quantity
        -> same? 1`m3 '1'               -> same? 1`m3 "1m³"
        -> same? [1`m3] [one]           -> same? [1`m3] [one:]
        -> same? 1`m3 '1                -> same? [1`m3] [.1]               
        -> same? [1`m3] [.1:]           -> same? [1`m3] [one\1]
        -> same? [1`m3] [one\1:]        -> same? [1`m3] [+]             
        -> same? 1`m3 {/1m³/}           -> same? 1`m3 to :binary 1      
        -> same? 1`m3 to :binary 1      -> same? [1`m3] [(1)]           
        -> same? 1`m3 [1`m3]            -> same? 1`m3 1..1              
        -> same? 1`m3 #[one: 1`m3]      -> same? 0`m3 #black            
        -> same? 1`m3 var 'one?
    ] => not? passed
    
    ensure -> every? @[ 
        -> same? 1`c null           -> same? 1`c true
        -> same? 1`c false          -> same? 1`c to :complex [1 1]
        -> same? 1`c 1.0.0          -> same? 1`c :quantity
        -> same? 1`c '1'            -> same? 1`c "1°C"
        -> same? [1`c] [one]        -> same? [1`c] [one:]
        -> same? 1`c '1             -> same? [1`c] [.1]            
        -> same? [1`c] [.1:]        -> same? [1`c] [one\1]
        -> same? [1`c] [one\1:]     -> same? [1`c] [+]          
        -> same? 1`c {/1°C/}        -> same? 1`c to :binary 1   
        -> same? 1`c to :binary 1   -> same? [1`c] [(1)]        
        -> same? 1`c [1`c]          -> same? 1`c 1..1           
        -> same? 1`c #[one: 1`c]    -> same? 0`c #black         
        -> same? 1`c var 'one?
    ] => not? passed
    
    ; for :null
    ensure -> every? @[
        -> same? null 0                     -> same? null 0.0            
        -> same? null to :rational [1 1]    -> same? null true
        -> same? null false                 -> same? null to :complex [0 0]
        -> same? null 0.0.0                 -> same? null :null
        -> same? null 'ø'                   -> same? null "null"
        -> same? @[null] [null]             -> same? @[null] [null:]
        -> same? null 'null                 -> same? @[null] [.null]               
        -> same? @[null] [.null:]           -> same? @[null] [null\null]
        -> same? @[null] [null\null:]       -> same? @[null] [ø]                   
        -> same? null {/null/}              -> same? null {/ø/}                    
        -> same? null to :binary 0          -> same? @[null] [(null)]         
        -> same? null [null]                -> same? null 0..0            
        -> same? null #[null: null]         -> same? null #black          
        -> same? null var 'null?
    ] => not? passed
    
    ; for :logical
    ensure -> every? @[
        -> same? true 0                        -> same? true 0.0            
        -> same? true to :rational [1 1]       -> same? true to :complex [0 0]
        -> same? true 0.0.0                    -> same? true :true
        -> same? true '0'                      -> same? true "true"
        -> same? @[true] [true]                -> same? true 'true
        -> same? @[true] [.true]               -> same? @[true] [.true:]
        -> same? @[true] [true\true]           -> same? @[true] [true\true:]          
        -> same? @[true] [ø]                   -> same? true {/true/}
        -> same? true to :binary 0             -> same? true to :binary 0             
        -> same? @[true] [(true)]              -> same? true [true]                   
        -> same? true 0..0                     -> same? true #[true: true]            
        -> same? true #black
    ] => not? passed
    
    ensure -> every? @[
        -> same? false 0                           -> same? false 0.0            
        -> same? false to :rational [1 1]          -> same? false to :complex [0 0]
        -> same? false 0.0.0                       -> same? false :false
        -> same? false '0'                         -> same? false "false"
        -> same? @[false] [false]                  -> same? @[false] [false:]
        -> same? false 'false                      -> same? @[false] [.false]                 
        -> same? @[false] [.false:]                -> same? @[false] [false\false]
        -> same? @[false] [false\false:]           -> same? @[false] [ø]                      
        -> same? false {/false/}                   -> same? false to :binary 0                
        -> same? false to :binary 0                -> same? @[false] [(false)]                
        -> same? false [false]                     -> same? false 0..0                        
        -> same? false #[false: false]             -> same? false #black
    ] => not? passed
    
    ensure -> every? @[
        -> same? maybe 0                           -> same? maybe 0.0            
        -> same? maybe to :rational [1 1]          -> same? maybe to :complex [0 0]
        -> same? maybe 0.0.0                       -> same? maybe :maybe
        -> same? maybe '0'                         -> same? maybe "maybe"
        -> same? @[maybe] [maybe]                  -> same? @[maybe] [maybe:]
        -> same? maybe 'maybe                      -> same? @[maybe] [.maybe]                
        -> same? @[maybe] [.maybe:]                -> same? @[maybe] [maybe\maybe]
        -> same? @[maybe] [maybe\maybe:]           -> same? @[maybe] [ø]                      
        -> same? maybe {/maybe/}                   -> same? maybe to :binary 0                
        -> same? maybe to :binary 0                -> same? @[maybe] [(maybe)]                
        -> same? maybe [maybe]                     -> same? maybe 0..0                        
        -> same? maybe #[maybe: maybe]             -> same? maybe #black                      
    ] => not? passed
    
    ; for :complex
    a: to :complex [1 1]
    ensure -> every? @[
        -> same? a 1                    -> same? a 1.0            
        -> same? a to :rational [1 1]   -> same? a null                    
        -> same? a true                 -> same? a false
        -> same? a 1.0.0                -> same? a :rational
        -> same? a '1'                  -> same? a "1.0+1.0i"
        -> same? @[a] [one]             -> same? @[a] [one:]
        -> same? 1 '1.0i                -> same? @[a] [.1]                 
        -> same? @[a] [.1:]             -> same? @[a] [one\1]
        -> same? @[a] [one\1:]          -> same? @[a] [+]                  
        -> same? a {/1.0+1.0i/}         -> same? a to :binary 1            
        -> same? a to :binary 1         -> same? @[a] [(1)]                
        -> same? a [1]                  -> same? a 1..1                    
        -> same? a #[one: 1]            -> same? to :complex [0 0] #black  
    ] => not? passed
    
    ; for :version
    ensure -> every? @[
        -> same? 1.0.0 1                       -> same? 1.0.0 1.0          
        -> same? 1.0.0 to :rational [1 1]      -> same? 1.0.0 null                    
        -> same? 1.0.0 true                    -> same? 1.0.0 false                   
        -> same? 1.0.0 to :complex [1.0 1.0]   -> same? 1.0.0 :floating
        -> same? 1.0.0 '1'                     -> same? 1.0.0 "1.0.0"
        -> same? [1.0.0] [one]                 -> same? [1.0.0] [one:]
        -> same? 1.0.0 '1.0i                   -> same? [1.0.0] [.1]                  
        -> same? [1.0.0] [.1:]                 -> same? [1.0.0] [one\1]
        -> same? [1.0.0] [one\1:]              -> same? [1.0.0 1.0.0] [one\1` 1.0.0]
        -> same? [1.0.0] [+]                   -> same? 1.0.0 {/1.0.0/}
        -> same? 1.0.0 to :binary 1.0          -> same? 1.0.0 to :binary 1.0
        -> same? [1.0.0] [(1.0.0)]             -> same? 1.0.0 [1.0.0]
        -> same? 1.0.0 1..1                    -> same? 1.0.0 #[one: 1.0.0]
        -> same? 0.0.0 #black                 
    ] => not? passed
    
    ; for :type
    ensure -> every? @[
        -> same? :1 1                           -> same? :1 1.0          
        -> same? :integer 1                     -> same? :floating 1.0          
        -> same? :rational to :rational [1 1]   -> same? :null null                    
        -> same? :true true                     -> same? :false false                   
        -> same? :logical false                 -> same? :complex to :complex [1 1]   
        -> same? :version 1.0.0                 -> same? :T 'T'                         
        -> same? :char 'T'                      -> same? :string ":type"
        -> same? [:type] [type]                 -> same? [:word] [word]                     
        -> same? [:type] [type:]                -> same? [:label] [label:]
        -> same? :1 '1                          -> same? :literal '1                       
        -> same? [:type] [.type]                -> same? [:attribute] [.type]              
        -> same? [:type] [.type:]               -> same? [:attributelabel] [.type:]                
        -> same? [:type] [type\type]            -> same? [:path] [type\type]
        -> same? [:type] [type\type:]           -> same? [:pathLabel] [type\type:]            
        -> same? [:type] [+]                    -> same? [:symbol] [+]                     
        -> same? :type {/:type/}                -> same? :regex {/:type/}                  
        -> same? :type to :binary 1.0           -> same? :binary to :binary 1.0            
        -> same? [:type] [(:type)]              -> same? [:inline] [(:type)]               
        -> same? :type [:type]                  -> same? :block [:type]                    
        -> same? :type 1..1                     -> same? :range 1..1                       
        -> same? :type #[type: :type]           -> same? :dictionary #[type: :type]        
        -> same? :type #black                   -> same? :color #black                     
        -> same? :type var 'type?               -> same? :function var 'one?
    ] => not? passed
    
    ; for :char
    ensure -> every? @[
        -> same? '1' 1.0          
        -> same? '1' to :rational [1 1]     -> same? 'ø' null                    
        -> same? 't' true                   -> same? 'f' false                   
        -> same? '1' to :complex [1.0 1.0]  -> same? 'T' :floating
        -> same? ['a'] [one]                -> same? 'a' 'a
        -> same? ['a'] [.1]                 -> same? ['a'] [.a:]
        -> same? ['a'] [a\a]                -> same? ['a'] [a\a:]              
        -> same? ['+'] [+]                  -> same? 'a' {/a/}
        -> same? '1' to :binary 1           -> same? 'a' to :binary 1
        -> same? ['1'] [('1')]              -> same? 'a' ['a']
        -> same? '1' 1..1                   -> same? 'a' #[a: 'a']
        -> same? '1' #black                 -> same? 'a' var 'char?
    ] => not? passed
    
    ; for :string
    ensure -> every? @[
        -> same? "1" 1                             -> same? "1/1" to :rational [1 1]          
        -> same? "1.0" 1.0                         -> same? "null" null                    
        -> same? "" null                           -> same? "true" true                  
        -> same? "" false                          -> same? "false" false                   
        -> same? "1.0+1.0i" to :complex [1.0 1.0]  -> same? "type" :floating
        -> same? "floating" :floating              -> same? ":floating" :floating
        -> same? "1.0" :floating                   -> same? ["a"] [a\a]
        -> same? ["a"] [a\a:]                      -> same? ["+"] [+]                         
        -> same? "a" {/a/}                         -> same? "01" to :binary 1                 
        -> same? "1" to :binary 1                  -> same? [""] [("")]                       
        -> same? "" [""]                           -> same? "1" 1..1                          
        -> same? "a" #[a: "a"]                     -> same? "#000000" #black                  
        -> same? "000000" #black              
        -> same? "" var 'char?
    ] => not? passed
    
    ; for :word
    ensure -> every? @[        
        -> same? [rational] @[to :rational [1 1]]      -> same? [null]  @[null]                    
        -> same? [true]     @[true]                    -> same? [false] @[false]                   
        -> same? [complex]  @[to :complex [1.0 1.0]]   -> same? [type]  @[:floating]  
        -> same? [floating] @[:floating]               -> same? [a]      [a\a]                   
        -> same? [a]         [a\a:]                    -> same? [a]     @[{/a/}]                      
        -> same? [binary]   @[to :binary 1]            -> same? [one]   @[to :binary 1]              
        -> same? [word]      [(word)]                  -> same? [word]  @[[word]]                      
        -> same? [range]    @[range 1 1]               -> same? [a]     @[#[a: 'a']]               
        -> same? [black]    @[#black ]                 -> same? [word]  @[var 'word?]              
        -> same? [var]      @[var 'word?]
    ] => not? passed
    
    ; for :label
    ensure -> every? @[
        -> same? [rational:] @[to :rational [1 1]]     -> same? [null:]     @[null]                                                        
        -> same? [true:]     @[true]                   -> same? [false:]    @[false]                   
        -> same? [complex:]  @[to :complex [1.0 1.0]]  -> same? [floating:] @[:floating]
        -> same? [type:]     @[:floating]              -> same? [a:]         [a\a]                     
        -> same? [a:]         [a\a:]                   -> same? [a:]        @[{/a:/}]                 
        -> same? [binary:]   @[to :binary 1]           -> same? [word:]      [(word:)]                
        -> same? [label:]    @[[label:]]               -> same? [a:]        @[#[a: 'a']]               
        -> same? [black:]    @[#black ]                -> same? [var:]      @[var 'word?]
        -> same? [word:]     @[var 'word?]
    ] => not? passed
    
    ; for :literal
    ; NOTE: technically, '+ is not a :literal, but a :symbolLiteral type ;)
    ensure -> every? @[
        -> same? 'integer  1                   -> same? 'floating 1.0
        -> same? 'rational to :rational [1 1]  -> same? 'one      to :rational [1 1]
        -> same? 'null     null                -> same? 'true     true    
        -> same? 'false    false               -> same? 'complex  to :complex [1.0 1.0]    
        -> same? 'type     :floating           -> same? 'floating :floating               
        -> same? ['a]        [a\a]             -> same? ['+]      [+]                       
        -> same? 'a        {/a/}               -> same? 'binary   to :binary 1            
        -> same? ['word]   [('word)]           -> same? 'word     ['word]                                     
        -> same? 'range    1..1                -> same? 'a        #[a: 'a]                
        -> same? 'black    #black              -> same? 'word?    var 'word?              
        -> same? 'var      var 'var
    ] => not? passed
    
    ; for :attribute
    ensure -> every? @[           
        -> same? [.rational] @[to :rational [1 1]]    -> same? [.null]     @[null]                  
        -> same? [.true]     @[true]                  -> same? [.false]    @[false]                 
        -> same? [.complex]  @[to :complex [1.0 1.0]] -> same? [.floating] @[:floating]                          
        -> same? [.a]        @[{/a:/}]                -> same? [.binary]   @[to :binary 1]          
        -> same? [.word]      [(.word:)]              -> same? [.label]    @[[.label]]                               
        -> same? [.a]        @[#[a: 'a']]             -> same? [.black]    @[#black]                
        -> same? [.var]      @[var 'word?]            -> same? [.word]     @[var 'word?]
    ] => not? passed
    
    ; for :attributelabel
    ensure -> every? @[           
        -> same? [.rational:] @[to :rational [1 1]]    -> same? [.null:]     @[null]                  
        -> same? [.true:]     @[true]                  -> same? [.false:]    @[false]                 
        -> same? [.complex:]  @[to :complex [1.0 1.0]] -> same? [.floating:] @[:floating]             
        -> same? [.a:]         [a\a]                   -> same? [.a: 'a']     [a\a: 'a']              
        -> same? [.plus:]      [+]                     -> same? [.a:]        @[{/a:/}]                
        -> same? [.binary:]   @[to :binary 1]          -> same? [.word:]      [(.word:)]               
        -> same? [.label:]    @[[label:]]              -> same? [.a:]        @[#[a: 'a']]             
        -> same? [.black:]    @[#black]                -> same? [.var:]      @[var 'word?]            
        -> same? [.word:]     @[var 'word?]
    ] => not? passed
    
    ; for :path & :pathLabel
    ensure -> every? @[
        -> same? [a\b:] [a\b]
        -> same? [a\b] [a\b:]
    ] => not? passed

    ; for :regex
    ensure -> every? @[
        -> same? {/1/} 1                            -> same? {/1/1/} to :rational [1 1]          
        -> same? {/1.0/} 1.0                        -> same? {/null/} null                    
        -> same? {//} null                          -> same? {/true/} true                  
        -> same? {//} false                         -> same? {/false/} false                   
        -> same? {/1.0+1.0i/} to :complex [1.0 1.0] -> same? {/type/} :floating
        -> same? {/floating/} :floating             -> same? {/:floating/} :floating
        -> same? {/1.0/} :floating                  -> same? [{/a/}] [a\a]
        -> same? [{/a/}] [a\a:]                     -> same? [{/\+/}] [+]                          
        -> same? {/01/} to :binary 1                -> same? {/1/} to :binary 1                    
        -> same? [{//}] [({//})]                    -> same? {//} [""]                             
        -> same? {/1/} 1..1                         -> same? {/a/} #[a: "a"]                       
        -> same? {/#000000/} #black                 -> same? {/000000/} #black                     
        -> same? {/var/} var 'regex?                -> same? {/regex?/} var 'regex?
    ] => not? passed
    
    ; for :binary
    ensure -> every? @[
        -> same? to :binary 1 1                    -> same? to :binary 1 1.0                
        -> same? to :binary 1 to :rational [1 1]   -> same? to :binary 1 1`usd                
        -> same? to :binary 1 1`m                  -> same? to :binary 1 1`m3                 
        -> same? to :binary 1 1`c                  -> same? to :binary 0 null                 
        -> same? to :binary 0 true                 -> same? to :binary 0 false                
        -> same? to :binary 0 maybe                -> same? to :binary 1 to :complex [1 1]                  
        -> same? to :binary 1 1.0.0                -> same? to :binary 1 :type              
        -> same? to :binary 1 :binary              -> same? to :binary 1 '1'                  
        -> same? to :binary "a" 'a'                -> same? to :binary 1 "01"                 
        -> same? to :binary 1 "1"                  -> same? @[to :binary 1] [binary]          
        -> same? @[to :binary 1] [one]             -> same? @[to :binary 1] [binary:]         
        -> same? @[to :binary 1][.binary]          -> same? @[to :binary 1] [.binary:]        
        -> same? to :binary 1 {/01/}               -> same? to :binary 1    {/1/}
    ] => not? passed
    
    ; for :range
    ensure -> every? @[
        -> same? 1..1 1                        -> same? 1..1 1.0
        -> same? 1..1 a: to :rational [1 1]    -> same? 1..1 1`usd
        -> same? 1..1 1`m                      -> same? 1..1 1`m3  
        -> same? 1..1 1`c                      -> same? 0..0 null 
        -> same? 0..0 true                     -> same? 0..0 false
        -> same? 0..0 maybe                    -> same? 1..1 to :complex [1 1]
        -> same? 1..1 1.0.0                    -> same? 1..1 :type                        
        -> same? 1..1 :range                   -> same? 1..1 '1' 
        -> same? 1..1 "1"                      -> same? 1..1 'range  
        -> same? 1..1 {/1/}
    ] => not? passed
    
    ; for :dictionary, :object & :date
    define :person [name surname]
    
    a: to :person ["Walter" "Pinkman"]
    b: to :date .format: "YYYY MMM dd" "2023 Jan 15"
    
    ensure -> every? @[
        -> same? #[name: "Walter" surname: "Pinkman"] a
        -> same? a #[name: "Walter" surname: "Pinkman"]
        -> same? #[year: 2023 day: 15 Month: "January"] b
        -> same? b #[year: 2023 day: 15 Month: "January"]
    ] => not? passed
    
    ; for :color
    ensure -> every? @[
        -> same? #black 0                  -> same? #black 0.0
        -> same? #black to :rational [1 1] -> same? #black 0`usd 
        -> same? #black 0`m                -> same? #black 0`m3
        -> same? #black 0`c                -> same? #black null 
        -> same? #black true               -> same? #black false 
        -> same? #black maybe              -> same? #black to :complex [0 0]
        -> same? #black 0.0.0              -> same? #black :color
        -> same? #black '1'                -> same? #black "#000000"
        -> same? #black "000000"           -> same? [#black] [black] 
        -> same? #black 'black             -> same? [#black] [.black]
        -> same? [#black] [.black:]        -> same? #black  {/#000000/}                 
        -> same? #black{/000000/} 
    ] => not? passed
    
    ; for :function
    ensure -> every? @[
        -> same? var 'null?     null
        -> same? var 'version?  1.0.0      -> same? var 'type?    :type 
        -> same? var 'function? :function  -> same? var 'char?    'a' 
        -> same? @[var 'word?]  [word]     -> same? @[var 'word?] [var]      
        -> same? @[var 'word?]  [var:]     -> same? @[var 'word?] [word:]    
        -> same? var 'word?     'word?     -> same? var 'var      'var       
        -> same? @[var 'word?]  [.var]     -> same? @[var 'word?] [.word]    
        -> same? @[var 'word?]  [.var:]    -> same? @[var 'word?] [.word:]   
        -> same? var 'regex?    {/var/}    -> same? var 'regex?   {/regex?/} 
    ] => not? passed
    
    
]
