; helper function
debug: $[variable][
    print[variable type variable]
]

topic: $[topic :string] -> print ~"\n>> |topic|"
passed: $[] -> print "[+] passed!"


; ==> Tests

topic "append"
do [

    topic "append - :binary < :binary :binary"
    do [
        b0: to :binary 0
        b1: to :binary 1
        
        ensure -> as.binary 1 = append b0 b1
        passed
        
        b0: to :binary 0
        b1: to :binary 1
        
        ensure -> as.binary 1 = b0 ++ b1
        passed
    ]
    topic "append - :binary < :binary (literal) :binary"
    do [
        b0: to :binary 0
        b1: to :binary 1
        append 'b0 b1
        
        ensure -> as.binary 1 = b0
        passed
        
        b0: to :binary 0
        b1: to :binary 1
        'b0 ++ b1
        
        ensure -> as.binary 1 = b0
        passed
    ]

    topic "append - :binary < :binary :integer"
    do [
        b: to :binary 0
        ensure -> as.binary 1 = append b 1
        passed
        
        b: to :binary 0
        ensure -> as.binary 1 = b ++ 1
        passed
    ]
    
    topic "append - :binary < :binary (literal) :integer"
    do [
        b: to :binary 0
        append 'b 1
        ensure -> as.binary 1 = b
        passed
        
        b: to :binary 0
        'b ++ 1
        ensure -> as.binary 1 = b
        passed
    ]

    topic "append - :string < :string + :string"
    do [

        ensure -> "Arturo" = append "Art" "uro"
        passed
        
        ensure -> "Arturo" = "Art" ++ "uro"
        passed

    ]
    
        topic "append - :string < :string (literal) + :string"
    do [

        s: "Art"
        append 's "uro"
        ensure -> "Arturo" = s
        passed
        
        s: "Art"
        's ++ "uro"
        ensure -> "Arturo" = s
        passed

    ]

    topic "append - :string < :string + :char"
    do [

        ensure -> "Arturo" = append "Artur" `o`
        passed

        ensure -> "Arturo" = "Artur" ++ `o`
        passed

    ]
    
    topic "append - :string < :string (literal) + :char"
    do [

        s: "Artur"
        append 's `o`
        ensure -> "Arturo" = s
        passed

        s: "Artur"
        's ++ `o`
        ensure -> "Arturo" = s
        passed

    ]

    topic "append - :string < :char + :char"
    do [

        ensure -> "ab" = append `a` `b`
        passed
        
        ensure -> "ab" = `a` ++ `b`
        passed

    ]
    
    topic "append - :string < :char (literal) + :char"
    do [

        c: `a`
        append 'c `b`
        ensure -> "ab" = c
        passed
        
        c: `a`
        'c ++ `b`
        ensure -> "ab" = c
        passed

    ]

    topic "append - :string < :char + :string"
    do [

        ensure -> "Arturo" = append `A` "rturo"
        passed
        
        ensure -> "Arturo" = `A` ++ "rturo"
        passed

    ]
    
    topic "append - :string < :char (literal) + :string"
    do [
        
        c: `A`
        append 'c "rturo"
        ensure -> "Arturo" = c
        passed
        
        c: `A`
        'c ++ "rturo"
        ensure -> "Arturo" = c
        passed

    ]
    
    topic "append - [:string] < [:string] + :string"
    do [
        ensure -> ["A" "r" "t" "uro"] = append ["A" "r" "t"] "uro"
        passed
        ensure -> ["L" "a" "n" "g" "u" "a" "g" "e"] = append ["L" "a" "n" "g" "u" "a" "g"] "e"
        passed
        
        ensure -> ["A" "r" "t" "uro"] = ["A" "r" "t"] ++ "uro"
        passed
        ensure -> ["L" "a" "n" "g" "u" "a" "g" "e"] = ["L" "a" "n" "g" "u" "a" "g"] ++ "e"
        passed
    ]
    
    topic "append - [:string] < [:string] (literal) + :string"
    do [
        a: ["A" "r" "t"] 
        append 'a "uro"
        ensure -> ["A" "r" "t" "uro"] = a
        passed
        
        a: ["L" "a" "n" "g" "u" "a" "g"]
        append 'a "e"
        ensure -> ["L" "a" "n" "g" "u" "a" "g" "e"] = a
        passed
        
        a: ["A" "r" "t"]
        'a ++ "uro"
        ensure -> ["A" "r" "t" "uro"] =  a
        passed
        
        a: ["L" "a" "n" "g" "u" "a" "g"]
        'a ++ "e"
        ensure -> ["L" "a" "n" "g" "u" "a" "g" "e"] = a
        passed
    ]

    topic "append - [:string] < [:string] + :string - testing precedence"
    do [
        
        ensure -> ["L" "a" "n" "g" "uage"] =  ["L" "a" "n" "g"] ++ "u" ++ "a" ++ "g" ++ "e"
        passed
        
        a: ["L" "a" "n" "g"]
        'a ++ "u" ++ "a" ++ "g" ++ "e"
        ensure -> ["L" "a" "n" "g" "uage"] = a
        passed

    ]

    topic "append - :block < :block + :block"
    do [

        ensure -> ['literal "string" 102230 ] = append ['literal "string" ] 102230
        passed
        
        ensure -> ['literal "string" 102230 ] = ['literal "string" ] ++ 102230
        passed
    ]
    
    topic "append - :block < :block (literal) + :block"
    do [

        a: ['literal "string" ]
        append 'a 102230
        ensure -> ['literal "string" 102230 ] = a
        passed
        
        a: ['literal "string" ]
        'a ++ 102230
        ensure -> ['literal "string" 102230 ] = a
        passed
    ]

]

topic "chop - :string < :string :string"
do [
    ensure -> "Artur" = chop "Arturo"
    passed
    ensure -> "Art" = chop chop chop "Arturo"
    passed
]

topic "chop.times - :string < :string :string"
do [
    ensure -> "Art" = chop.times: 3 "Arturo"
    passed
]

topic "chop - :string < :string (literal) :string"
do [
    a: "Arturo", chop 'a
    
    ensure -> "Artur" = a
    passed
    
    b: "Arturo"
    try? -> chop chop chop 'b
    else -> passed
]

topic "chop.times - :string < :string (literal) :string"
do [
    a: "Arturo", chop.times: 3 'a
    ensure -> "Art" = a
    passed
]

topic "chop - :block < :block :block"
do [
    ensure -> [1 2 3 4] = chop [1 2 3 4 5]
    passed
    ensure -> [1 2] = chop chop chop [1 2 3 4 5]
    passed
]

topic "chop.times - :block < :block :block"
do [
    ensure -> [1 2] = chop.times: 3 [1 2 3 4 5]
    passed
]

topic "chop - :block < :block (literal) :block"
do [
    a: [1 2 3 4 5], chop 'a
    
    ensure -> [1 2 3 4] = a
    passed
    
    b: [1 2 3 4 5]
    try? -> chop chop chop 'b
    else -> passed
]

topic "chop.times - :block < :block (literal) :block"
do [
    a: [1 2 3 4 5], chop.times: 3 'a
    ensure -> [1 2] = a
    passed
]


topic "combine - .count - .repeat - .by"
do [
    
    ensure -> [[A B C]] = combine [A B C]
    passed
    
    ensure -> [[A A A] [A A B] [A A C] [A B B] [A B C] [A C C] [B B B] [B B C] [B C C] [C C C]] 
        = combine.repeated [A B C]
    passed
    
    ensure -> [[A B] [A C] [B C]] = combine.by:2 [A B C]
    passed
    
    ensure -> [[A A] [A B] [A C] [B B] [B C] [C C]] = combine.repeated.by:2 [A B C]
    passed
    
    ensure -> 1 = combine.count [A B C]
    passed
    
    ensure -> 6 = combine.count.repeated.by:2 [A B C]
    passed

]

topic "contains? - :string"
do [
    str: "Arturo"
    ensure -> contains? str "Art"         ; :string
    passed
    ensure -> contains? str `t`           ; :char
    passed
    ensure -> contains? str {/[Art]/}     ; :regex
    passed
    ensure -> not? contains? str "Football"
    passed
    ensure -> contains?.at:0 str "Art"
    passed
    ensure -> not? contains?.at:2 str "Art"
    passed
]

topic "contains? - :block"
do [
    block: ["Arturo" "Python" "Ruby"]
    ensure -> contains? block "Arturo"
    passed
    ensure -> not? contains? block "F#"
    passed
    ensure -> contains?.at: 0 block "Arturo"
    passed
    ensure -> not? contains?.at: 2 block "Python"
    passed
]

topic "contains? - with nested :block"
do [
    nested: [["Arturo" "Python" "Ruby"] ["C" "C++" "Nim"]]
    ensure -> not? contains? nested "Arturo"
    passed
    ensure -> contains? nested ["C" "C++" "Nim"]
    passed
    ensure -> not? contains?.at: 0 nested ["C" "C++" "Nim"]
    passed
    ensure -> not? contains?.at: 1 nested "Python"
    passed
]

topic "contains? - with :range"
do [
    rng: 1..10
    ensure -> contains? rng 5
    passed
    ensure -> not? contains? rng 0
    passed
    ensure -> contains? 1..10 5
    passed
    ensure -> not? contains? 1..10 0
    passed
    ensure -> contains?.at: 0 1..10 1
    passed
    ensure -> not? contains?.at: 0 1..10 0
    passed
]

topic "contains? - with :dictionary"
do [
    dict: #[ name: "John" surname: "Doe"]
    ensure -> contains? keys dict "name"
    passed
    ensure -> contains?.at:0 keys dict "name"
    passed
    ensure -> not? contains?.at:1 keys dict "name"
    passed
    ensure -> not? contains? keys dict "id"
    passed
    ensure -> contains? dict "John"
    passed
    ensure -> contains?.at:0 dict "John"
    passed
    ensure -> not? contains?.at:1 dict "John"
    passed
    ensure -> not? contains? dict "Jane"
    passed

]

; couple don't support literals yet
topic "couple"
do [
    ensure -> [["one" 1] ["two" 2] ["three" 3]] = couple ["one" "two" "three"] [1 2 3]
    passed
]

topic "decouple"
do [
    ensure -> [["one" "two" "three"] [1 2 3]] = decouple [["one" 1] ["two" 2] ["three" 3]]
    passed
    
    a:  [["one" 1] ["two" 2] ["three" 3]]
    decouple 'a
    ensure -> [["one" "two" "three"] [1 2 3]] = a
    passed
]

topic "drop - :string < :string :string"
do [
    ensure -> "rturo" = drop "Arturo" 1
    passed
    ensure -> "uro" = drop "Arturo" 3
    passed
]

topic "drop - :string < :string (literal) :string"
do [
    a: "Arturo", drop 'a 1
    
    ensure -> "rturo" = a
    passed
    
    b: "Arturo", drop 'b 3
    ensure -> "uro" = b
    passed
]

topic "drop - :block < :block :block"
do [
    ensure -> [2 3 4 5] = drop [1 2 3 4 5] 1
    passed
    ensure -> [4 5] = drop [1 2 3 4 5] 3
    passed
]

topic "drop - :block < :block (literal) :block"
do [
    a: [1 2 3 4 5], drop 'a 1
    
    ensure -> [2 3 4 5] = a
    passed
    
    b: [1 2 3 4 5], drop 'b 3
    ensure -> [4 5] = b
    passed
]

topic "empty - empty?"
do [
    b1: ["Arturo" "C" "Python" "Ruby"]
    b2: [1 2 3 4 5 6 7 8 9 10]
    b3: @['north 'south 'east 'west]
    s: "Arturo"
    d: #[ name: "John" surname: "Doe"]
    
    empty 'b1
    empty 'b2
    empty 'b3
    empty 's
    empty 'd
    
    ensure -> empty? b1
    passed
    ensure -> empty? b2
    passed
    ensure -> empty? b3
    passed
    ensure -> empty? s
    passed
    ensure -> empty? d
    passed
]


topic "extend"
do [

    person: #[ name: "john" surname: "doe" ]
    ensure -> (#[ name: "john" surname: "doe" age: 35 ]) = extend person #[ age: 35 ]
    passed
]

topic "extend (literal)"
do [

    person: #[ name: "john" surname: "doe" ]
    extend 'person #[ age: 35 ]
    ensure -> (#[ name: "john" surname: "doe" age: 35 ]) = person
    passed
]

topic "first - .n"
do [

    ensure -> `A` = first "Arturo"
    passed
    ensure -> "A" <> first "Arturo"
    passed
    ensure -> "Art" = first.n: 3 "Arturo"
    passed
    
    ensure -> "one" = first ["one" "two" "three"]
    passed
    ensure -> ["one" "two"] = first.n: 2 ["one" "two" "three"]
    passed

    ensure -> 5 = first 5..10
    passed
    ensure -> (to :block 5..7) = first.n: 3 5..10
    passed

]

topic "flatten"
do [

    ensure -> [1 2 3 4 5 6] = flatten [[1 2 3] [4 5 6]]
    passed
    
    a: [[1 2 3] [4 5 6]], flatten 'a
    ensure -> [1 2 3 4 5 6] = a
    passed

]

topic "flatten.once"
do [

    ensure -> [1 2 3 4 [5 6]] = flatten.once [1 [2 3] [4 [5 6]]]
    passed
    
    a: [1 [2 3] [4 [5 6]]], flatten.once 'a
    ensure -> [1 2 3 4 [5 6]] = a
    passed

]

topic "get - :string"
do [
    
    ensure -> `r` = get "Arturo" 1
    passed
    
    s: "Arturo"
    
    ensure -> `r` = s\1
    passed
    
    i: 0
    ensure -> `r` = s\[i + 1]
    passed
    
]

topic "get - :date"
do [
    
    d: to :date .format: "MMM dd" "Jan 15"
    
    ensure -> 1 = d\month 
    passed
    ensure -> 15 = d\day 
    passed
]

topic "get - :binary"
do [
    bi: to :binary 65000
    ensure -> (from.hex "E8") = get bi 1
    passed
]


topic "get - :dictionary"
do [
    
    user: #[
        name: "John"
        surname: "Doe"
    ]

    ensure -> "John" = user\name
    passed
    ensure -> "John" = user\["name"]
    passed
    ensure -> "John" = get user 'name
    passed
    ensure -> "Doe" = get user 'surname
    passed
    ensure -> "Doe" = user\["surname"]
    passed
    
]

topic "get - :object"
do [
    define :person [name, surname][
        init: ->
            this\name: capitalize this\name
        
        print: ->
            ~"NAME: |this\name|, SURNAME: |this\surname|"
    ]
    
    p: to :person ["John" "Doe"]
    ensure -> "John" = get p 'name
    ensure -> "Doe" = get p 'surname
    passed
    ensure -> "John" = get p "name"
    ensure -> "Doe" = get p "surname"
    passed
    ensure -> "John" = p\name
    ensure -> "Doe" = p\surname
    passed
    ensure -> "John" = p\["name"]
    ensure -> "Doe" = p\["surname"]
    passed
    
]

topic "get - :store"
do [
    
    p: store "test.db"
    p\name: "John"
    p\surname: "Doe"

    ensure -> "John" = get p 'name
    ensure -> "Doe" = get p 'surname
    passed
    ensure -> "John" = get p "name"
    ensure -> "Doe" = get p "surname"
    passed
    ensure -> "John" = p\name
    ensure -> "Doe" = p\surname
    passed
    ensure -> "John" = p\["name"]
    ensure -> "Doe" = p\["surname"]
    passed
    
]

topic "get - :block"
do [
    
    a: ["zero" "one" "two"]
    ensure -> "zero" = get a 0
    ensure -> "zero" = a\0
    passed
    ensure -> "one" = get a 1
    ensure -> "one" = a\1
    passed
    ensure -> "two" = get a 2
    ensure -> "two" = a\2
    passed
    
]

topic "get - :range"
do [
    ensure -> 1 = get range 0 10 1
    passed
    ensure -> 5 = get 5..10 0
    passed
]

topic "get - :bytecode"
do [
    bt: to :bytecode [print "hello"]
    ensure -> ["hello"] = bt\data
    ensure -> [32 189 218] = bt\code
    passed
    ensure -> ["hello"] = get bt 'data
    ensure -> [32 189 218] = get bt 'code
    passed
    ensure -> ["hello"] = get bt "data"
    ensure -> [32 189 218] = get bt "code"
    passed
    ensure -> ["hello"] = bt\["data"]
    ensure -> [32 189 218] = bt\["code"]
    passed
]

topic "in? - :string"
do [
    str: "Arturo"
    ensure -> in? "Art" str        ; :string
    passed
    ensure -> in? `t` str           ; :char
    passed
    ensure -> in? {/[Art]/} str     ; :regex
    passed
    ensure -> not? in? "Football" str 
    passed
    ensure -> in?.at:0 "Art" str
    passed
    ensure -> not? in?.at:2 "Art" str 
    passed
]

topic "in? - :block"
do [
    block: ["Arturo" "Python" "Ruby"]
    ensure -> in? "Arturo" block
    passed
    ensure -> not? in? "F#" block
    passed
    ensure -> in?.at:0 "Arturo" block
    passed
    ensure -> not? in?.at:2 "Python" block 
    passed
]

topic "in? - with nested :block"
do [
    nested: [["Arturo" "Python" "Ruby"] ["C" "C++" "Nim"]]
    ensure -> not? in? "Arturo" nested 
    passed
    ensure -> in? ["C" "C++" "Nim"] nested 
    passed
    ensure -> not? in?.at:0 ["C" "C++" "Nim"] nested 
    passed
    ensure -> not? in?.at:1 "Python" nested 
    passed
]

topic "in? - with :range"
do [
    rng: 1..10
    ensure -> in? 5 rng 
    passed
    ensure -> not? in? 0 rng 
    passed
    ensure -> in? 5 1..10 
    passed
    ensure -> not? in? 0 1..10 
    passed
    ensure -> in?.at:0 1 1..10 
    passed
    ensure -> not? in?.at:0 0 1..10 
    passed
]

topic "in? - with :dictionary"
do [
    dict: #[ name: "John" surname: "Doe"]
    ensure -> in? "name" keys dict 
    passed
    ensure -> in?.at:0 "name" keys dict 
    passed
    ensure -> not? in?.at:1 "name" keys dict
    passed
    ensure -> not? in? "id" keys dict 
    passed
    ensure -> in? "John" dict 
    passed
    ensure -> in?.at:0 "John" dict
    passed
    ensure -> not? in?.at:1 "John" dict 
    passed
    ensure -> not? in? "Jane" dict 
    passed

]


topic "index - :string"
do [
    
    ensure -> 0 = index "Arturo" "Art"
    passed
    ensure -> 3 = index "Arturo" "uro"
    passed
    
]

topic "index - :dictionary"
do [
    
    user: #[
        name: "John"
        surname: "Doe"
    ]

    ensure -> "name" = index user "John"
    passed
    ensure -> "surname" = index user "Doe"
    passed
    
]

topic "index - :block"
do [
    
    a: ["zero" "one" "two"]
    ensure -> 0 = index a "zero"
    passed
    ensure -> 1 = index a "one"
    passed
    ensure -> 2 = index a "two"
    passed
    
]

topic "index - :range"
do [
    ensure -> 1 = index range 0 10 1
    passed
    ensure -> 0 = index 5..10 5
    passed
]



topic "insert"
do [

    ; with :dictionary
    debug insert #[ name: "John" ] "age" 32
    dict: #[ name: "John" ]
    insert 'dict "name" "Joe, Again", debug dict

    ; with :block
    debug insert [1 2 3 4] 0 "zero"
    debug insert [1 2 6 7 8 9 10] 2 [3 4 5]
    arr: [1 2 3 4]
    insert 'arr 0 0, debug arr

    ; with :string
    debug insert "heo" 2 "ll"
    str1: "Auro"
    insert 'str1 1 "rt", debug str1
    
    debug insert "helo" 2 `l`
    str2: "uby"
    insert 'str2 0 `R`, debug str2

]

topic "key?"
do [

    ; :dictionary
    user: #[ name: "John" surname: "Doe" ]
    debug key? user 'name
    debug key? user "name"
    debug key? user 'age
    debug key? user "age"

    ; :object
    define :person [name, surname][
        init: ->
            this\name: capitalize this\name
        
        print: ->
            ~"NAME: |this\name|, SURNAME: |this\surname|"
    ]

    personA: to :person ["John" "Doe"]
    debug key? personA 'name
    debug key? personA "name"
    debug key? personA 'surname
    debug key? personA "surname"
    debug key? personA 'age
    debug key? personA "age"
]


topic "keys"
do [

    ; :dictionary
    user: #[ name: "John" surname: "Doe" ]
    debug keys user

    ; :object
    define :person [name, surname][
        init: ->
            this\name: capitalize this\name
        
        print: ->
            ~"NAME: |this\name|, SURNAME: |this\surname|"
    ]
    
    personA: to :person ["John" "Doe"]
    debug keys personA
]


topic "last"
do [

    debug last "Arturo"
    debug last.n: 3 "Arturo"

    debug last ["one" "two" "three"]
    debug last.n: 2 ["one" "two" "three"]

    print last 1..10
    print last 5..0
    print last 0..40
    last.n: 6 0..10
    ; storing into a variable
    r1: 1..10
    print last r1
    print last.n: 6 r1
    ; using range function
    print last range 0 10
    print last.n: 6 range 0 10
    r2: range 0 10
    print last range 0 10
    print last.n: 6 range 0 10

]


topic "max"
do [

    debug max [4 2 8 5 1 9]
    debug max.index [4 2 8 5 1 9]
    debug max ["Granada" "Manchester" "Boston"]
    debug max.index ["Granada" "Manchester" "Boston"]
    
    print max 1..10
    print max 5..0
    print max.index 1..10
    print max.index 5..0
    ; storing into a variable
    r1: 1..10
    print max r1
    print max.index r1
    ; using range function
    print max range 1 10
    print max range 5 0
    print max.index range 1 10
    print max.index range 5 0
    r2: range 0 10
    r3: range 5 0
    print max r2
    print max r3
    print max.index r2
    print max.index r3

]


topic "min"
do [

    debug min [4 2 8 5 1 9]
    debug min.index [4 2 8 5 1 9]
    debug min ["Granada" "Manchester" "Boston"]
    debug min.index ["Granada" "Manchester" "Boston"]
    
    print min 1..10
    print min 5..0
    print min.index 1..10
    print min.index 5..0
    ; storing into a variable
    r1: 1..10
    print min r1
    print min.index r1
    ; using range function
    print min range 1 10
    print min range 5 0
    print min.index range 1 10
    print min.index range 5 0
    r2: range 0 10
    r3: range 5 0
    print min r2
    print min r3
    print min.index r2
    print min.index r3

]


topic "one?"
do [

    topic "one? - with :integer"
    debug one? 4-3
    debug one? 5  

    topic "one? - with :floating"
    debug one? 1.0
    debug one? 0.0

    topic "one? - with :string"
    debug one? "A"
    debug one? "Arturo"

    topic "one? - with :block"
    debug one? ["apple"] 
    debug one? ["apple" "pear"] 

    topic "one? - with :range"
    print one? 0..0 ; Yet not
    print one? 0..10

    topic "one? - with :dictionary"
    debug one? #[ name: "John" ]
    debug one? #[ name: "John" surname: "Doe" ]


    topic "one? - with :object"
    define :person [name, surname][
        init: ->
            this\name: capitalize this\name
        
        print: ->
            ~"NAME: |this\name|, SURNAME: |this\surname|"
    ]

    personA: to :person ["John"]
    personB: to :person ["John" "Doe"]
    debug one? personA
    debug one? personB

    topic "one? - with :null"
    debug one? null

]


topic "permutate"
do [

    debug permutate [A B C]
    debug permutate [[1 2 3] [4 5 6]]

    debug permutate.by: 2 [A B C]
    debug permutate.repeated [A B C]
    debug permutate.repeated.by: 2 [A B C]

    debug permutate.count [A B C]
    debug permutate.count.repeated.by: 2 
        [A B C]

]

topic "prepend"
do [

    topic "prepend - :binary < :binary :binary"
    do [
        bin0: to :binary 0
        bin1: to :binary 1
        debug prepend bin0 bin1

        prepend 'bin0 bin1, debug bin0
    ]

    topic "prepend - :binary < :binary :integer"
    do [
        bin0: to :binary 0
        int1: 1
        debug prepend bin0 int1

        prepend 'bin0 int1, debug bin0
    ]

    topic "prepend - :string < :string + :string"
    do [

        a: "uro"
        debug prepend "uro" "Art"
        prepend 'a "Art", debug a

    ]

    topic "prepend - :string < :string + :char"
    do [

        a: "rturo"
        debug prepend "rturo" `A`
        prepend 'a `A`, debug a

    ]

    topic "prepend - :string < :char + :char"
    do [

        a: `b`
        debug prepend `b` `a`
        prepend 'a `a`, debug a

    ]

    topic "prepend - :string < :char + :string"
    do [

        a: `t`
        debug prepend `t` "ar"
        prepend 'a "ar", debug a

    ]

    topic "prepend - [:string] < [:string] + :string"
    do [

        a: ["r" "t" "u" "r" "o"]
        debug prepend ["r" "t" "u" "r" "o"] "A"
        prepend 'a "A", debug a

        ; Testing precedence
        c: ["u" "r" "o"]
        debug prepend ["u" "r" "o"] prepend "t" prepend "r" "A"
        prepend 'c prepend "t" prepend "r" "A", debug c

    ]

    topic "prepend - [:string] < [:string] + [:string]"
    do [

        a: ["u" "r" "o"]
        debug prepend ["u" "r" "o"] ["A" "r" "t"]
        prepend 'a ["A" "r" "t"], debug a

    ]

    topic "prepend - [:integer] < [:integer] + [:integer]|:integer"
    do [

        a: [1 2 3]
        debug prepend [4 5 6] [1 2 3]
        debug prepend [1 2 3 4 5 6] 0
        prepend 'a 0, debug a

    ]

]


topic "remove"
do [
    ; default
    topic "remove - default"
    do [

        ; :string
        s1: "Arturo"
        debug remove "Arturo" "uro"
        remove 's1 "uro", debug s1

        s2: "Language"
        debug "Language" -- "uage"
        's2 -- "uage", debug s2

        ; :string -- :char
        s3: "hello"
        debug remove "hello" `l`
        remove 's3 `l`, debug s3

        s4: "hello"
        debug "hello" -- `l`
        's4 -- `l`, debug s4


        ; :block
        debug remove [1 2 3 4] 4
        debug remove [1 2 3 4] [2 4]

        b1: [1 2 3 5 6 4]
        debug [1 2 3 4] -- 4
        debug [1 2 3 4] -- [2 4]
        remove 'b1 [5 6], debug b1

        debug remove [1 6 2 5 3 4 5 6] [5 2]
        debug remove [1 [6 2] 5 3 [6 2] 4 5 6] [6 2]
        
        b2: [1 6 2 5 3 4 5 6]
        b3: [1 [6 2] 5 3 [6 2] 4 5 6]
        remove 'b2 [5 2], debug b2
        remove 'b3 [6 2], debug b3


        ; :dictionary
        debug remove #[name: "John" surname: "Doe"] "John"
        
        ; Note: It's not a bug, but it's important to be here.
        ; Read the solved: 
        ; [Collections/remove] -- is not working with :dictionary #918
        ; explanation: https://github.com/arturo-lang/arturo/issues/918#issuecomment-1361466787
        ; print #[name: "John" surname: "Doe"] -- "John"
        
        user: #[name: "John" surname: "Doe"]
        user2: #[name: "John" surname: "Wick"]
        remove 'user "John", debug user
        'user2 -- "John", debug user2


    ]

    topic "remove - .index"
    do[
        debug remove.index [0 1 2 3 4 5] 3
        debug remove.index [0 1 2 3 4 5] 4
        debug remove.index [0 1 2 3 4 5] 0

        a: [5 4 3 2 1 0]
        remove.index 'a 2, debug a
        remove.index 'a 0, debug a
        remove.index 'a 3, debug a
    ]

    topic "remove - .prefix"
    do [

        a: "test_function.art"
        debug remove.prefix "test_function.art" "test_"
        remove.prefix 'a "test_", debug a

    ]

    topic "remove - .suffix"
    do [

        a: "test_function.art"
        debug remove.suffix "test_function.art" ".art"
        remove.suffix 'a ".art", debug a

    ]

    topic "remove - .key"
    do [

        user: #[
            name: "John"
            surname: "Doe"
        ]

        remove.key 'user "surname"
        debug user

    ]

    topic "remove - .once"
    do [

        topic "remove - .once :string"
        debug remove.once "hello" "l"

        debug remove.once "hello" `l`

        s1: "hello"
        remove.once 's1 "l", debug s1

        s2: "hello"
        remove.once 's2 `l`, debug s2
        
        ; :block
        topic "remove - .once :block"
        debug remove.once [1 2 5 3 4 5] 5
        b1: [1 2 5 3 4 5]
        remove.once 'b1 5, debug b1

        ; Testing new behavior from PR #877
        debug remove.once [1 6 2 5 3 4 5 6] [6 2]
        debug remove.once [1 2 [6 2] 5 3 4 5 6] [6 2]
        debug remove.once [1 2 [1 2] 3 4 1 2 [1 2] 3 4]  [1 2]

        b2: [1 6 2 5 3 4 5 6]
        b3: [1 2 [6 2] 5 3 [6 2] 4 5 6]
        b4: [1 2 [1 2] 3 4 1 2 [1 2] 3 4]
        remove.once 'b2 [6 2], debug b2
        remove.once 'b3 [6 2], debug b3
        remove.once 'b4 [1 2], debug b4

        ; :dictionary
        topic "remove - .once :dictionary"
        debug remove.once #[name: "John" surname: "Doe" father: "John"] 
            "John"
        
        user: #[name: "John" surname: "Doe" father: "John"]
        remove.once 'user "John", debug user

    ]

    topic "remove - .instance"
    do [

        a1: [1 2 [1 2] 1 2 3 [1 2]]
        debug remove.instance [1 2 [1 2] 1 2 3 [1 2]] [1 2]
        remove.instance 'a1 [1 2], debug a1

    ]

    topic "remove - .instance.once"
    do [

        a1: [1 2 [1 2] 1 2 3 [1 2]]
        debug remove.instance.once [1 2 [1 2] 1 2 3 [1 2]] [1 2]
        remove.instance.once 'a1 [1 2], debug a1

    ]
]


topic "repeat"
do [

    debug repeat "hello" 3

    a: "Arturo"
    repeat 'a 3, debug a

    debug repeat [1 2 3] 3
    debug repeat [[1 2 3]] 3
    
    b: [4 5 6]
    repeat 'b 3, debug b

]


topic "reverse"
do [

    debug reverse [1 2 3 4 5]
    debug reverse [[1 2 3] [4 5 6] [7 8 9]]
    debug reverse "Manchester"

    b: [[1 2 3] [4 5 6] [7 8 9]]
    s: "Arturo"
    reverse 'b, debug b
    reverse 's, debug s

    topic "reverse - with :range"
    debug reverse 1..10
    r1: 10..0
    reverse 'r1, debug r1

    topic "reverse - .exact"
    do [

        debug reverse.exact [1 2 3 4 5]
        debug reverse.exact [[1 2 3] [4 5 6] [7 8 9]]
        debug reverse.exact "Manchester"

        b: [[1 2 3] [4 5 6] [7 8 9]]
        s: "Arturo"
        reverse.exact 'b, debug b
        reverse.exact 's, debug s

        topic "reverse - .exact with :range"
        debug reverse.exact 1..10
        r2: 10..0
        reverse.exact 'r2, debug r2

    ]

]


topic "rotate"
do [

    ; :block
    debug rotate [2 3 4 5 1] 1 
    b1: [3 4 5 1 2]
    rotate 'b1 2, debug b1

    ; :string
    debug rotate "turoAr" 2

    s1: "turoAr"
    rotate 's1 2, debug s1

    ; -- left
    ; :block
    debug rotate.left [4 5 1 2 3] 2
    b2: [3 4 5 1 2]
    rotate.left 'b2 3
    debug b2

    ; :string
    debug rotate.left "roArtu" 2

    s2: "oArtur"
    rotate.left 's2 1, debug s2

]


topic "sample"
do [

    table: ["apple" "appricot" "banana"]
    fruit: sample table

    print type fruit
    print in? fruit table

    alphabet: `a`..`z`
    letter: sample alphabet
    print type letter
    print in? letter alphabet

]


topic "set"
do [

    ; TODO: test with
    ; :bytecode

    ; :binary
    bin0: to :binary 0
    debug bin0
    set bin0 0 1, debug bin0

    ; :block
    arr: [1 2 3 4]
    set arr 0 "one", debug arr

    ; :dictionary
    myDict: #[
        name: "John"
        age: 34
    ]

    set myDict 'name "Michael"
    debug myDict

    myDict\name: "Jane"
    debug myDict

    myDict\["name"]: "Christian"
    debug myDict

    ; :object
    define :person [name, surname][
        init: ->
            this\name: capitalize this\name
        
        print: ->
            ~"NAME: |this\name|, SURNAME: |this\surname|"
    ]

    personA: to :person ["John" "Doe"]
    set personA 'surname "Wick"
    debug personA

    ; :string
    s1: "Arruro"
    set s1 2 "t"
    debug s1

    s1: "Arruro"
    set s1 2 `t`
    debug s1

    ; :store
    st: store "teststore"
    st\name: "John"
    st\surname: "Doe"

    debug get st 'name
    debug st\surname

]


topic "shuffle"
do [

    a: shuffle [1 2 3 4 5 6]
    print size a
    print every? a 'item [ type? item :integer ]

    a: shuffle ["Manchester" "Granada" "Boston" "Davos"]
    print size a
    print every? a 'item [ type? item :string ]

]


topic "size"
do [

    ; :string
    print ["Good morning!" size "Good morning!"]
    print ["Konnichiwa!" size "Konnichiwa!"]
    print ["こんいちわ！" size "こんいちわ！"]
    ; :block
    print [["one" "two" "three"] 
        size ["one" "two" "three"]]

    print size range 0 10
    print size 0..10
    r1: 0..20
    print size r1

    ; :dictionary
    print [#[name: "John", surname: "Doe"] 
        size #[name: "John", surname: "Doe"]]

    ; :object
    define :person [name, surname][
        init: ->
            this\name: capitalize this\name
        
        print: ->
            ~"NAME: |this\name|, SURNAME: |this\surname|"
    ]

    p1: to :person ["Joe"]
    debug size p1
    p2: to :person ["Joe" "Doe"]
    debug size p2

    ; :null
    print [null size null]

]


topic "slice"
do [

    debug slice "Arturo" 0 2
    debug slice ["Arturo" "Python" "Ruby" "C" "C++" "Nim" "Wren"] 3 5

    a: ["Arturo" "Python" "Ruby" "C" "C++" "Nim" "Wren"]
    b: "Arturo"

    slice 'a 3 5, debug a
    slice 'b 0 2, debug b

]


topic "sort"
do [

    ; default
    topic "sort - default"
    do [

        debug sort [5 4 3 2 1]
        debug sort ["Ruby" "Arturo" "Python"]
        debug sort #[ c: "C" art: "Arturo"
            nim: "Nim" coffee: "CoffeeScript" ]

        a: [5 4 3 2 1]
        b: ["Ruby" "Arturo" "Python"]
        c: #[ c: "C" art: "Arturo" 
            nim: "Nim" coffee: "CoffeeScript"]
        sort 'a, debug a
        sort 'b, debug b
        sort 'c, debug c

    ]

    topic "sort - .values"
    do [

        debug sort.values #[
            name: "John"
            surname: "Doe"
            id: "012568"
            city: "Manchester"
            age: 45
        ]

        user: #[
            name: "John"
            surname: "Doe"
            id: "012568"
            city: "Manchester"
            age: 45
        ]

        sort.values 'user, debug user

    ]

    topic "sort - .sensitive .as with :block and :dictionary"
    do [

        a1: ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        print sort ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        sort 'a1, print a1
        ; => [aberración abismo dos perversión tres uno Uno ábaco]

        d1: #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        print sort.values #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        sort.values 'd1, print d1

        a2: ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        print sort.as: 'es ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        sort.as: 'es 'a2, print a2
        ; => [ábaco aberración abismo dos perversión tres uno Uno]

        d2: #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        print sort.values.as: 'es #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        sort.values.as: 'es 'd2, print d2
        ; ; => [f:ábaco h:aberración g:abismo b:dos e:perversión c:tres a:uno d:Uno]

        a3: ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        print sort.sensitive ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        sort.sensitive 'a3, print a3
        ; => [Uno aberración abismo dos perversión tres uno ábaco]

        d3: #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        print sort.values.sensitive #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        sort.values.sensitive 'd3, print d3
        ; ; => [d:Uno h:aberración g:abismo b:dos e:perversión c:tres a:uno f:ábaco]

        a4: ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        print sort.sensitive.as: 'es ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        sort.sensitive.as: 'es 'a4, print a4
        ; => [Uno ábaco aberración abismo dos perversión tres uno]

        d4: #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        print sort.values.sensitive.as: 'es #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        sort.values.sensitive.as: 'es 'd4, print d4
        ; ; => [d:Uno f:ábaco h:aberración g:abismo b:dos e:perversión c:tres a:uno]

        a5: [10 9 8 7 6 5 4 3 2 1 0]
        print sort [10 9 8 7 6 5 4 3 2 1 0]
        sort 'a5, print a5
        ; => [0 1 2 3 4 5 6 7 8 9 10]

        d5: #[a:10 b:9 c:8 d:7 e:6 f:5 g:4 h:3 i:2 j:1 k:0]
        print sort.values #[a:10 b:9 c:8 d:7 e:6 f:5 g:4 h:3 i:2 j:1 k:0]
        sort.values 'd5, print d5
        ; => [k:0 j:1 i:2 h:3 g:4 f:5 e:6 d:7 c:8 b:9 a:10]

    ]

    ; [Collections/sort] attributes missing for :dictionary #922
    topic "sort - .descending .sensitive .as with :block and :dictionary"
    do [

        a1: ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        print sort.descending ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        sort.descending 'a1, print a1

        d1: #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        print sort.descending.values #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        sort.descending.values 'd1, print d1

        a2: ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        print sort.descending.as: 'es ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        sort.descending.as: 'es 'a2, print a2
        ; => [uno Uno tres perversión dos abismo aberración ábaco]

        d2: #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        print sort.descending.values.as: 'es #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        sort.descending.values.as: 'es 'd2, print d2
        ; ; => [a:uno d:Uno c:tres e:perversión b:dos g:abismo h:aberración f:ábaco]

        a3: ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        print sort.descending.sensitive ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        sort.descending.sensitive 'a3, print a3
        ; => [ábaco uno tres perversión dos abismo aberración Uno]

        d3: #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        print sort.descending.values.sensitive #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        sort.descending.values.sensitive 'd3, print d3
        ; ; => [f:ábaco a:uno c:tres e:perversión b:dos g:abismo h:aberración d:Uno]

        a4: ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        print sort.descending.sensitive.as: 'es ["uno","dos","tres","Uno","perversión","ábaco","abismo", "aberración"]
        sort.descending.sensitive.as: 'es 'a4, print a4
        ; => [uno tres perversión dos abismo aberración ábaco Uno]

        d4: #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        print sort.descending.values.sensitive.as: 'es #[a:"uno" b:"dos" c:"tres" d:"Uno" e:"perversión" f:"ábaco" g:"abismo" h:"aberración"]
        sort.descending.values.sensitive.as: 'es 'd4, print d4
        ; ; => [a:uno c:tres e:perversión b:dos g:abismo h:aberración f:ábaco d:Uno]

        a5: [0 1 2 3 4 5 6 7 8 9 10]
        print sort.descending [0 1 2 3 4 5 6 7 8 9 10]
        sort.descending 'a5, print a5
        ; => [10 9 8 7 6 5 4 3 2 1 0]

        d5: #[a:0 b:1 c:2 d:3 e:4 f:5 g:6 h:7 i:8 j:9 k:10]
        print sort.descending.values #[a:0 b:1 c:2 d:3 e:4 f:5 g:6 h:7 i:8 j:9 k:10]
        sort.descending.values 'd5, print d5
        ; => [k:10 j:9 i:8 h:7 g:6 f:5 e:4 d:3 c:2 b:1 a:0]

    ]


    topic "sort - .by"
    do [

        user1: #[ name: "John" surname: "Doe" ]
        user2: #[ name: "Jane" surname: "Doe" ]
        user3: #[ name: "John" surname: "Wick" ]
        user4: #[ name: "Arnold" surname: "Schwarzenegger" ]

        arr: @[user1 user2 user3 user4]
        debug sort.by: "surname" arr
        debug sort.by: 'name arr

    ]
]


topic "sorted?"
do [

    print sorted? [1 2 3 4 5]
    print sorted? [4 3 2 1 5]
    print sorted? [5 4 3 2 1] 
    print sorted? ["Arturo" "Python" "Ruby"]
    print sorted? ["Python" "Ruby" "Arturo"]
    print sorted? ["Ruby" "Python" "Arturo"] 
    
    ; .descending
    print sorted?.descending [5 4 3 2 1]
    print sorted?.descending [4 3 2 1 5]
    print sorted?.descending [1 2 3 4 5]
    print sorted?.descending ["Ruby" "Python" "Arturo"] 
    print sorted?.descending ["Python" "Ruby" "Arturo"]
    print sorted?.descending ["Arturo" "Python" "Ruby"]

]


topic "split"
do [

    ; default
    debug split "Arturo"
    
    a: "Arturo"
    split 'a, debug a

    debug split [[1 2 3] [4 5 6] [7 8]]
    b: [[1 2 3] [4 5 6] [7 8]]
    split 'b, debug b

    debug split [1 2 3 4 5 6]
    c: [1 2 3 4 5 6]
    split 'c, debug c

    topic "split - .path"
    do [

        ; They would return the same result
        (sys\os = "windows")? [
            ; Accepts \\ and / paths
            debug split.path "directory\\wofilerld"
            debug split.path "\\usr\\bin"

            p1: "directory\\wofilerld\\"
            p2: "\\usr\\bin"
        ][
            ; Accepts / paths
            debug split.path "directory/wofilerld"
            debug split.path "/usr/bin"

            p1: "directory/wofilerld/"
            p2: "/usr/bin"
        ]

        debug split.path p1
        debug split.path p2
        split.path 'p1, debug p1
        split.path 'p2, debug p2

        ; tests the Unix's default path and Windows' alternative
        ; Since, you can use it on Msys, for instance
        ; it gives the same result in both
        debug split.path "/usr/bin/"
        debug split.path "/usr/bin"
        debug split.path "usr/bin/"

    ]

    topic "split - .words & .lines"
    do [

        debug split.words "Hello World!"
        s1: "Hello World!"
        split.words 's1, debug s1

        debug split.lines "Hi\nmy\nname\nis..."
        s2: "Hi\nmy\nname\nis..."
        split.lines 's2, debug s2

    ]

    topic "split - .by"
    do [

        debug split.by: "/" "directory/file.ext"

        csv: "id;nickname;name;age"
        split.by: ";" 'csv, debug csv

    ]

    topic "split - .at"
    do [

        debug split.at: 5 "Hello, World"
        s: "Hello, World"
        split.at: 5 's, debug s

        debug split.at: 4 [
            "Arnold" "Andreas" "Paul" "Ricard" "Linus"
            "Yanis" "Helena" "Eva" "Blanca"
        ]

        b: [
            "Arnold" "Andreas" "Paul" "Ricard" "Linus"
            "Yanis" "Helena" "Eva" "Blanca"
        ]
        split.at: 4 'b, debug b

    ]

    topic "split - .every"
    do [

        debug split.every: 3 "split collection to components"
        debug split.every: 3 [
            "Arnold" "Andreas" "Paul" "Ricard" "Linus"
            "Yanis" "Helena" "Eva" "Blanca"
        ]


        b: ["Arnold" "Andreas" "Paul" 
            "Ricard" "Linus" "Yanis" 
            "Helena" "Eva" "Blanca"
        ]
        split.every: 3 'b, debug b

        city: split.every: 3 "Manchester"
        print [city, size city\0, size city\1, size city\2, size city\3]

        lang: split.every: 4 "Arturo"
        print [lang, size lang\0, size lang\1]

        city2: "Manchester"
        lang2: "Arturo"
        split.every: 3 'city2
        split.every: 4 'lang2
        print [city2, size city2\0, size city2\1, size city2\2, size city2\3]
        print [lang2, size lang2\0 size, lang2\1]

    ]

]


topic "squeeze"
do [

    debug squeeze [1 1 2 3 4 2 3 4 4 5 5 6 7]

    debug squeeze [1 [4 2 3] 1 2 3 [4 2 3] 4 4 5 5 [6 7] [6 7]]
    a1: [1 [4 2 3] 1 2 3 [4 2 3] 4 4 5 5 [6 7] [6 7]]
    squeeze 'a1, debug a1
    debug squeeze "hello world"
    
    str: "hello world"
    squeeze 'str, debug str

    arr: [4 2 1 1 3 6 6]
    squeeze 'arr, debug arr

]


topic "take"
do [

    debug take "some text" 7
    s: "some text"
    take 's 7, debug s
    debug take ["Arnold" "Andreas" "Paul"] 2
    b: ["Arnold" "Andreas" "Paul"]
    take 'b 2, debug b

    debug take 1..10 3
    arr: 1..10
    take 'arr 3, debug arr

]


topic "tally"
do [
    debug tally "helloWorld"
    debug tally [1 2 4 1 3 5 6 2 6 3 5 7 2 4 2 4 5 6 2 1 1 1]
]


topic "unique"
do [
    
    ; :block
    debug unique [1 2 4 1 3 2]
    b: [1 2 4 1 3 2]
    unique 'b, debug b

    id1: unique.id [1 2 4 1 3 2]
    id2: unique.id [1 2 4 1 3 2 5 6 5 7 4]
    print id1 <> id2

    ; :string
    debug unique "Arturo"
    s: "Arturo"
    unique 's, debug s

    sid1: unique.id "Arturo"
    sid2: unique.id "Python"
    print sid1 <> sid2

]


topic "values"
do [

    ; Do nothing?
    debug values ["Arturo" "Ruby" "Python" "Nim"]

    r1: 1..10
    r2: range 1 10
    debug values 1..10
    debug values range 1 10
    debug values r1
    debug values r2

    user: #[
        name: "John"
        surname: "Doe"
        id: "012568"
        city: "Manchester"
        age: 45
    ]

    debug values user

    ; test with :object
    define :person [name, surname][
        init: ->
            this\name: capitalize this\name
        
        print: ->
            ~"NAME: |this\name|, SURNAME: |this\surname|"
    ]

    personA: to :person ["John" "Doe"]
    debug personA
    debug values personA

]


topic "zero?"
do [
    topic "zero? - with :integer"
    debug zero? 5-5
    debug zero? 4-3

    topic "zero? - with :floating"
    debug zero? 0.0
    debug zero? 1.0

    topic "zero? - with :string"
    debug zero? ""
    debug zero? "Arturo"

    topic "zero? - with :block"
    debug zero? [] 
    debug zero? ["apple" "pear"] 

    topic "zero? - with :range"
    debug zero? 0..0
    debug zero? range 0 0
    debug zero? 0..10
    debug zero? range 0 10
    debug zero? ø

    topic "zero? - with :dictionary"
    debug zero? #[]
    debug zero? #[ name: "John" ]

    ; topic "zero? - with :object"
    define :person [][
    ]

    personA: to :person []
    debug personA
    debug zero? personA

    topic "zero? - with :null"
    debug zero? null

]
