; A simple pipe
2 | print

; ...should be equivalent to:
print 2

; A tiny-bit more complicated pipe
2 | add 3 | print

; And a pipe split in different lines
2 | add 3
  | print

; ...should both be equivalent to:
print add 2 3

; Something even more complicated
["one" "two"] | map 'x [upper x]
              | print

; ...should be equivalent to:
print map ["one" "two"] 'x -> upper x

; Let's level up
1..10 | map 'x -> 2*x
      | print

; ...should be equivalent to:
print map 1..10 'x -> 2*x

; And a bit more
1..10 | map 'x [3*x]
      | select 'x [odd? x]
      | print

; ...should be equivalent to:
print select map 1..10 'x [3*x] 'x [odd? x]

; With assignment
z: 2 | add 3 | sub 1
print z

; ...should be equivalent to:
z: 2 | add 3
     | sub 1
print z

; ...and also to:
z: sub add 2 3 1
print z

print repeat "=" 60
;-----------------------------------------------------------------------------
testNo: 0
section: function [topic].inline[
      testNo: 0
      print ["\n>>" topic]
]

; what's the best way to verify the pipe transformations work, 
; other than that they produce the exact same bytecode
; as the "normal" code?! :)
check: function [block1 block2].inline[
      testNo: testNo + 1
      b1: to.intrepid :bytecode block1
      b2: to.intrepid :bytecode block2

      if? b1 = b2 -> print [pad to :string testNo 2 ": [+] passed!"]
      else [
            print [pad to :string testNo 2 ": [-] failed!"]
            inspect b1
            print repeat "-" 10
            inspect b2
            
            panic.code:1 "Test failed!"
      ]
]

section "Simple call with one param"

      check [print 2] [2 | print]
      ; also check the exact same thing
      ; only with newlines in between; you never know...
      check [
            print 2
      ][
            2 | 
            print
      ]
      check [
            print
            2
      ][
            2 
            | 
            print
      ]
      check [
            print "before"
            print 2
            print "after"
      ][
            print "before"
            2 | print
            print "after"
      ]

section "Simple call with two params"

      check [add 2 x] [2 | add x]
      check [
            add 2 x
      ][
            2 | add x
      ]
      check [
            add 2 x
      ][
            2 
            | add x
      ]
      check [
            add
            2
            x
      ][
            2 
            | 
            add x
      ]
      check [
            print "before"
            add 2 x
            print "after"
      ][
            print "before"
            2 | add x
            print "after"
      ]

section "Assignment with an one-param call"

      check [x: even? 2][x: 2 | even?]
      check [
            x: even? 2
      ][
            x:
            2 | even?
      ]
      check [
            x: even? 2
      ][
            x: 2 
            | even?
      ]
      check [
            x: even? 2
      ][
            x: 2 
            | 
            even?
      ]
      check [
            print "before"
            x: even? 2
            print "after"
      ][
            print "before"
            x: 2 | even?
            print "after"
      ]

section "Assignment with a two-param call"

      check [x: add 2 z][x: 2 | add z]
      check [
            x: add 2 z
      ][
            x:
            2 | add z
      ]
      check [
            x: add 2 z
      ][
            x: 2 
            | add z
      ]
      check [
            x: add 2 z
      ][
            x: 2 
            | 
            add z
      ]
      check [
            print "before"
            x: add 2 z
            print "after"
      ][
            print "before"
            x: 2 | add z
            print "after"
      ]

section "Call as initial argument"

      check [print 1..3][1..3 | print]
      check [
            print 1..3
      ][
            1..3 | print
      ]
      check [
            print 1..3
      ][
            1..3 
            | print
      ]
      check [
            print 1..3
      ][
            1..3 
            | 
            print
      ]
      check [
            print "before"
            print 1..3
            print "after"
      ][
            print "before"
            1..3 | print
            print "after"
      ]

section "Assignment with call as initial argument"

      check [x: max 1..10][x: 1..10 | max]
      check [
            x: max 1..10
      ][
            x:
            1..10 | max
      ]
      check [
            x: max 1..10
      ][
            x: 1..10 
            | max
      ]
      check [
            x: max 1..10
      ][
            x: 1..10 
            | 
            max
      ]
      check [
            print "before"
            x: max 1..10
            print "after"
      ][
            print "before"
            x: 1..10 | max
            print "after"
      ]

section "Pipes + Attributes"

      check [split.words "hello world"]["hello world" | split.words]
      check [
            split.words "hello world"
      ][
            "hello world" | split.words
      ]
      check [
            split.words "hello world"
      ][
            "hello world" 
            | split.words
      ]
      check [
            split.words "hello world"
      ][
            "hello world" 
            | 
            split.words
      ]
      check [
            print "before"
            split.words "hello world"
            print "after"
      ][
            print "before"
            "hello world" | split.words
            print "after"
      ]
      check [
            print "before"
            split.words "hello world"
            print "after"
            z: split.words "one two three"
            print "final"
      ][
            print "before"
            "hello world" | split.words
            print "after"
            z: split.words "one two three"
            print "final"
      ]

section "Pipes + Attributes (+ Assignment)"

      check [x: split.words "hello world"][x: "hello world" | split.words]
      check [
            x: split.words "hello world"
      ][
            x:
            "hello world" | split.words
      ]
      check [
            x: split.words "hello world"
      ][
            x: "hello world" 
            | split.words
      ]
      check [
            x: split.words "hello world"
      ][
            x: "hello world" 
            | 
            split.words
      ]
      check [
            print "before"
            x: split.words "hello world"
            print "after"
      ][
            print "before"
            x: "hello world" | split.words
            print "after"
      ]
      check [
            print "before"
            x: split.words "hello world"
            print "after"
            z: split.words "one two three"
            print "final"
      ][
            print "before"
            x: "hello world" | split.words
            print "after"
            z: split.words "one two three"
            print "final"
      ]

section "Pipes + AttributeLabels"

      check [split.every:3 "hello world"]["hello world" | split.every:3]
      check [
            split.every:3 "hello world"
      ][
            "hello world" | split.every:3
      ]
      check [
            split.every:3 "hello world"
      ][
            "hello world" 
            | split.every:3
      ]
      check [
            split.every:3 "hello world"
      ][
            "hello world" 
            | 
            split.every:3
      ]
      check [
            print "before"
            split.every:3 "hello world"
            print "after"
      ][
            print "before"
            "hello world" | split.every:3
            print "after"
      ]
      check [
            print "before"
            split.every:3 "hello world"
            print "after"
            z: split.words "one two three"
            print "final"
      ][
            print "before"
            "hello world" | split.every:3
            print "after"
            z: split.words "one two three"
            print "final"
      ]

section "Pipes + AttributeLabels (+ Assignment)"

      check [x: split.every:3 "hello world"][x: "hello world" | split.every:3]
      check [
            x: split.every:3 "hello world"
      ][
            x:
            "hello world" | split.every:3
      ]
      check [
            x: split.every:3 "hello world"
      ][
            x: "hello world" 
            | split.every:3
      ]
      check [
            x: split.every:3 "hello world"
      ][
            x: "hello world" 
            | 
            split.every:3
      ]
      check [
            print "before"
            x: split.every:3 "hello world"
            print "after"
      ][
            print "before"
            x: "hello world" | split.every:3
            print "after"
      ]
      check [
            print "before"
            x: split.every:3 "hello world"
            print "after"
            z: split.words "one two three"
            print "final"
      ][
            print "before"
            x: "hello world" | split.every:3
            print "after"
            z: split.words "one two three"
            print "final"
      ]

section "Using pipes + iterators"

      check [
            print select map 1..10 'x -> x * 3 => even?
      ][
            1..10 | map 'x -> x * 3 
                  | select => even?
                  | print
      ]
      check [
            print "before"
            print select map 1..10 'x -> x * 3 => even?
            print "after"
      ][
            print "before"
            1..10 | 
                  map 'x 
                  -> x * 3 
                  | 
                  select 
                  => even?
                  | 
                  print
            print "after"
      ]

section "Real-world testing"

      ; from: examples/rosetta/smarandache prime-digital sequence.art
      check [
            spds: select.first:100 2..∞ 'x ->
                        and? -> prime? x
                             -> every? digits x => prime?
            
            print "First 25 SPDS primes:"
            print first.n: 25 spds

            print ""
            print ["100th SPDS prime:" last spds]
      ][
            spds: 2..∞ | select.first:100 'x ->
                        and? -> prime? x
                              -> every? digits x => prime?

            print "First 25 SPDS primes:"
            print first.n: 25 spds

            print ""
            print ["100th SPDS prime:" last spds]
      ]

      ; from: examples/rosetta/concatenate two primes is also prime.art
      check [
            primesBelow100: select 1..100 => prime?
            allPossibleConcats: permutate.repeat.by:2 primesBelow100

            concatPrimes: unique sort select map allPossibleConcats 'x -> to :integer (to :string x\[0]) ++ (to :string x\[1]) => prime?

            print ["Found" size concatPrimes "concatenations of primes below 100:"]
            loop split.every: 16 concatPrimes 'x ->
            print map x 's -> pad to :string s 4
      ][
            primesBelow100: select 1..100 => prime?
            allPossibleConcats: permutate.repeat.by:2 primesBelow100

            concatPrimes: allPossibleConcats | map 'x -> to :integer (to :string x\[0]) ++ (to :string x\[1])
                                             | select => prime?
                                             | sort
                                             | unique

            print ["Found" size concatPrimes "concatenations of primes below 100:"]
            loop split.every: 16 concatPrimes 'x ->
            print map x 's -> pad to :string s 4
      ]